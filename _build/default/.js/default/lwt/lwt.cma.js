// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Lwt_sequence
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Empty = [248, "Lwt_sequence.Empty", runtime.caml_fresh_oo_id(0)];
   function get(node){return node[3];}
   function set(node, data){node[3] = data; return 0;}
   function remove(node){
    var
     _k_ = node[4],
     _l_ =
       _k_
        ? (node[4] = 0, node[1][2] = node[2], node[2][1] = node[1], 0)
        : _k_;
    return _l_;
   }
   function create(param){
    var seq = [];
    runtime.caml_update_dummy(seq, [0, seq, seq]);
    return seq;
   }
   function clear(seq){seq[1] = seq; seq[2] = seq; return 0;}
   function is_empty(seq){return seq[2] === seq ? 1 : 0;}
   function length(seq){
    var curr$1 = seq[2], curr = curr$1, len = 0;
    for(;;){
     if(curr === seq) return len;
     var len$0 = len + 1 | 0, curr$0 = curr[2];
     curr = curr$0;
     len = len$0;
    }
   }
   function add_l(data, seq){
    var node = [0, seq, seq[2], data, 1];
    seq[2][1] = node;
    seq[2] = node;
    return node;
   }
   function add_r(data, seq){
    var node = [0, seq[1], seq, data, 1];
    seq[1][2] = node;
    seq[1] = node;
    return node;
   }
   function take_l(seq){
    if(is_empty(seq)) throw caml_maybe_attach_backtrace(Empty, 1);
    var node = seq[2];
    remove(node);
    return node[3];
   }
   function take_r(seq){
    if(is_empty(seq)) throw caml_maybe_attach_backtrace(Empty, 1);
    var node = seq[1];
    remove(node);
    return node[3];
   }
   function take_opt_l(seq){
    if(is_empty(seq)) return 0;
    var node = seq[2];
    remove(node);
    return [0, node[3]];
   }
   function take_opt_r(seq){
    if(is_empty(seq)) return 0;
    var node = seq[1];
    remove(node);
    return [0, node[3]];
   }
   function transfer_l(s1, s2){
    s2[2][1] = s1[1];
    s1[1][2] = s2[2];
    s2[2] = s1[2];
    s1[2][1] = s2;
    s1[1] = s1;
    s1[2] = s1;
    return 0;
   }
   function transfer_r(s1, s2){
    s2[1][2] = s1[2];
    s1[2][1] = s2[1];
    s2[1] = s1[1];
    s1[1][2] = s2;
    s1[1] = s1;
    s1[2] = s1;
    return 0;
   }
   function iter_l(f, seq){
    var curr$1 = seq[2], curr = curr$1;
    for(;;){
     var _j_ = curr !== seq ? 1 : 0;
     if(! _j_) return _j_;
     if(curr[4]) caml_call1(f, curr[3]);
     var curr$0 = curr[2];
     curr = curr$0;
    }
   }
   function iter_r(f, seq){
    var curr$1 = seq[1], curr = curr$1;
    for(;;){
     var _i_ = curr !== seq ? 1 : 0;
     if(! _i_) return _i_;
     if(curr[4]) caml_call1(f, curr[3]);
     var curr$0 = curr[1];
     curr = curr$0;
    }
   }
   function iter_node_l(f, seq){
    var curr$1 = seq[2], curr = curr$1;
    for(;;){
     var _h_ = curr !== seq ? 1 : 0;
     if(! _h_) return _h_;
     if(curr[4]) caml_call1(f, curr);
     var curr$0 = curr[2];
     curr = curr$0;
    }
   }
   function iter_node_r(f, seq){
    var curr$1 = seq[1], curr = curr$1;
    for(;;){
     var _g_ = curr !== seq ? 1 : 0;
     if(! _g_) return _g_;
     if(curr[4]) caml_call1(f, curr);
     var curr$0 = curr[1];
     curr = curr$0;
    }
   }
   function fold_l(f, seq, acc){
    var curr$2 = seq[2], curr = curr$2, acc$0 = acc;
    for(;;){
     if(curr === seq) return acc$0;
     if(curr[4]){
      var acc$1 = caml_call2(f, curr[3], acc$0), curr$0 = curr[2];
      curr = curr$0;
      acc$0 = acc$1;
     }
     else{var curr$1 = curr[2]; curr = curr$1;}
    }
   }
   function fold_r(f, seq, acc){
    var curr$2 = seq[1], curr = curr$2, acc$0 = acc;
    for(;;){
     if(curr === seq) return acc$0;
     if(curr[4]){
      var acc$1 = caml_call2(f, curr[3], acc$0), curr$0 = curr[1];
      curr = curr$0;
      acc$0 = acc$1;
     }
     else{var curr$1 = curr[1]; curr = curr$1;}
    }
   }
   function find_node_l(f, seq){
    var curr$2 = seq[2], curr = curr$2;
    for(;;){
     if(curr === seq) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(curr[4]){
      if(caml_call1(f, curr[3])) return curr;
      var curr$0 = curr[2];
      curr = curr$0;
     }
     else{var curr$1 = curr[2]; curr = curr$1;}
    }
   }
   function find_node_r(f, seq){
    var curr$2 = seq[1], curr = curr$2;
    for(;;){
     if(curr === seq) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(curr[4]){
      if(caml_call1(f, curr[3])) return curr;
      var curr$0 = curr[1];
      curr = curr$0;
     }
     else{var curr$1 = curr[1]; curr = curr$1;}
    }
   }
   function find_node_opt_l(f, seq){
    try{var _e_ = [0, find_node_l(f, seq)]; return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function find_node_opt_r(f, seq){
    try{var _b_ = [0, find_node_r(f, seq)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var
    Lwt_sequence =
      [0,
       get,
       set,
       remove,
       create,
       clear,
       is_empty,
       length,
       add_l,
       add_r,
       Empty,
       take_l,
       take_r,
       take_opt_l,
       take_opt_r,
       transfer_l,
       transfer_r,
       iter_l,
       iter_r,
       iter_node_l,
       iter_node_r,
       fold_l,
       fold_r,
       find_node_opt_l,
       find_node_opt_r,
       find_node_l,
       find_node_r];
   runtime.caml_register_global(2, Lwt_sequence, "Lwt_sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Lwt_sequence, Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Map, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Lwt = "Lwt.",
    cst_Lwt_s = "Lwt.%s",
    cst_src_core_lwt_ml = "src/core/lwt.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Map = global_data.Stdlib__Map,
    compare = runtime.caml_compare,
    Storage_map = caml_call1(Stdlib_Map[1], [0, compare]);
   function state_of_result(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var exn = param[1];
    return [1, exn];
   }
   function underlying(p){
    var match = p[1];
    switch(match[0]){
      case 0:
       return p;
      case 1:
       return p;
      case 2:
       return p;
      default:
       var p2 = match[1], p1 = underlying(p2);
       if(1 - (p1 === p2 ? 1 : 0)) p[1] = [3, p1];
       return p1;
    }
   }
   function handle_all(param){return 1;}
   function handle_all_except_runtime(param){
    return param === Stdlib[9] ? 0 : param === Stdlib[10] ? 0 : 1;
   }
   var v = [0, handle_all];
   function set(f){v[1] = f; return 0;}
   function run(e){return caml_call1(v[1], e);}
   var next_key_id = [0, 0];
   function new_key(param){
    var id = next_key_id[1];
    next_key_id[1] = id + 1 | 0;
    return [0, id, 0];
   }
   var
    current_storage = [0, Storage_map[1]],
    _a_ = [0, cst_src_core_lwt_ml, 978, 23],
    _b_ = [0, cst_src_core_lwt_ml, 979, 22],
    cst_Fatal_error_exception = "Fatal error: exception ";
   function get(key){
    if(! caml_call2(Storage_map[3], key[1], current_storage[1])) return 0;
    var refresh = caml_call2(Storage_map[28], key[1], current_storage[1]);
    caml_call1(refresh, 0);
    var value = key[2];
    key[2] = 0;
    return value;
   }
   function with_value(key, value, f){
    if(value)
     var
      refresh = function(param){key[2] = value; return 0;},
      new_storage =
        caml_call3(Storage_map[4], key[1], refresh, current_storage[1]);
    else
     var new_storage = caml_call2(Storage_map[7], key[1], current_storage[1]);
    var saved_storage = current_storage[1];
    current_storage[1] = new_storage;
    try{
     var result = caml_call1(f, 0);
     current_storage[1] = saved_storage;
     return result;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     current_storage[1] = saved_storage;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function concat_regular_callbacks(l1, l2){
    return typeof l1 === "number"
            ? l2
            : typeof l2 === "number" ? l1 : [0, l1, l2];
   }
   function clean_up_callback_cells(callbacks){
    if(typeof callbacks !== "number")
     switch(callbacks[0]){
       case 0:
        var
         l2 = callbacks[2],
         l1 = callbacks[1],
         l1$0 = clean_up_callback_cells(l1),
         l2$0 = clean_up_callback_cells(l2);
        return concat_regular_callbacks(l1$0, l2$0);
       case 2:
        if(! callbacks[1][1]) return 0; break;
     }
    return callbacks;
   }
   function clear_explicitly_removable_cal(cell, ps){
    cell[1] = 0;
    return caml_call1
            (caml_call1
              (Stdlib_List[17],
               function(p){
                var match = underlying(p)[1];
                switch(match[0]){
                  case 1:
                   return 0;
                  case 2:
                   var callbacks = match[1], _aW_ = callbacks[1];
                   if(typeof _aW_ !== "number" && 2 === _aW_[0]){callbacks[1] = 0; return 0;}
                   var cleanups_deferred = callbacks[4] + 1 | 0;
                   return 42 < cleanups_deferred
                           ? (callbacks
                              [4]
                             = 0,
                             callbacks[1] = clean_up_callback_cells(callbacks[1]),
                             0)
                           : (callbacks[4] = cleanups_deferred, 0);
                  default: return 0;
                }
               }),
             ps);
   }
   function add_regular_callback_list_node(callbacks, node){
    var
     existing = callbacks[1],
     node$0 = typeof existing === "number" ? node : [0, node, existing];
    callbacks[1] = node$0;
    return 0;
   }
   function add_implicitly_removed_callbac(callbacks, f){
    return add_regular_callback_list_node(callbacks, [1, f]);
   }
   function add_explicitly_removable_callb(ps, f){
    var
     cell = [],
     self_removing_callback_wrapper =
       function _aV_(_aU_){return _aV_.fun(_aU_);};
    caml_update_dummy(cell, [0, [0, self_removing_callback_wrapper]]);
    caml_update_dummy
     (self_removing_callback_wrapper,
      function(result){
       clear_explicitly_removable_cal(cell, ps);
       return caml_call1(f, result);
      });
    var node = [2, cell];
    caml_call1
     (caml_call1
       (Stdlib_List[17],
        function(p){
         var match = underlying(p)[1];
         switch(match[0]){
           case 1:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
           case 2:
            var callbacks = match[1];
            return add_regular_callback_list_node(callbacks, node);
           default:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         }
        }),
      ps);
    return cell;
   }
   function add_explicitly_removable_callb$0(ps, f){add_explicitly_removable_callb(ps, f);
   }
   function add_cancel_callback(callbacks, f){
    var
     node = [1, current_storage[1], f],
     node$0 =
       typeof callbacks[2] === "number" ? node : [0, node, callbacks[2]];
    callbacks[2] = node$0;
    return 0;
   }
   var
    async_exception_hook =
      [0,
       function(exn){
        caml_call1(Stdlib[49], cst_Fatal_error_exception);
        var _aT_ = caml_call1(Stdlib_Printexc[1], exn);
        caml_call1(Stdlib[49], _aT_);
        caml_call1(Stdlib[48], 10);
        caml_call1(Stdlib_Printexc[5], Stdlib[40]);
        caml_call1(Stdlib[63], Stdlib[40]);
        return caml_call1(Stdlib[99], 2);
       }];
   function handle_with_async_exception_ho(f, v){
    try{var _aS_ = caml_call1(f, v); return _aS_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return caml_call1(async_exception_hook[1], exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    Canceled =
      [248, "Lwt.Resolution_loop.Canceled", runtime.caml_fresh_oo_id(0)];
   function run_callbacks(callbacks, result){
    if(1 === result[0])
     var _aR_ = result[1] === Canceled ? 1 : 0, is_canceled = _aR_;
    else
     var is_canceled = 0;
    if(is_canceled){
     var
      fs = callbacks[2],
      iter_callback_list$2 =
        function(counter, fs, rest){
         var fs$0 = fs, rest$0 = rest;
         for(;;){
          if(typeof fs$0 === "number"){
           if(counter >= 50)
            return caml_trampoline_return(iter_list$0, [0, rest$0]);
           var counter$0 = counter + 1 | 0;
           return iter_list$0(counter$0, rest$0);
          }
          switch(fs$0[0]){
            case 0:
             var fs$1 = fs$0[2], fs$2 = fs$0[1], rest$1 = [0, fs$1, rest$0];
             fs$0 = fs$2;
             rest$0 = rest$1;
             break;
            case 1:
             var f = fs$0[2], storage = fs$0[1];
             current_storage[1] = storage;
             handle_with_async_exception_ho(f, 0);
             if(counter >= 50)
              return caml_trampoline_return(iter_list$0, [0, rest$0]);
             var counter$1 = counter + 1 | 0;
             return iter_list$0(counter$1, rest$0);
            default:
             var node = fs$0[1];
             caml_call1(Lwt_sequence[3], node);
             if(counter >= 50)
              return caml_trampoline_return(iter_list$0, [0, rest$0]);
             var counter$2 = counter + 1 | 0;
             return iter_list$0(counter$2, rest$0);
          }
         }
        },
      iter_callback_list =
        function(fs, rest){
         return caml_trampoline(iter_callback_list$2(0, fs, rest));
        },
      iter_list$0 =
        function(counter, rest){
         if(! rest) return;
         var rest$0 = rest[2], fs = rest[1];
         if(counter >= 50)
          return caml_trampoline_return(iter_callback_list$2, [0, fs, rest$0]);
         var counter$0 = counter + 1 | 0;
         return iter_callback_list$2(counter$0, fs, rest$0);
        };
     iter_callback_list(fs, 0);
    }
    var fs$0 = callbacks[1];
    function iter_callback_list$1(counter, fs, rest){
     var fs$0 = fs, rest$0 = rest;
     for(;;){
      if(typeof fs$0 === "number"){
       if(counter >= 50)
        return caml_trampoline_return(iter_list, [0, rest$0]);
       var counter$0 = counter + 1 | 0;
       return iter_list(counter$0, rest$0);
      }
      switch(fs$0[0]){
        case 0:
         var fs$1 = fs$0[2], fs$2 = fs$0[1], rest$1 = [0, fs$1, rest$0];
         fs$0 = fs$2;
         rest$0 = rest$1;
         break;
        case 1:
         var f = fs$0[1];
         caml_call1(f, result);
         if(counter >= 50)
          return caml_trampoline_return(iter_list, [0, rest$0]);
         var counter$1 = counter + 1 | 0;
         return iter_list(counter$1, rest$0);
        default:
         var match = fs$0[1][1];
         if(match){
          var f$0 = match[1];
          caml_call1(f$0, result);
          if(counter >= 50)
           return caml_trampoline_return(iter_list, [0, rest$0]);
          var counter$2 = counter + 1 | 0;
          return iter_list(counter$2, rest$0);
         }
         if(counter >= 50)
          return caml_trampoline_return(iter_list, [0, rest$0]);
         var counter$3 = counter + 1 | 0;
         return iter_list(counter$3, rest$0);
      }
     }
    }
    function iter_callback_list$0(fs, rest){
     return caml_trampoline(iter_callback_list$1(0, fs, rest));
    }
    function iter_list(counter, rest){
     if(! rest) return 0;
     var rest$0 = rest[2], fs = rest[1];
     if(counter >= 50)
      return caml_trampoline_return(iter_callback_list$1, [0, fs, rest$0]);
     var counter$0 = counter + 1 | 0;
     return iter_callback_list$1(counter$0, fs, rest$0);
    }
    return iter_callback_list$0(fs$0, 0);
   }
   var
    current_callback_nesting_depth = [0, 0],
    deferred_callbacks = caml_call1(Stdlib_Queue[2], 0),
    default_maximum_callback_nesti = 42,
    _c_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _d_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _e_ = [0, 0],
    cst_wakeup_result = "wakeup_result",
    cst_wakeup = "wakeup",
    cst_wakeup_exn = "wakeup_exn",
    _f_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _g_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _h_ = [0, 1],
    cst_wakeup_later_result = "wakeup_later_result",
    cst_wakeup_later = "wakeup_later",
    cst_wakeup_later_exn = "wakeup_later_exn",
    _i_ = [0, 0];
   function leave_resolution_loop(storage_snapshot){
    if(1 === current_callback_nesting_depth[1])
     for(;;){
      if(caml_call1(Stdlib_Queue[13], deferred_callbacks)) break;
      var
       match = caml_call1(Stdlib_Queue[7], deferred_callbacks),
       result = match[2],
       callbacks = match[1];
      run_callbacks(callbacks, result);
     }
    current_callback_nesting_depth[1] =
     current_callback_nesting_depth[1] - 1 | 0;
    current_storage[1] = storage_snapshot;
    return 0;
   }
   function run_in_resolution_loop(f){
    current_callback_nesting_depth[1] =
     current_callback_nesting_depth[1] + 1 | 0;
    var storage_snapshot = current_storage[1], result = caml_call1(f, 0);
    leave_resolution_loop(storage_snapshot);
    return result;
   }
   function abandon_wakeups(param){
    var _aQ_ = 0 !== current_callback_nesting_depth[1] ? 1 : 0;
    return _aQ_ ? leave_resolution_loop(Storage_map[1]) : _aQ_;
   }
   function run_callbacks_or_defer_them(opt, _aP_, callbacks, result){
    if(opt)
     var sth = opt[1], allow_deferring = sth;
    else
     var allow_deferring = 1;
    if(_aP_)
     var sth$0 = _aP_[1], maximum_callback_nesting_depth = sth$0;
    else
     var maximum_callback_nesting_depth = default_maximum_callback_nesti;
    var
     should_defer =
       allow_deferring
        ? maximum_callback_nesting_depth
          <= current_callback_nesting_depth[1]
          ? 1
          : 0
        : allow_deferring;
    return should_defer
            ? caml_call2
              (Stdlib_Queue[4], [0, callbacks, result], deferred_callbacks)
            : run_in_resolution_loop
              (function(param){return run_callbacks(callbacks, result);});
   }
   function resolve
   (allow_deferring, maximum_callback_nesting_depth, p, result){
    var callbacks = p[1][1];
    p[1] = result;
    run_callbacks_or_defer_them
     (allow_deferring, maximum_callback_nesting_depth, callbacks, result);
    return p;
   }
   function run_callback_or_defer_it(opt, f, if_deferred){
    if(opt)
     var sth = opt[1], run_immediately_and_ensure_tai = sth;
    else
     var run_immediately_and_ensure_tai = 0;
    if(run_immediately_and_ensure_tai) return caml_call1(f, 0);
    var should_defer = 42 <= current_callback_nesting_depth[1] ? 1 : 0;
    if(! should_defer)
     return run_in_resolution_loop(function(param){return caml_call1(f, 0);});
    var
     match = caml_call1(if_deferred, 0),
     deferred_result = match[3],
     deferred_callback = match[2],
     immediate_result = match[1],
     deferred_record = [0, [1, deferred_callback], 0, 0, 0];
    caml_call2
     (Stdlib_Queue[4],
      [0, deferred_record, deferred_result],
      deferred_callbacks);
    return immediate_result;
   }
   function wakeup_general(api_function_name, r, result){
    var p = underlying(r), _aO_ = p[1];
    switch(_aO_[0]){
      case 1:
       return _aO_[1] === Canceled
               ? 0
               : caml_call3
                 (Stdlib_Printf[10], Stdlib[1], _d_, api_function_name);
      case 2:
       var result$0 = state_of_result(result);
       resolve(_e_, 0, p, result$0);
       return 0;
      default:
       return caml_call3(Stdlib_Printf[10], Stdlib[1], _c_, api_function_name);
    }
   }
   function wakeup_result(r, result){
    return wakeup_general(cst_wakeup_result, r, result);
   }
   function wakeup(r, v){return wakeup_general(cst_wakeup, r, [0, v]);}
   function wakeup_exn(r, exn){
    return wakeup_general(cst_wakeup_exn, r, [1, exn]);
   }
   function wakeup_later_general(api_function_name, r, result){
    var p = underlying(r), _aN_ = p[1];
    switch(_aN_[0]){
      case 1:
       return _aN_[1] === Canceled
               ? 0
               : caml_call3
                 (Stdlib_Printf[10], Stdlib[1], _g_, api_function_name);
      case 2:
       var result$0 = state_of_result(result);
       resolve(0, _h_, p, result$0);
       return 0;
      default:
       return caml_call3(Stdlib_Printf[10], Stdlib[1], _f_, api_function_name);
    }
   }
   function wakeup_later_result(r, result){
    return wakeup_later_general(cst_wakeup_later_result, r, result);
   }
   function wakeup_later(r, v){
    return wakeup_later_general(cst_wakeup_later, r, [0, v]);
   }
   function wakeup_later_exn(r, exn){
    return wakeup_later_general(cst_wakeup_later_exn, r, [1, exn]);
   }
   function cancel(p){
    var canceled_result = [1, Canceled];
    function cancel_and_collect_callbacks(callbacks_accumulator, p){
     var p$0 = p;
     for(;;){
      var p$1 = underlying(p$0), match = p$1[1];
      switch(match[0]){
        case 1:
         return callbacks_accumulator;
        case 2:
         var callbacks = match[1], match$0 = callbacks[3];
         if(typeof match$0 === "number")
          return 0 === match$0
                  ? callbacks_accumulator
                  : (p$1
                     [1]
                    = canceled_result,
                    [0, callbacks, callbacks_accumulator]);
         if(0 !== match$0[0]){
          var ps = match$0[1];
          return caml_call3
                  (Stdlib_List[25],
                   cancel_and_collect_callbacks,
                   callbacks_accumulator,
                   ps);
         }
         var p$2 = match$0[1];
         p$0 = p$2;
         break;
        default: return callbacks_accumulator;
      }
     }
    }
    var callbacks = cancel_and_collect_callbacks(0, p);
    return caml_call1
            (caml_call1
              (Stdlib_List[17],
               function(param){
                return run_callbacks_or_defer_them
                        (_i_, 0, param, canceled_result);
               }),
             callbacks);
   }
   function return$0(v){return [0, [0, v]];}
   function of_result(result){return [0, state_of_result(result)];}
   function fail(exn){return [0, [1, exn]];}
   var return_unit = return$0(0), return_none = return$0(0);
   function return_some(x){return return$0([0, x]);}
   var
    return_nil = return$0(0),
    return_true = return$0(1),
    return_false = return$0(0),
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _n_ = [0, 0],
    _o_ = [0, 1],
    _p_ = [0, 0],
    _q_ = [0, 1],
    _r_ = [0, 0],
    _s_ = [0, 0],
    _t_ = [0, 1],
    _u_ = [0, 0],
    _v_ = [0, 1],
    _w_ = [0, 0],
    _x_ = [0, 1],
    _y_ = [0, 1],
    _z_ = [0, 1],
    _A_ = [0, 1],
    _B_ = [0, 1],
    _C_ = [0, 0],
    _D_ = [0, 1],
    _E_ = [0, 1],
    _F_ = [0, 1],
    _G_ = [0, 1],
    _H_ = [0, 1],
    _I_ = [0, 1],
    _J_ = [0, 1],
    _K_ = [0, 0],
    _L_ = [0, 0],
    _M_ = [0, cst_src_core_lwt_ml, 2649, 13],
    _N_ = [0, cst_src_core_lwt_ml, 2668, 24],
    _O_ = [0, cst_src_core_lwt_ml, 2707, 6],
    _P_ = [0, cst_src_core_lwt_ml, 2727, 6];
   function return_ok(x){return return$0([0, x]);}
   function return_error(x){return return$0([1, x]);}
   function fail_with(msg){return [0, [1, [0, Stdlib[7], msg]]];}
   function fail_invalid_arg(msg){return [0, [1, [0, Stdlib[6], msg]]];}
   function new_pending(how_to_cancel){
    var state = [2, [0, 0, 0, how_to_cancel, 0]];
    return [0, state];
   }
   function wait(param){var p = new_pending(0); return [0, p, p];}
   function task(param){var p = new_pending(1); return [0, p, p];}
   function add_task_r(sequence){
    var
     p = new_pending(1),
     node = caml_call2(Lwt_sequence[9], p, sequence),
     callbacks = p[1][1];
    callbacks[2] = [2, node];
    return p;
   }
   function add_task_l(sequence){
    var
     p = new_pending(1),
     node = caml_call2(Lwt_sequence[8], p, sequence),
     callbacks = p[1][1];
    callbacks[2] = [2, node];
    return p;
   }
   function protected$0(p_internal){
    switch(underlying(p_internal)[1][0]){
      case 1:
       return p_internal;
      case 2:
       var
        p = new_pending(1),
        callback =
          function(p_result){
           var p$0 = underlying(p);
           resolve(_j_, 0, p$0, p_result);
           return 0;
          },
        ps = [0, p_internal, 0],
        cell = add_explicitly_removable_callb(ps, callback),
        remove_the_callback =
          function(param){return clear_explicitly_removable_cal(cell, ps);},
        p_callbacks = p[1][1];
       add_cancel_callback(p_callbacks, remove_the_callback);
       return p;
      default: return p_internal;
    }
   }
   function no_cancel(p_internal){
    var match = underlying(p_internal)[1];
    switch(match[0]){
      case 1:
       return p_internal;
      case 2:
       var
        p_callbacks = match[1],
        p = new_pending(0),
        callback =
          function(p_result){
           var p$0 = underlying(p);
           resolve(_k_, 0, p$0, p_result);
           return 0;
          };
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p;
      default: return p_internal;
    }
   }
   function make_into_proxy(outer_promise, user_provided_promise){
    var p1 = underlying(user_provided_promise);
    if(p1 === outer_promise) return p1;
    var match = p1[1];
    switch(match[0]){
      case 1:
       return resolve(_m_, 0, outer_promise, p1[1]);
      case 2:
       var
        p_callbacks = match[1],
        outer_callbacks = outer_promise[1][1],
        regular_callbacks =
          concat_regular_callbacks(outer_callbacks[1], p_callbacks[1]),
        cleanups_deferred = outer_callbacks[4] + p_callbacks[4] | 0;
       if(42 < cleanups_deferred)
        var
         cleanups_deferred$0 = 0,
         regular_callbacks$0 = clean_up_callback_cells(regular_callbacks);
       else
        var
         cleanups_deferred$0 = cleanups_deferred,
         regular_callbacks$0 = regular_callbacks;
       var
        l2 = p_callbacks[2],
        l1 = outer_callbacks[2],
        cancel_callbacks =
          typeof l1 === "number"
           ? l2
           : typeof l2 === "number" ? l1 : [0, l1, l2];
       outer_callbacks[1] = regular_callbacks$0;
       outer_callbacks[2] = cancel_callbacks;
       outer_callbacks[4] = cleanups_deferred$0;
       outer_callbacks[3] = p_callbacks[3];
       var state = [3, outer_promise];
       p1[1] = state;
       return outer_promise;
      default: return resolve(_l_, 0, outer_promise, p1[1]);
    }
   }
   function symbol_bind(p, f){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var p$2 = underlying(p);
       resolve(_n_, 0, p$2, p_result);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aM_ = caml_call1(f, v), p$0 = _aM_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(exn);
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var result = p$0[1];
    switch(result[0]){
      case 1:
       return [0, result];
      case 2:
       var
        p_callbacks = result[1],
        match = create_result_promise_and_call(0),
        callback = match[2],
        p$1 = match[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = result[1];
       return run_callback_or_defer_it
               (_o_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function backtrace_bind(add_loc, p, f){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1], p$2 = underlying(p);
       resolve(_p_, 0, p$2, [1, caml_call1(add_loc, exn$0)]);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aL_ = caml_call1(f, v), p$0 = _aL_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(caml_call1(add_loc, exn));
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; return [0, [1, caml_call1(add_loc, exn)]];
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_q_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function symbol(f, p){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var p$1 = underlying(p);
       resolve(_s_, 0, p$1, p_result);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aK_ = [0, caml_call1(f, v)], p_result$0 = _aK_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p_result$0 = [1, exn];
      }
      var p$0 = underlying(p);
      resolve(_r_, 0, p$0, p_result$0);
      return 0;
     }
     return [0, p, callback];
    }
    var result = p$0[1];
    switch(result[0]){
      case 1:
       return [0, result];
      case 2:
       var
        p_callbacks = result[1],
        match = create_result_promise_and_call(0),
        callback = match[2],
        p$1 = match[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = result[1];
       return run_callback_or_defer_it
               (_t_,
                function(param){
                 try{var _aJ_ = [0, caml_call1(f, v)], _aI_ = _aJ_;}
                 catch(exn$0){
                  var exn = caml_wrap_exception(exn$0);
                  if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
                  var _aI_ = [1, exn];
                 }
                 return [0, _aI_];
                },
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function catch$0(f, h){
    try{var _aG_ = caml_call1(f, 0), p = _aG_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 !== p_result[0]){
       var p$0 = underlying(p);
       resolve(_u_, 0, p$0, p_result);
       return 0;
      }
      var exn = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aH_ = caml_call1(h, exn), p$1 = _aH_;}
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(! run(exn$0)) throw caml_maybe_attach_backtrace(exn$0, 0);
       var p$1 = fail(exn$0);
      }
      var p$2 = underlying(p);
      make_into_proxy(p$2, p$1);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_v_,
                function(param){return caml_call1(h, exn$0);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default: return p$0;
    }
   }
   function backtrace_catch(add_loc, f, h){
    try{var _aE_ = caml_call1(f, 0), p = _aE_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 !== p_result[0]){
       var p$0 = underlying(p);
       resolve(_w_, 0, p$0, p_result);
       return 0;
      }
      var exn = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aF_ = caml_call1(h, exn), p$1 = _aF_;}
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(! run(exn$0)) throw caml_maybe_attach_backtrace(exn$0, 0);
       var p$1 = fail(caml_call1(add_loc, exn$0));
      }
      var p$2 = underlying(p);
      make_into_proxy(p$2, p$1);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_x_,
                function(param){
                 return caml_call1(h, caml_call1(add_loc, exn$0));
                },
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default: return p$0;
    }
   }
   function try_bind(f$0, f, h){
    try{var _aB_ = caml_call1(f$0, 0), p = _aB_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1];
       current_storage[1] = saved_storage;
       try{var _aD_ = caml_call1(h, exn$0), p$2 = _aD_;}
       catch(exn){
        var exn$1 = caml_wrap_exception(exn);
        if(! run(exn$1)) throw caml_maybe_attach_backtrace(exn$1, 0);
        var p$2 = fail(exn$1);
       }
       var p$3 = underlying(p);
       make_into_proxy(p$3, p$2);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aC_ = caml_call1(f, v), p$0 = _aC_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(exn);
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_z_,
                function(param){return caml_call1(h, exn$0);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_y_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function backtrace_try_bind(add_loc, f$0, f, h){
    try{var _ay_ = caml_call1(f$0, 0), p = _ay_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1];
       current_storage[1] = saved_storage;
       try{var _aA_ = caml_call1(h, exn$0), p$2 = _aA_;}
       catch(exn){
        var exn$1 = caml_wrap_exception(exn);
        if(! run(exn$1)) throw caml_maybe_attach_backtrace(exn$1, 0);
        var p$2 = fail(caml_call1(add_loc, exn$1));
       }
       var p$3 = underlying(p);
       make_into_proxy(p$3, p$2);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _az_ = caml_call1(f, v), p$0 = _az_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(caml_call1(add_loc, exn));
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_B_,
                function(param){
                 return caml_call1(h, caml_call1(add_loc, exn$0));
                },
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_A_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function finalize(f$0, f){
    return try_bind
            (f$0,
             function(x){
              return symbol_bind
                      (caml_call1(f, 0), function(param){return return$0(x);});
             },
             function(e){
              return symbol_bind
                      (caml_call1(f, 0), function(param){return fail(e);});
             });
   }
   function backtrace_finalize(add_loc, f$0, f){
    return backtrace_try_bind
            (add_loc,
             f$0,
             function(x){
              return symbol_bind
                      (caml_call1(f, 0), function(param){return return$0(x);});
             },
             function(e){
              return symbol_bind
                      (caml_call1(f, 0),
                       function(param){return fail(caml_call1(add_loc, e));});
             });
   }
   function on_cancel(p, f){
    var p$0 = underlying(p), match = p$0[1];
    switch(match[0]){
      case 1:
       return match[1] === Canceled
               ? run_callback_or_defer_it
                 (_D_,
                  function(param){
                   return handle_with_async_exception_ho(f, 0);
                  },
                  function(param){
                   return [0,
                           0,
                           function(param){
                            return handle_with_async_exception_ho(f, 0);
                           },
                           _C_];
                  })
               : 0;
      case 2:
       var callbacks = match[1]; return add_cancel_callback(callbacks, f);
      default: return 0;
    }
   }
   function on_success(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 === result[0]) return 0;
      var v = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, v);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       return 0;
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_E_,
                function(param){return handle_with_async_exception_ho(f, v);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
    }
   }
   function on_failure(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 !== result[0]) return 0;
      var exn = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, exn);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1];
       return run_callback_or_defer_it
               (_F_,
                function(param){
                 return handle_with_async_exception_ho(f, exn);
                },
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function on_termination(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, 0);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       return run_callback_or_defer_it
               (_H_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       return run_callback_or_defer_it
               (_G_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
    }
   }
   function on_any(p, f, g){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 === result[0]){
       var exn = result[1];
       current_storage[1] = saved_storage;
       return handle_with_async_exception_ho(g, exn);
      }
      var v = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, v);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1];
       return run_callback_or_defer_it
               (_J_,
                function(param){
                 return handle_with_async_exception_ho(g, exn);
                },
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_I_,
                function(param){return handle_with_async_exception_ho(f, v);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
    }
   }
   function wrap_in_cancelable(p_internal){
    var p_underlying = underlying(p_internal);
    switch(p_underlying[1][0]){
      case 1:
       return p_internal;
      case 2:
       var match = task(0), r = match[2], p = match[1];
       on_cancel(p, function(param){return cancel(p_internal);});
       on_any
        (p_internal,
         function(_ax_){return wakeup(r, _ax_);},
         function(_aw_){return wakeup_exn(r, _aw_);});
       return p;
      default: return p_internal;
    }
   }
   function dont_wait(f, h){
    try{var _av_ = caml_call1(f, 0), p = _av_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1]; return caml_call1(h, exn$0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(h, exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function async(f){
    try{var _au_ = caml_call1(f, 0), p = _au_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return caml_call1(async_exception_hook[1], exn$0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(async_exception_hook[1], exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function ignore_result(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; throw caml_maybe_attach_backtrace(exn, 0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(async_exception_hook[1], exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function join(ps){
    var
     p = new_pending([1, ps]),
     number_pending_in_ps = [0, 0],
     join_result = [0, _K_];
    function callback(new_result){
     if(1 === new_result[0] && 1 !== join_result[1][0])
      join_result[1] = new_result;
     number_pending_in_ps[1] = number_pending_in_ps[1] - 1 | 0;
     var _ar_ = 0 === number_pending_in_ps[1] ? 1 : 0;
     if(_ar_){
      var p$0 = underlying(p), _as_ = join_result[1];
      resolve(_L_, 0, underlying(p$0), _as_);
      var _at_ = 0;
     }
     else
      var _at_ = _ar_;
     return _at_;
    }
    var ps$0 = ps;
    for(;;){
     if(! ps$0)
      return 0 === number_pending_in_ps[1] ? [0, join_result[1]] : p;
     var ps$1 = ps$0[2], p$0 = ps$0[1], p_result = underlying(p$0)[1];
     switch(p_result[0]){
       case 1:
        if(1 !== join_result[1][0]) join_result[1] = p_result;
        ps$0 = ps$1;
        break;
       case 2:
        var p_callbacks = p_result[1];
        number_pending_in_ps[1] = number_pending_in_ps[1] + 1 | 0;
        add_implicitly_removed_callbac(p_callbacks, callback);
        ps$0 = ps$1;
        break;
       default: ps$0 = ps$1;
     }
    }
   }
   function both(p1, p2){
    var
     pair = [0, 0, 0],
     p1$0 =
       symbol_bind(p1, function(v){pair[1] = [0, v]; return return_unit;}),
     p2$0 =
       symbol_bind(p2, function(v){pair[2] = [0, v]; return return_unit;});
    return symbol
            (function(param){
              var _aq_ = pair[1], match = pair[2];
              if(_aq_ && match){
               var v2 = match[1], v1 = _aq_[1];
               return [0, v1, v2];
              }
              throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
             },
             join([0, p1$0, [0, p2$0, 0]]));
   }
   function all(ps){
    if(! ps) return return_nil;
    var _ap_ = ps[2], x = ps[1];
    if(! _ap_) return symbol(function(y){return [0, y, 0];}, x);
    if(_ap_[2]){
     var vs = runtime.caml_make_vect(caml_call1(Stdlib_List[1], ps), 0);
     return symbol
             (function(param){
               var i$1 = vs.length - 2 | 0, i = i$1, acc = 0;
               for(;;){
                if(0 > i) return acc;
                var match = vs[1 + i];
                if(! match)
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _N_], 1);
                var x = match[1], acc$0 = [0, x, acc], i$0 = i - 1 | 0;
                i = i$0;
                acc = acc$0;
               }
              },
              join
               (caml_call1
                 (caml_call1
                   (Stdlib_List[20],
                    function(index, p){
                     return symbol_bind
                             (p,
                              function(v){
                               runtime.caml_check_bound(vs, index)[1 + index] = [0, v];
                               return return_unit;
                              });
                    }),
                  ps)));
    }
    var y = _ap_[1];
    return symbol
            (function(param){
              var y = param[2], x = param[1];
              return [0, x, [0, y, 0]];
             },
             both(x, y));
   }
   function count_resolved_promises_in(ps){
    var total$1 = 0, ps$2 = ps;
    a:
    for(;;){
     if(! ps$2) return [0, total$1];
     var ps$3 = ps$2[2], p$0 = ps$2[1];
     switch(underlying(p$0)[1][0]){
       case 1:
        break a;
       case 2:
        ps$2 = ps$3; break;
       default: var total$2 = total$1 + 1 | 0; total$1 = total$2; ps$2 = ps$3;
     }
    }
    var
     rejected$1 = [0, p$0, 0],
     total = 1,
     rejected = rejected$1,
     ps$0 = ps$3;
    for(;;){
     if(! ps$0) return [1, [0, total, rejected]];
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        var rejected$0 = [0, p, rejected], total$0 = total + 1 | 0;
        total = total$0;
        rejected = rejected$0;
        ps$0 = ps$1;
        break;
       case 2:
        ps$0 = ps$1; break;
       default: ps$0 = ps$1;
     }
    }
   }
   function nth_resolved(ps, n){
    var ps$0 = ps, n$0 = n;
    for(;;){
     if(! ps$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        if(0 >= n$0) return p;
        var n$2 = n$0 - 1 | 0;
        ps$0 = ps$1;
        n$0 = n$2;
        break;
       case 2:
        ps$0 = ps$1; break;
       default:
        if(0 >= n$0) return p; var n$1 = n$0 - 1 | 0; ps$0 = ps$1; n$0 = n$1;
     }
    }
   }
   function nth_resolved_and_cancel_pendin(ps, n){
    var ps$0 = ps, n$0 = n;
    for(;;){
     if(! ps$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        if(0 >= n$0){caml_call2(Stdlib_List[17], cancel, ps$1); return p;}
        var n$2 = n$0 - 1 | 0;
        ps$0 = ps$1;
        n$0 = n$2;
        break;
       case 2:
        cancel(p); ps$0 = ps$1; break;
       default:
        if(0 >= n$0){caml_call2(Stdlib_List[17], cancel, ps$1); return p;}
        var n$1 = n$0 - 1 | 0;
        ps$0 = ps$1;
        n$0 = n$1;
     }
    }
   }
   var
    prng =
      [246, function(_ao_){return caml_call1(Stdlib_Random[15][1], [0]);}],
    cst_Lwt_choose_would_return_a_ =
      "Lwt.choose [] would return a promise that is pending forever",
    _Q_ = [0, 0],
    cst_Lwt_pick_would_return_a_pr =
      "Lwt.pick [] would return a promise that is pending forever",
    _R_ = [0, 0],
    cst_Lwt_nchoose_would_return_a =
      "Lwt.nchoose [] would return a promise that is pending forever",
    _S_ = [0, 0],
    cst_Lwt_npick_would_return_a_p =
      "Lwt.npick [] would return a promise that is pending forever",
    _T_ = [0, 0],
    cst_Lwt_nchoose_split_would_re =
      "Lwt.nchoose_split [] would return a promise that is pending forever",
    _U_ = [0, 0],
    _V_ = [0, 0];
   function choose(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_choose_would_return_a_);
    var match = count_resolved_promises_in(ps);
    if(0 !== match[0]){
     var
      match$0 = match[1],
      ps$0 = match$0[2],
      n$0 = match$0[1],
      _am_ = caml_obj_tag(prng),
      _an_ =
        250 === _am_
         ? prng[1]
         : 246 === _am_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
     return nth_resolved(ps$0, caml_call2(Stdlib_Random[15][5], _an_, n$0));
    }
    var n = match[1];
    if(0 === n){
     var
      p = new_pending([1, ps]),
      callback =
        function(result){
         var p$0 = underlying(p);
         resolve(_Q_, 0, p$0, result);
         return 0;
        };
     add_explicitly_removable_callb$0(ps, callback);
     return p;
    }
    if(1 === n) return nth_resolved(ps, 0);
    var
     _ak_ = caml_obj_tag(prng),
     _al_ =
       250 === _ak_
        ? prng[1]
        : 246 === _ak_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
    return nth_resolved(ps, caml_call2(Stdlib_Random[15][5], _al_, n));
   }
   function pick(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_pick_would_return_a_pr);
    var match = count_resolved_promises_in(ps);
    if(0 !== match[0]){
     var match$0 = match[1], qs = match$0[2], n$0 = match$0[1];
     caml_call2(Stdlib_List[17], cancel, ps);
     var
      _ai_ = caml_obj_tag(prng),
      _aj_ =
        250 === _ai_
         ? prng[1]
         : 246 === _ai_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
     return nth_resolved(qs, caml_call2(Stdlib_Random[15][5], _aj_, n$0));
    }
    var n = match[1];
    if(0 === n){
     var
      p = new_pending([1, ps]),
      callback =
        function(result){
         caml_call2(Stdlib_List[17], cancel, ps);
         var p$0 = underlying(p);
         resolve(_R_, 0, p$0, result);
         return 0;
        };
     add_explicitly_removable_callb$0(ps, callback);
     return p;
    }
    if(1 === n) return nth_resolved_and_cancel_pendin(ps, 0);
    var
     _ag_ = caml_obj_tag(prng),
     _ah_ =
       250 === _ag_
        ? prng[1]
        : 246 === _ag_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
    return nth_resolved_and_cancel_pendin
            (ps, caml_call2(Stdlib_Random[15][5], _ah_, n));
   }
   function collect_fulfilled_promises_aft(results, ps){
    var results$0 = results, ps$0 = ps;
    for(;;){
     if(! ps$0) return [0, caml_call1(Stdlib_List[9], results$0)];
     var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
     switch(result[0]){
       case 1:
        return result;
       case 2:
        ps$0 = ps$1; break;
       default:
        var v = result[1], results$1 = [0, v, results$0];
        results$0 = results$1;
        ps$0 = ps$1;
     }
    }
   }
   function nchoose(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_nchoose_would_return_a);
    a:
    {
     b:
     {
      var ps$2 = ps;
      for(;;){
       if(! ps$2) break;
       var ps$3 = ps$2[2], p$0 = ps$2[1], result$0 = underlying(p$0)[1];
       switch(result$0[0]){
         case 1:
          var p$2 = [0, result$0]; break a;
         case 2:
          ps$2 = ps$3; break;
         default: break b;
       }
      }
      var
       p$1 = new_pending([1, ps]),
       callback =
         function(result){
          var
           p = underlying(p$1),
           result$0 = collect_fulfilled_promises_aft(0, ps);
          resolve(_S_, 0, p, result$0);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      var p$2 = p$1;
      break a;
     }
     var v$0 = result$0[1], acc$1 = [0, v$0, 0], acc = acc$1, ps$0 = ps$3;
     b:
     for(;;){
      if(! ps$0){var p$2 = return$0(caml_call1(Stdlib_List[9], acc)); break;}
      var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
      switch(result[0]){
        case 1:
         var p$2 = [0, result]; break b;
        case 2:
         ps$0 = ps$1; break;
        default:
         var v = result[1], acc$0 = [0, v, acc]; acc = acc$0; ps$0 = ps$1;
      }
     }
    }
    return p$2;
   }
   function npick(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_npick_would_return_a_p);
    a:
    {
     b:
     {
      var ps$2 = ps;
      for(;;){
       if(! ps$2) break;
       var ps$3 = ps$2[2], p$0 = ps$2[1], result$0 = underlying(p$0)[1];
       switch(result$0[0]){
         case 1:
          caml_call2(Stdlib_List[17], cancel, ps);
          var p$2 = [0, result$0];
          break a;
         case 2:
          ps$2 = ps$3; break;
         default: break b;
       }
      }
      var
       p$1 = new_pending([1, ps]),
       callback =
         function(result){
          var
           p = underlying(p$1),
           result$0 = collect_fulfilled_promises_aft(0, ps);
          caml_call2(Stdlib_List[17], cancel, ps);
          resolve(_T_, 0, p, result$0);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      var p$2 = p$1;
      break a;
     }
     var v$0 = result$0[1], acc$1 = [0, v$0, 0], acc = acc$1, ps$0 = ps$3;
     b:
     for(;;){
      if(! ps$0){
       caml_call2(Stdlib_List[17], cancel, ps);
       var p$2 = return$0(caml_call1(Stdlib_List[9], acc));
       break;
      }
      var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
      switch(result[0]){
        case 1:
         caml_call2(Stdlib_List[17], cancel, ps);
         var p$2 = [0, result];
         break b;
        case 2:
         ps$0 = ps$1; break;
        default:
         var v = result[1], acc$0 = [0, v, acc]; acc = acc$0; ps$0 = ps$1;
      }
     }
    }
    return p$2;
   }
   function nchoose_split(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_nchoose_split_would_re);
    a:
    {
     b:
     {
      var pending_acc = 0, ps$2 = ps;
      for(;;){
       if(! ps$2) break;
       var
        ps$3 = ps$2[2],
        p_internal$0 = ps$2[1],
        result$0 = underlying(p_internal$0)[1];
       switch(result$0[0]){
         case 1:
          var p$0 = [0, result$0]; break a;
         case 2:
          var pending_acc$0 = [0, p_internal$0, pending_acc];
          pending_acc = pending_acc$0;
          ps$2 = ps$3;
          break;
         default: break b;
       }
      }
      var
       p = new_pending([1, ps]),
       callback =
         function(result$0){
          var
           to_resolve = underlying(p),
           fulfilled = 0,
           pending = 0,
           ps$0 = ps;
          for(;;){
           if(ps$0){
            var
             ps$1 = ps$0[2],
             p_internal = ps$0[1],
             result = underlying(p_internal)[1];
            switch(result[0]){
              case 1:
               resolve(_U_, 0, to_resolve, result); break;
              case 2:
               var pending$0 = [0, p_internal, pending];
               pending = pending$0;
               ps$0 = ps$1;
               continue;
              default:
               var v = result[1], fulfilled$0 = [0, v, fulfilled];
               fulfilled = fulfilled$0;
               ps$0 = ps$1;
               continue;
            }
           }
           else{
            var _af_ = caml_call1(Stdlib_List[9], pending);
            resolve
             (_V_,
              0,
              to_resolve,
              [0, [0, caml_call1(Stdlib_List[9], fulfilled), _af_]]);
           }
           return 0;
          }
         };
      add_explicitly_removable_callb$0(ps, callback);
      var p$0 = p;
      break a;
     }
     var
      v$0 = result$0[1],
      results$1 = [0, v$0, 0],
      results = results$1,
      pending = pending_acc,
      ps$0 = ps$3;
     b:
     for(;;){
      if(! ps$0){
       var p$0 = return$0([0, caml_call1(Stdlib_List[9], results), pending]);
       break;
      }
      var
       ps$1 = ps$0[2],
       p_internal = ps$0[1],
       result = underlying(p_internal)[1];
      switch(result[0]){
        case 1:
         var p$0 = [0, result]; break b;
        case 2:
         var pending$0 = [0, p_internal, pending];
         pending = pending$0;
         ps$0 = ps$1;
         break;
        default:
         var v = result[1], results$0 = [0, v, results];
         results = results$0;
         ps$0 = ps$1;
      }
     }
    }
    return p$0;
   }
   function state(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; return [1, exn];
      case 2:
       return 0;
      default: var v = match[1]; return [0, v];
    }
   }
   function debug_state_is(expected_state, p){
    return return$0(runtime.caml_equal(state(p), expected_state));
   }
   function is_sleeping(p){
    switch(underlying(p)[1][0]){
      case 1:
       return 0;
      case 2:
       return 1;
      default: return 0;
    }
   }
   function poll(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var e = match[1]; throw caml_maybe_attach_backtrace(e, 0);
      case 2:
       return 0;
      default: var v = match[1]; return [0, v];
    }
   }
   function apply(f, x){
    try{var _ae_ = caml_call1(f, x); return _ae_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap(f){
    try{var _ad_ = return$0(caml_call1(f, 0)); return _ad_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap1(f, x1){
    try{var _ac_ = return$0(caml_call1(f, x1)); return _ac_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap2(f, x1, x2){
    try{var _ab_ = return$0(caml_call2(f, x1, x2)); return _ab_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap3(f, x1, x2, x3){
    try{var _aa_ = return$0(caml_call3(f, x1, x2, x3)); return _aa_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap4(f, x1, x2, x3, x4){
    try{var _$_ = return$0(caml_call4(f, x1, x2, x3, x4)); return _$_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap5(f, x1, x2, x3, x4, x5){
    try{var ___ = return$0(caml_call5(f, x1, x2, x3, x4, x5)); return ___;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap6(f, x1, x2, x3, x4, x5, x6){
    try{var _Z_ = return$0(caml_call6(f, x1, x2, x3, x4, x5, x6)); return _Z_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap7(f, x1, x2, x3, x4, x5, x6, x7){
    try{
     var _Y_ = return$0(caml_call7(f, x1, x2, x3, x4, x5, x6, x7));
     return _Y_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    pause_hook = [0, function(_X_){}],
    paused = caml_call1(Lwt_sequence[4], 0),
    _W_ = [0, 0];
   function pause(param){
    var p = add_task_r(paused);
    _W_[1]++;
    caml_call1(pause_hook[1], _W_[1]);
    return p;
   }
   function wakeup_paused(param){
    if(caml_call1(Lwt_sequence[6], paused)){_W_[1] = 0; return 0;}
    var tmp = caml_call1(Lwt_sequence[4], 0);
    caml_call2(Lwt_sequence[16], paused, tmp);
    _W_[1] = 0;
    return caml_call2
            (Lwt_sequence[17], function(r){return wakeup(r, 0);}, tmp);
   }
   function register_pause_notifier(f){pause_hook[1] = f; return 0;}
   function abandon_paused(param){
    caml_call1(Lwt_sequence[5], paused);
    _W_[1] = 0;
    return 0;
   }
   function paused_count(param){return _W_[1];}
   function map(t, f){return symbol(f, t);}
   function bind(t, f){return symbol_bind(t, f);}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, map, bind, both, Open_on_rhs],
    Let_syntax$0 = [0, Let_syntax];
   function symbol$0(f, p){return symbol_bind(p, f);}
   function symbol$1(p, f){return symbol(f, p);}
   function symbol$2(p$0, p){return join([0, p$0, [0, p, 0]]);}
   function symbol$3(p$0, p){return choose([0, p$0, [0, p, 0]]);}
   var Let_syntax$1 = Let_syntax$0[1];
   function let$0(x, f){return symbol(f, x);}
   var
    Syntax = [0, symbol_bind, both, let$0, both],
    Lwt =
      [0,
       wait,
       wakeup_later,
       wakeup_later_exn,
       return$0,
       fail,
       symbol_bind,
       catch$0,
       finalize,
       try_bind,
       dont_wait,
       async,
       async_exception_hook,
       both,
       join,
       all,
       pick,
       choose,
       npick,
       nchoose,
       nchoose_split,
       Canceled,
       task,
       cancel,
       on_cancel,
       protected$0,
       no_cancel,
       wrap_in_cancelable,
       symbol,
       on_success,
       on_failure,
       on_termination,
       on_any,
       [0,
        symbol_bind,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$0,
        symbol,
        Let_syntax$1],
       Let_syntax$0,
       Syntax,
       return_unit,
       return_none,
       return_nil,
       return_true,
       return_false,
       return_some,
       return_ok,
       return_error,
       fail_with,
       fail_invalid_arg,
       of_result,
       wakeup_later_result,
       state,
       new_key,
       get,
       with_value,
       wakeup,
       wakeup_exn,
       wakeup_result,
       add_task_r,
       add_task_l,
       pause,
       wakeup_paused,
       paused_count,
       register_pause_notifier,
       abandon_paused,
       wrap,
       wrap1,
       wrap2,
       wrap3,
       wrap4,
       wrap5,
       wrap6,
       wrap7,
       symbol_bind,
       symbol$1,
       symbol$3,
       symbol$2,
       symbol$0,
       symbol,
       is_sleeping,
       ignore_result,
       [0, handle_all, handle_all_except_runtime, set, run],
       poll,
       apply,
       backtrace_bind,
       backtrace_catch,
       backtrace_finalize,
       backtrace_try_bind,
       abandon_wakeups,
       debug_state_is];
   runtime.caml_register_global(71, Lwt, "Lwt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_switch
//# unitInfo: Requires: Lwt, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Off = [248, "Lwt_switch.Off", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, [0, [0, 0]]];}
   function is_on(switch$0){return switch$0[1] ? 1 : 0;}
   function check(param){
    if(param && ! param[1][1]) throw caml_maybe_attach_backtrace(Off, 1);
    return 0;
   }
   function add_hook(switch$0, hook){
    if(! switch$0) return 0;
    var match = switch$0[1][1];
    if(! match) throw caml_maybe_attach_backtrace(Off, 1);
    var os = match[1];
    os[1] = [0, hook, os[1]];
    return 0;
   }
   function add_hook_or_exec(switch$0, hook){
    if(! switch$0) return Lwt[36];
    var match = switch$0[1][1];
    if(! match) return caml_call1(hook, 0);
    var os = match[1];
    os[1] = [0, hook, os[1]];
    return Lwt[36];
   }
   function turn_off(switch$0){
    var _a_ = switch$0[1];
    if(! _a_) return Lwt[36];
    var hooks = _a_[1][1];
    switch$0[1] = 0;
    var
     _b_ =
       caml_call2
        (Stdlib_List[19],
         function(hook){return caml_call2(Lwt[80], hook, 0);},
         hooks);
    return caml_call1(Lwt[14], _b_);
   }
   function with_switch(fn){
    var switch$0 = create(0);
    return caml_call2
            (Lwt[8],
             function(param){return caml_call1(fn, switch$0);},
             function(param){return turn_off(switch$0);});
   }
   var
    Lwt_switch =
      [0,
       create,
       with_switch,
       is_on,
       turn_off,
       Off,
       check,
       add_hook,
       add_hook_or_exec];
   runtime.caml_register_global(3, Lwt_switch, "Lwt_switch");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_seq
//# unitInfo: Requires: Lwt, Stdlib, Stdlib__List, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    return_nil = caml_call1(Lwt[4], 0),
    _h_ =
      [0,
       [11,
        "Lwt_seq.iter_n: max_concurrency must be > 0, ",
        [4, 0, 0, 0, [11, " given", 0]]],
       "Lwt_seq.iter_n: max_concurrency must be > 0, %d given"];
   function empty(param){return return_nil;}
   function return$0(x, param){return caml_call1(Lwt[4], [0, x, empty]);}
   function return_lwt(x, param){
    return caml_call2(Lwt[35][3], x, function(x){return [0, x, empty];});
   }
   function cons(x, t, param){return caml_call1(Lwt[4], [0, x, t]);}
   function cons_lwt(x, t, param){
    return caml_call2(Lwt[35][3], x, function(x){return [0, x, t];});
   }
   function _a_(seq1, seq2, param){
    var _ax_ = caml_call1(seq1, 0);
    return caml_call2
            (Lwt[33][1],
             _ax_,
             function(param){
              if(! param) return caml_call1(seq2, 0);
              var next = param[2], x = param[1];
              return caml_call1
                      (Lwt[4],
                       [0, x, function(_ay_){return _a_(next, seq2, _ay_);}]);
             });
   }
   function append(seq1, seq2, param){
    var _av_ = caml_call2(Lwt[80], seq1, 0);
    return caml_call2
            (Lwt[33][1],
             _av_,
             function(param){
              if(! param) return caml_call1(seq2, 0);
              var next = param[2], x = param[1];
              return caml_call1
                      (Lwt[4],
                       [0, x, function(_aw_){return _a_(next, seq2, _aw_);}]);
             });
   }
   function _b_(f, seq, param){
    var _at_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][2],
             _at_,
             function(param){
              if(! param) return 0;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              return [0, x$0, function(_au_){return _b_(f, next, _au_);}];
             });
   }
   function map(f, seq, param){
    var _ar_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][2],
             _ar_,
             function(param){
              if(! param) return 0;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              return [0, x$0, function(_as_){return _b_(f, next, _as_);}];
             });
   }
   function _c_(f, seq, param){
    var _ao_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ao_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _ap_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][3],
                       _ap_,
                       function(x){
                        return [0, x, function(_aq_){return _c_(f, next, _aq_);}];
                       });
             });
   }
   function map_s(f, seq, param){
    var _al_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _al_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _am_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][3],
                       _am_,
                       function(x){
                        return [0, x, function(_an_){return _c_(f, next, _an_);}];
                       });
             });
   }
   function _d_(f, seq, param){
    var _aj_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _aj_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              if(! x$0) return _d_(f, next, 0);
              var y = x$0[1];
              return caml_call1
                      (Lwt[4], [0, y, function(_ak_){return _d_(f, next, _ak_);}]);
             });
   }
   function filter_map(f, seq, param){
    var _ah_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ah_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              if(! x$0) return _d_(f, next, 0);
              var y = x$0[1];
              return caml_call1
                      (Lwt[4], [0, y, function(_ai_){return _d_(f, next, _ai_);}]);
             });
   }
   function _e_(f, seq, param){
    var _ae_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ae_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _af_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _af_,
                       function(x){
                        if(! x) return _e_(f, next, 0);
                        var y = x[1];
                        return caml_call1
                                (Lwt[4], [0, y, function(_ag_){return _e_(f, next, _ag_);}]);
                       });
             });
   }
   function filter_map_s(f, seq, param){
    var _ab_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ab_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _ac_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _ac_,
                       function(x){
                        if(! x) return _e_(f, next, 0);
                        var y = x[1];
                        return caml_call1
                                (Lwt[4], [0, y, function(_ad_){return _e_(f, next, _ad_);}]);
                       });
             });
   }
   function _f_(f, seq, param){
    var _$_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _$_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], ok = caml_call1(f, x);
              return ok
                      ? caml_call1
                        (Lwt[4], [0, x, function(_aa_){return _f_(f, next, _aa_);}])
                      : _f_(f, next, 0);
             });
   }
   function filter(f, seq, param){
    var _Z_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _Z_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], ok = caml_call1(f, x);
              return ok
                      ? caml_call1
                        (Lwt[4], [0, x, function(___){return _f_(f, next, ___);}])
                      : _f_(f, next, 0);
             });
   }
   function _g_(f, seq, param){
    var _W_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _W_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _X_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _X_,
                       function(ok){
                        return ok
                                ? caml_call1
                                  (Lwt[4], [0, x, function(_Y_){return _g_(f, next, _Y_);}])
                                : _g_(f, next, 0);
                       });
             });
   }
   function filter_s(f, seq, param){
    var _T_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _T_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _U_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _U_,
                       function(ok){
                        return ok
                                ? caml_call1
                                  (Lwt[4], [0, x, function(_V_){return _g_(f, next, _V_);}])
                                : _g_(f, next, 0);
                       });
             });
   }
   function flat_map_app(f, seq, tail, param){
    var _Q_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _Q_,
             function(param){
              if(param){
               var next = param[2], x = param[1];
               return caml_call1
                       (Lwt[4],
                        [0,
                         x,
                         function(_S_){return flat_map_app(f, next, tail, _S_);}]);
              }
              var _R_ = caml_call1(tail, 0);
              return caml_call2
                      (Lwt[33][1],
                       _R_,
                       function(param){
                        if(! param) return return_nil;
                        var next = param[2], x = param[1];
                        return flat_map_app(f, caml_call1(f, x), next, 0);
                       });
             });
   }
   function flat_map(f, seq, param){
    var _P_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _P_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1];
              return flat_map_app(f, caml_call1(f, x), next, 0);
             });
   }
   function fold_left(f, acc, seq){
    function aux(f, acc, seq){
     var _O_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _O_,
              function(param){
               if(! param) return caml_call1(Lwt[4], acc);
               var
                next = param[2],
                x = param[1],
                acc$0 = caml_call2(f, acc, x);
               return aux(f, acc$0, next);
              });
    }
    var _N_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _N_,
             function(param){
              if(! param) return caml_call1(Lwt[4], acc);
              var
               next = param[2],
               x = param[1],
               acc$0 = caml_call2(f, acc, x);
              return aux(f, acc$0, next);
             });
   }
   function fold_left_s(f, acc, seq){
    function aux(f, acc, seq){
     var _L_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _L_,
              function(param){
               if(! param) return caml_call1(Lwt[4], acc);
               var next = param[2], x = param[1], _M_ = caml_call2(f, acc, x);
               return caml_call2
                       (Lwt[35][1], _M_, function(acc){return aux(f, acc, next);});
              });
    }
    var _J_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _J_,
             function(param){
              if(! param) return caml_call1(Lwt[4], acc);
              var next = param[2], x = param[1], _K_ = caml_call2(f, acc, x);
              return caml_call2
                      (Lwt[35][1], _K_, function(acc){return aux(f, acc, next);});
             });
   }
   function iter(f, seq){
    function aux(seq){
     var _I_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _I_,
              function(param){
               if(! param) return Lwt[36];
               var next = param[2], x = param[1];
               caml_call1(f, x);
               return aux(next);
              });
    }
    var _H_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _H_,
             function(param){
              if(! param) return Lwt[36];
              var next = param[2], x = param[1];
              caml_call1(f, x);
              return aux(next);
             });
   }
   function iter_s(f, seq){
    function aux(seq){
     var _F_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _F_,
              function(param){
               if(! param) return Lwt[36];
               var next = param[2], x = param[1], _G_ = caml_call1(f, x);
               return caml_call2
                       (Lwt[35][1], _G_, function(param){return aux(next);});
              });
    }
    var _D_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _D_,
             function(param){
              if(! param) return Lwt[36];
              var next = param[2], x = param[1], _E_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1], _E_, function(param){return aux(next);});
             });
   }
   function iter_p(f, seq){
    function aux(acc, seq){
     var _C_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _C_,
              function(param){
               if(! param) return caml_call1(Lwt[14], acc);
               var next = param[2], x = param[1], p = caml_call1(f, x);
               return aux([0, p, acc], next);
              });
    }
    var acc = 0, _B_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _B_,
             function(param){
              if(! param) return caml_call1(Lwt[14], acc);
              var next = param[2], x = param[1], p = caml_call1(f, x);
              return aux([0, p, acc], next);
             });
   }
   function iter_n(opt, f, seq){
    if(opt)
     var sth = opt[1], max_concurrency = sth;
    else
     var max_concurrency = 1;
    if(max_concurrency <= 0){
     var message = caml_call2(Stdlib_Printf[4], _h_, max_concurrency);
     caml_call1(Stdlib[1], message);
    }
    function loop(running, available, seq){
     function _w_(param){
      var available = param[2], running = param[1], _A_ = caml_call1(seq, 0);
      return caml_call2
              (Lwt[33][1],
               _A_,
               function(param){
                if(! param) return caml_call1(Lwt[14], running);
                var seq = param[2], elt = param[1];
                return loop
                        ([0, caml_call1(f, elt), running], available - 1 | 0, seq);
               });
     }
     if(0 < available)
      var _x_ = caml_call1(Lwt[4], [0, running, available]);
     else
      var
       _y_ = caml_call1(Lwt[20], running),
       _x_ =
         caml_call2
          (Lwt[33][1],
           _y_,
           function(param){
            var
             running = param[2],
             complete = param[1],
             _z_ =
               [0,
                running,
                available + caml_call1(Stdlib_List[1], complete) | 0];
            return caml_call1(Lwt[4], _z_);
           });
     return caml_call2(Lwt[33][1], _x_, _w_);
    }
    return loop
            (0,
             max_concurrency,
             function(param){return caml_call2(Lwt[80], seq, 0);});
   }
   function unfold(f, u, param){
    try{var val = caml_call1(f, u);}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0);
     if(caml_call1(Lwt[78][4], exc))
      throw caml_maybe_attach_backtrace(exc, 0);
     throw caml_maybe_attach_backtrace(exc, 0);
    }
    if(! val) return return_nil;
    var match = val[1], u$0 = match[2], x = match[1];
    return caml_call1
            (Lwt[4], [0, x, function(_v_){return unfold(f, u$0, _v_);}]);
   }
   function _i_(f, u, param){
    var _t_ = caml_call1(f, u);
    return caml_call2
            (Lwt[35][1],
             _t_,
             function(x){
              if(! x) return return_nil;
              var match = x[1], u = match[2], x$0 = match[1];
              return caml_call1
                      (Lwt[4], [0, x$0, function(_u_){return _i_(f, u, _u_);}]);
             });
   }
   function unfold_lwt(f, u, param){
    var _r_ = caml_call2(Lwt[80], f, u);
    return caml_call2
            (Lwt[35][1],
             _r_,
             function(x){
              if(! x) return return_nil;
              var match = x[1], u = match[2], x$0 = match[1];
              return caml_call1
                      (Lwt[4], [0, x$0, function(_s_){return _i_(f, u, _s_);}]);
             });
   }
   function of_list(l, param){
    if(l)
     var
      t = l[2],
      h = l[1],
      _p_ = [0, h, function(_q_){return of_list(t, _q_);}];
    else
     var _p_ = 0;
    return caml_call1(Lwt[4], _p_);
   }
   function to_list(seq){
    function aux(f, seq){
     var _n_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[6],
              _n_,
              function(param){
               if(param){
                var t = param[2], h = param[1];
                return aux(function(x){return caml_call1(f, [0, h, x]);}, t);
               }
               var _o_ = caml_call1(f, 0);
               return caml_call1(Lwt[4], _o_);
              });
    }
    return aux(function(x){return x;}, caml_call1(Lwt[80], seq));
   }
   function of_seq(seq, param){
    try{var val = caml_call1(seq, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(caml_call1(Lwt[78][4], exn))
      throw caml_maybe_attach_backtrace(exn, 0);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    if(! val) return return_nil;
    var next = val[2], x = val[1];
    return caml_call1
            (Lwt[4], [0, x, function(_m_){return of_seq(next, _m_);}]);
   }
   function _j_(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return return_nil;
    var next = match[2], x = match[1];
    return caml_call2
            (Lwt[35][3],
             x,
             function(x){
              function next$0(_l_){return _j_(next, _l_);}
              return [0, x, next$0];
             });
   }
   function of_seq_lwt(seq, param){
    try{var val = caml_call1(seq, 0);}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0);
     if(caml_call1(Lwt[78][4], exc))
      throw caml_maybe_attach_backtrace(exc, 0);
     throw caml_maybe_attach_backtrace(exc, 0);
    }
    if(! val) return return_nil;
    var next = val[2], x = val[1];
    return caml_call2
            (Lwt[35][3],
             x,
             function(x){
              function next$0(_k_){return _j_(next, _k_);}
              return [0, x, next$0];
             });
   }
   var
    Lwt_seq =
      [0,
       empty,
       return$0,
       return_lwt,
       cons,
       cons_lwt,
       append,
       map,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       flat_map,
       fold_left,
       fold_left_s,
       iter,
       iter_s,
       iter_p,
       iter_n,
       unfold,
       unfold_lwt,
       to_list,
       of_list,
       of_seq,
       of_seq_lwt];
   runtime.caml_register_global(5, Lwt_seq, "Lwt_seq");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_stream
//# unitInfo: Requires: CamlinternalOO, Lwt, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__List, Stdlib__Printf, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$6 = "",
    cst_blocked = "blocked",
    cst_close = "close",
    cst_closed = "closed",
    cst_count = "count",
    cst_push = "push",
    cst_resize = "resize",
    cst_set_reference = "set_reference",
    cst_size = "size",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst$3 = "    ",
    cst$4 = "   ",
    cst$5 = " |",
    cst = cst$6,
    cst$0 = cst$6,
    cst$1 = cst$6,
    cst$2 = cst$6,
    shared =
      [0,
       cst_size,
       cst_set_reference,
       cst_resize,
       cst_push,
       cst_count,
       cst_closed,
       cst_close,
       cst_blocked],
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    CamlinternalOO = global_data.CamlinternalOO,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Array = global_data.Stdlib__Array,
    Closed = [248, "Lwt_stream.Closed", caml_fresh_oo_id(0)],
    Full = [248, "Lwt_stream.Full", caml_fresh_oo_id(0)],
    Empty = [248, "Lwt_stream.Empty", caml_fresh_oo_id(0)],
    _a_ = [0, cst_closed],
    cst_Lwt_stream_clone = "Lwt_stream.clone",
    cst_Lwt_stream_bounded_push_re = "Lwt_stream.bounded_push#resize";
   function new_node(param){
    var node = [];
    runtime.caml_update_dummy(node, [0, node, 0]);
    return node;
   }
   function clone(s){
    if(3 === s[1][0]) caml_call1(Stdlib[1], cst_Lwt_stream_clone);
    return [0, s[1], s[2], s[3], s[4], s[5]];
   }
   function from_source(source){
    var
     node = new_node(0),
     match = caml_call1(Lwt[1], 0),
     close = match[2],
     closed = match[1];
    return [0, source, close, closed, node, [0, node]];
   }
   function from(f){return from_source([0, [0, f, Lwt[36]]]);}
   function from_direct(f){return from_source([1, f]);}
   function closed(s){return s[3];}
   function is_closed(s){return 1 - caml_call1(Lwt[76], s[3]);}
   function enqueue(e, last){
    var node = last[1], new_last = new_node(0);
    node[2] = e;
    node[1] = new_last;
    last[1] = new_last;
   }
   function enqueue$0(e, s){return enqueue(e, s[5]);}
   function create_with_reference(param){
    var
     match = caml_call1(Lwt[1], 0),
     push_signal_resolver = match[2],
     push_signal = match[1],
     push_signal_resolver$0 = [0, push_signal_resolver],
     source = [0, push_signal, 0, 0],
     t = from_source([2, source]),
     close = t[2],
     closed = t[3],
     last = t[5];
    function push(x){
     if(1 - caml_call1(Lwt[76], closed))
      throw caml_maybe_attach_backtrace(Closed, 1);
     enqueue(x, last);
     if(source[2]){
      source[2] = 0;
      var
       old_push_signal_resolver = push_signal_resolver$0[1],
       match = caml_call1(Lwt[1], 0),
       new_push_signal_resolver = match[2],
       new_waiter = match[1];
      source[1] = new_waiter;
      push_signal_resolver$0[1] = new_push_signal_resolver;
      caml_call2(Lwt[2], old_push_signal_resolver, 0);
     }
     var _aH_ = 0 === x ? 1 : 0;
     return _aH_ ? caml_call2(Lwt[52], close, 0) : _aH_;
    }
    return [0, t, push, function(x){source[3] = x; return 0;}];
   }
   function return$0(a){
    var match = create_with_reference(0), push = match[2], stream = match[1];
    caml_call1(push, [0, a]);
    caml_call1(push, 0);
    return stream;
   }
   function return_lwt(a){
    var match = create_with_reference(0), push = match[2], source = match[1];
    caml_call2
     (Lwt[10],
      function(param){
       return caml_call2
               (Lwt[6],
                a,
                function(x){
                 caml_call1(push, [0, x]);
                 caml_call1(push, 0);
                 return Lwt[36];
                });
      },
      function(exc){return caml_call1(push, 0);});
    return source;
   }
   function of_seq(s){
    var s$0 = [0, s];
    function get(param){
     var match = caml_call1(s$0[1], 0);
     if(! match) return 0;
     var s = match[2], elt = match[1];
     s$0[1] = s;
     return [0, elt];
    }
    return from_direct(get);
   }
   function of_lwt_seq(s){
    var s$0 = [0, s];
    function get(param){
     var _aG_ = caml_call1(s$0[1], 0);
     return caml_call2
             (Lwt[33][2],
              _aG_,
              function(param){
               if(! param) return 0;
               var s = param[2], elt = param[1];
               s$0[1] = s;
               return [0, elt];
              });
    }
    return from(get);
   }
   function create(param){
    var match = create_with_reference(0), push = match[2], source = match[1];
    return [0, source, push];
   }
   function of_iter(iter, i){
    var match = create(0), push = match[2], stream = match[1];
    caml_call2(iter, function(x){return caml_call1(push, [0, x]);}, i);
    caml_call1(push, 0);
    return stream;
   }
   function of_list(l){return of_iter(Stdlib_List[17], l);}
   function of_array(a){return of_iter(Stdlib_Array[13], a);}
   function of_string(s){return of_iter(Stdlib_String[29], s);}
   function notify_pusher(info, last){
    enqueue(info[5], last);
    info[5] = 0;
    var
     old_wakener = info[7],
     match = caml_call1(Lwt[22], 0),
     wakener = match[2],
     waiter = match[1];
    info[6] = waiter;
    info[7] = wakener;
    return caml_call2(Lwt[2], old_wakener, 0);
   }
   var
    bounded_push_impl =
      caml_call2
       (CamlinternalOO[19],
        [0,
         cst_blocked,
         cst_close,
         cst_push,
         cst_count,
         cst_size,
         cst_set_reference,
         cst_resize,
         cst_closed],
        function(_ap_){
         var
          _aq_ = caml_call2(CamlinternalOO[3], _ap_, cst),
          _ar_ = caml_call2(CamlinternalOO[3], _ap_, cst$0),
          _as_ = caml_call2(CamlinternalOO[3], _ap_, cst$1),
          _at_ = caml_call2(CamlinternalOO[3], _ap_, cst$2),
          _au_ = caml_call3(CamlinternalOO[4], _ap_, shared, _a_),
          _av_ = _au_[9];
         caml_call2
          (CamlinternalOO[11],
           _ap_,
           [0,
            _au_[1],
            function(self_1){return self_1[1 + _aq_][3];},
            _au_[3],
            function(self_1, size){
             if(size < 0)
              caml_call1(Stdlib[1], cst_Lwt_stream_bounded_push_re);
             self_1[1 + _aq_][3] = size;
             var
              _aE_ = self_1[1 + _aq_][4] < self_1[1 + _aq_][3] ? 1 : 0,
              _aF_ = _aE_ ? 0 !== self_1[1 + _aq_][5] ? 1 : 0 : _aE_;
             return _aF_
                     ? (self_1
                         [1 + _aq_]
                        [4]
                       = self_1[1 + _aq_][4] + 1 | 0,
                       notify_pusher(self_1[1 + _aq_], self_1[1 + _as_]))
                     : _aF_;
            },
            _au_[4],
            function(self_1, x){
             if(self_1[1 + _av_]) return caml_call1(Lwt[5], Closed);
             if(0 !== self_1[1 + _aq_][5]) return caml_call1(Lwt[5], Full);
             if(self_1[1 + _aq_][3] <= self_1[1 + _aq_][4]){
              self_1[1 + _aq_][5] = [0, x];
              return caml_call2
                      (Lwt[7],
                       function(param){return self_1[1 + _aq_][6];},
                       function(exn){
                        if(exn !== Lwt[21])
                         throw caml_maybe_attach_backtrace(exn, 0);
                        self_1[1 + _aq_][5] = 0;
                        var
                         match = caml_call1(Lwt[22], 0),
                         wakener = match[2],
                         waiter = match[1];
                        self_1[1 + _aq_][6] = waiter;
                        self_1[1 + _aq_][7] = wakener;
                        throw caml_maybe_attach_backtrace(exn, 0);
                       });
             }
             enqueue([0, x], self_1[1 + _as_]);
             self_1[1 + _aq_][4] = self_1[1 + _aq_][4] + 1 | 0;
             if(self_1[1 + _aq_][2]){
              self_1[1 + _aq_][2] = 0;
              var
               old_wakener = self_1[1 + _ar_][1],
               match = caml_call1(Lwt[1], 0),
               new_wakener = match[2],
               new_waiter = match[1];
              self_1[1 + _aq_][1] = new_waiter;
              self_1[1 + _ar_][1] = new_wakener;
              caml_call2(Lwt[2], old_wakener, 0);
             }
             return Lwt[36];
            },
            _au_[7],
            function(self_1){
             var _aD_ = 1 - self_1[1 + _av_];
             if(! _aD_) return _aD_;
             self_1[1 + _av_] = 1;
             var node = self_1[1 + _as_][1], new_last = new_node(0);
             node[2] = 0;
             node[1] = new_last;
             self_1[1 + _as_][1] = new_last;
             if(0 !== self_1[1 + _aq_][5]){
              self_1[1 + _aq_][5] = 0;
              caml_call2(Lwt[3], self_1[1 + _aq_][7], Closed);
             }
             if(self_1[1 + _aq_][2]){
              self_1[1 + _aq_][2] = 0;
              var old_wakener = self_1[1 + _ar_][1];
              caml_call2(Lwt[2], old_wakener, 0);
             }
             return caml_call2(Lwt[52], self_1[1 + _at_], 0);
            },
            _au_[5],
            function(self_1){return self_1[1 + _aq_][4];},
            _au_[8],
            function(self_1){return 0 !== self_1[1 + _aq_][5] ? 1 : 0;},
            _au_[6],
            function(self_1){return self_1[1 + _av_];},
            _au_[2],
            function(self_1, x){self_1[1 + _aq_][8] = x; return 0;}]);
         return function(_aB_, _aA_, _az_, _ay_, _ax_, _aw_){
          var _aC_ = caml_call2(CamlinternalOO[24], _aA_, _ap_);
          _aC_[1 + _at_] = _aw_;
          _aC_[1 + _as_] = _ax_;
          _aC_[1 + _ar_] = _ay_;
          _aC_[1 + _aq_] = _az_;
          _aC_[1 + _av_] = 0;
          return _aC_;};
        }),
    cst_Lwt_stream_create_bounded = "Lwt_stream.create_bounded",
    _b_ =
      [0,
       [11,
        "Lwt_stream.iter_n: max_concurrency must be > 0, ",
        [4, 0, 0, 0, [11, " given", 0]]],
       "Lwt_stream.iter_n: max_concurrency must be > 0, %d given"],
    cst_Lwt_stream_parse = "Lwt_stream.parse",
    _c_ = [0, [4, 6, [0, 2, 8], 0, [11, "|  ", 0]], "%08x|  "],
    _d_ = [0, [4, 6, [0, 2, 2], 0, [12, 32, 0]], "%02x "];
   function create_bounded(size){
    if(size < 0) caml_call1(Stdlib[1], cst_Lwt_stream_create_bounded);
    var
     match = caml_call1(Lwt[1], 0),
     wakener = match[2],
     waiter = match[1],
     match$0 = caml_call1(Lwt[22], 0),
     push_wakener = match$0[2],
     push_waiter = match$0[1],
     wakener_cell = [0, wakener],
     info = [0, waiter, 0, size, 0, 0, push_waiter, push_wakener, 0],
     t = from_source([3, info]);
    return [0,
            t,
            caml_call5
             (bounded_push_impl[1], 0, info, wakener_cell, t[5], t[2])];
   }
   function feed(s){
    var match = s[1];
    switch(match[0]){
      case 0:
       var from = match[1];
       if(caml_call1(Lwt[76], from[2])) return caml_call1(Lwt[25], from[2]);
       var
        thread =
          caml_call2
           (Lwt[7],
            function(param){
             var _ao_ = caml_call1(from[1], 0);
             return caml_call2
                     (Lwt[33][1],
                      _ao_,
                      function(x){
                       enqueue$0(x, s);
                       if(0 === x) caml_call2(Lwt[52], s[2], 0);
                       return Lwt[36];
                      });
            },
            function(_an_){throw caml_maybe_attach_backtrace(_an_, 0);});
       from[2] = thread;
       return caml_call1(Lwt[25], thread);
      case 1:
       var f = match[1], x = caml_call1(f, 0);
       enqueue$0(x, s);
       if(0 === x) caml_call2(Lwt[52], s[2], 0);
       return Lwt[36];
      case 2:
       var push = match[1]; push[2] = 1; return caml_call1(Lwt[25], push[1]);
      default:
       var push$0 = match[1];
       push$0[2] = 1;
       return caml_call1(Lwt[25], push$0[1]);
    }
   }
   function consume(s, node){
    var _am_ = node === s[4] ? 1 : 0;
    if(! _am_) return _am_;
    s[4] = node[1];
    var match = s[1];
    if(3 !== match[0]) return;
    var info = match[1];
    if(0 !== info[5]) return notify_pusher(info, s[5]);
    info[4] = info[4] - 1 | 0;
   }
   function peek_rec(s, node){
    if(node !== s[5][1]) return caml_call1(Lwt[4], node[2]);
    var _al_ = feed(s);
    return caml_call2
            (Lwt[33][1], _al_, function(param){return peek_rec(s, node);});
   }
   function peek(s){return peek_rec(s, s[4]);}
   function npeek_rec(node, acc, n, s){
    var node$0 = node, acc$0 = acc, n$0 = n;
    for(;;){
     if(0 >= n$0){
      var _ak_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _ak_);
     }
     if(node$0 === s[5][1]){
      var _ai_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _ai_,
               function(param){return npeek_rec(node$0, acc$0, n$0, s);});
     }
     var match = node$0[2];
     if(! match){
      var _aj_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _aj_);
     }
     var
      x = match[1],
      n$1 = n$0 - 1 | 0,
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
     n$0 = n$1;
    }
   }
   function npeek(n, s){return npeek_rec(s[4], 0, n, s);}
   function get_rec(s, node){
    if(node === s[5][1]){
     var _ah_ = feed(s);
     return caml_call2
             (Lwt[33][1], _ah_, function(param){return get_rec(s, node);});
    }
    if(0 !== node[2]) consume(s, node);
    return caml_call1(Lwt[4], node[2]);
   }
   function get(s){return get_rec(s, s[4]);}
   function get_exn_rec(s, node){
    if(node === s[5][1])
     return caml_call3
             (Lwt[9],
              function(param){return feed(s);},
              function(param){return get_exn_rec(s, node);},
              function(exn){return caml_call1(Lwt[4], [0, [1, exn]]);});
    var match = node[2];
    if(! match) return Lwt[37];
    var value = match[1];
    consume(s, node);
    return caml_call1(Lwt[4], [0, [0, value]]);
   }
   function wrap_exn(s){
    return from(function(param){return get_exn_rec(s, s[4]);});
   }
   function nget_rec(node, acc, n, s){
    var node$0 = node, acc$0 = acc, n$0 = n;
    for(;;){
     if(0 >= n$0){
      var _ag_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _ag_);
     }
     if(node$0 === s[5][1]){
      var _ae_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _ae_,
               function(param){return nget_rec(node$0, acc$0, n$0, s);});
     }
     var match = s[4][2];
     if(! match){
      var _af_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _af_);
     }
     var x = match[1];
     consume(s, node$0);
     var n$1 = n$0 - 1 | 0, acc$1 = [0, x, acc$0], node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
     n$0 = n$1;
    }
   }
   function nget(n, s){return nget_rec(s[4], 0, n, s);}
   function get_while_rec(node, acc, f, s){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var _ab_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _ab_,
               function(param){return get_while_rec(node$0, acc$0, f, s);});
     }
     var match = node$0[2];
     if(! match){
      var _ad_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _ad_);
     }
     var x = match[1], test = caml_call1(f, x);
     if(! test){
      var _ac_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _ac_);
     }
     consume(s, node$0);
     var acc$1 = [0, x, acc$0], node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
    }
   }
   function get_while(f, s){return get_while_rec(s[4], 0, f, s);}
   function get_while_s_rec(node, acc, f, s){
    if(node === s[5][1]){
     var _Z_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _Z_,
              function(param){return get_while_s_rec(node, acc, f, s);});
    }
    var match = node[2];
    if(match){
     var x = match[1], ___ = caml_call1(f, x);
     return caml_call2
             (Lwt[33][1],
              ___,
              function(param){
               if(param){
                consume(s, node);
                return get_while_s_rec(node[1], [0, x, acc], f, s);
               }
               var _aa_ = caml_call1(Stdlib_List[9], acc);
               return caml_call1(Lwt[4], _aa_);
              });
    }
    var _$_ = caml_call1(Stdlib_List[9], acc);
    return caml_call1(Lwt[4], _$_);
   }
   function get_while_s(f, s){return get_while_s_rec(s[4], 0, f, s);}
   function next_rec(s, node){
    if(node === s[5][1]){
     var _Y_ = feed(s);
     return caml_call2
             (Lwt[33][1], _Y_, function(param){return next_rec(s, node);});
    }
    var match = node[2];
    if(! match) return caml_call1(Lwt[5], Empty);
    var x = match[1];
    consume(s, node);
    return caml_call1(Lwt[4], x);
   }
   function next(s){return next_rec(s, s[4]);}
   function last_new_rec(node, x, s){
    var node$0 = node, x$0 = x;
    for(;;)
     if(node$0 === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Lwt[4], x$0);
      if(0 !== match[0]){var exn = match[1]; return caml_call1(Lwt[5], exn);}
     }
     else{
      var match$0 = node$0[2];
      if(! match$0) return caml_call1(Lwt[4], x$0);
      var x$1 = match$0[1];
      consume(s, node$0);
      var node$1 = node$0[1];
      node$0 = node$1;
      x$0 = x$1;
     }
   }
   function last_new(s){
    var node = s[4];
    if(node !== s[5][1]){
     var match$0 = node[2];
     if(! match$0) return caml_call1(Lwt[5], Empty);
     var x$0 = match$0[1];
     consume(s, node);
     return last_new_rec(node[1], x$0, s);
    }
    var thread = next(s), match = caml_call1(Lwt[48], thread);
    if(typeof match !== "number" && 0 === match[0]){
     var x = match[1];
     return last_new_rec(node, x, s);
    }
    return thread;
   }
   function to_list_rec(node, acc, s){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var _W_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _W_,
               function(param){return to_list_rec(node$0, acc$0, s);});
     }
     var match = node$0[2];
     if(! match){
      var _X_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _X_);
     }
     var x = match[1];
     consume(s, node$0);
     var acc$1 = [0, x, acc$0], node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
    }
   }
   function to_list(s){return to_list_rec(s[4], 0, s);}
   function to_string_rec(node, buf, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _U_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _U_,
               function(param){return to_string_rec(node$0, buf, s);});
     }
     var match = node$0[2];
     if(! match){
      var _V_ = caml_call1(Stdlib_Buffer[2], buf);
      return caml_call1(Lwt[4], _V_);
     }
     var x = match[1];
     consume(s, node$0);
     caml_call2(Stdlib_Buffer[12], buf, x);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function to_string(s){
    var _T_ = caml_call1(Stdlib_Buffer[1], 128);
    return to_string_rec(s[4], _T_, s);
   }
   function junk(s){
    var node = s[4];
    if(node === s[5][1]){
     var _S_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _S_,
              function(param){
               if(0 !== node[2]) consume(s, node);
               return Lwt[36];
              });
    }
    if(0 !== node[2]) consume(s, node);
    return Lwt[36];
   }
   function njunk_rec(node, n, s){
    var node$0 = node, n$0 = n;
    for(;;){
     if(0 >= n$0) return Lwt[36];
     if(node$0 === s[5][1]){
      var _R_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _R_,
               function(param){return njunk_rec(node$0, n$0, s);});
     }
     if(! node$0[2]) return Lwt[36];
     consume(s, node$0);
     var n$1 = n$0 - 1 | 0, node$1 = node$0[1];
     node$0 = node$1;
     n$0 = n$1;
    }
   }
   function njunk(n, s){return njunk_rec(s[4], n, s);}
   function junk_while_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _Q_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _Q_,
               function(param){return junk_while_rec(node$0, f, s);});
     }
     var match = node$0[2];
     if(! match) return Lwt[36];
     var x = match[1], test = caml_call1(f, x);
     if(! test) return Lwt[36];
     consume(s, node$0);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function junk_while(f, s){return junk_while_rec(s[4], f, s);}
   function junk_while_s_rec(node, f, s){
    if(node === s[5][1]){
     var _O_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _O_,
              function(param){return junk_while_s_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1], _P_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _P_,
             function(param){
              return param
                      ? (consume(s, node), junk_while_s_rec(node[1], f, s))
                      : Lwt[36];
             });
   }
   function junk_while_s(f, s){return junk_while_s_rec(s[4], f, s);}
   function junk_available(s){
    var node$1 = s[4], node = node$1;
    for(;;)
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      if(! node[2]) return 0;
      consume(s, node);
      var node$0 = node[1];
      node = node$0;
     }
   }
   function junk_old(s){
    var _N_ = junk_available(s);
    return caml_call1(Lwt[4], _N_);
   }
   function get_available(s){
    var node$1 = s[4], node = node$1, acc = 0;
    for(;;)
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Stdlib_List[9], acc);
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      var match$0 = node[2];
      if(! match$0) return caml_call1(Stdlib_List[9], acc);
      var x = match$0[1];
      consume(s, node);
      var acc$0 = [0, x, acc], node$0 = node[1];
      node = node$0;
      acc = acc$0;
     }
   }
   function get_available_up_to(n$1, s){
    var node$1 = s[4], node = node$1, acc = 0, n = n$1;
    for(;;){
     if(0 >= n) return caml_call1(Stdlib_List[9], acc);
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Stdlib_List[9], acc);
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      var match$0 = s[4][2];
      if(! match$0) return caml_call1(Stdlib_List[9], acc);
      var x = match$0[1];
      consume(s, node);
      var n$0 = n - 1 | 0, acc$0 = [0, x, acc], node$0 = node[1];
      node = node$0;
      acc = acc$0;
      n = n$0;
     }
    }
   }
   function is_empty(s){
    if(s[4] !== s[5][1]) return caml_call1(Lwt[4], 0 === s[4][2] ? 1 : 0);
    var _M_ = feed(s);
    return caml_call2(Lwt[33][1], _M_, function(param){return is_empty(s);});
   }
   function map(f, s){
    return from
            (function(param){
              var _L_ = get(s);
              return caml_call2
                      (Lwt[33][2],
                       _L_,
                       function(param){
                        if(! param) return 0;
                        var x = param[1], x$0 = caml_call1(f, x);
                        return [0, x$0];
                       });
             });
   }
   function map_s(f, s){
    return from
            (function(param){
              var _J_ = get(s);
              return caml_call2
                      (Lwt[33][1],
                       _J_,
                       function(param){
                        if(! param) return Lwt[37];
                        var x = param[1], _K_ = caml_call1(f, x);
                        return caml_call2
                                (Lwt[33][2], _K_, function(x){return [0, x];});
                       });
             });
   }
   function filter(f, s){
    function next(param){
     var t = get(s);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], test = caml_call1(f, x);
               return test ? t : next(0);
              });
    }
    return from(next);
   }
   function filter_s(f, s){
    function next(param){
     var t = get(s);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(! param) return t;
               var x = param[1], _I_ = caml_call1(f, x);
               return caml_call2
                       (Lwt[33][1],
                        _I_,
                        function(param){return param ? t : next(0);});
              });
    }
    return from(next);
   }
   function filter_map(f, s){
    function next(param){
     var _H_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _H_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], x$0 = caml_call1(f, x);
               return x$0 ? caml_call1(Lwt[4], x$0) : next(0);
              });
    }
    return from(next);
   }
   function filter_map_s(f, s){
    function next(param){
     var _G_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _G_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], t = caml_call1(f, x);
               return caml_call2
                       (Lwt[33][1],
                        t,
                        function(param){return param ? t : next(0);});
              });
    }
    return from(next);
   }
   function map_list(f, s){
    var pendings = [0, 0];
    function next(param){
     var match = pendings[1];
     if(match){
      var l = match[2], x = match[1];
      pendings[1] = l;
      return caml_call1(Lwt[4], [0, x]);
     }
     var _F_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _F_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], l = caml_call1(f, x);
               pendings[1] = l;
               return next(0);
              });
    }
    return from(next);
   }
   function map_list_s(f, s){
    var pendings = [0, 0];
    function next(param){
     var match = pendings[1];
     if(match){
      var l = match[2], x = match[1];
      pendings[1] = l;
      return caml_call1(Lwt[4], [0, x]);
     }
     var _D_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _D_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], _E_ = caml_call1(f, x);
               return caml_call2
                       (Lwt[33][1],
                        _E_,
                        function(l){pendings[1] = l; return next(0);});
              });
    }
    return from(next);
   }
   function flatten(s){return map_list(function(l){return l;}, s);}
   function fold_rec(node, f, s, acc){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var _C_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _C_,
               function(param){return fold_rec(node$0, f, s, acc$0);});
     }
     var match = node$0[2];
     if(! match) return caml_call1(Lwt[4], acc$0);
     var x = match[1];
     consume(s, node$0);
     var acc$1 = caml_call2(f, x, acc$0), node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
    }
   }
   function fold(f, s, acc){return fold_rec(s[4], f, s, acc);}
   function fold_s_rec(node, f, s, acc){
    if(node === s[5][1]){
     var _A_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _A_,
              function(param){return fold_s_rec(node, f, s, acc);});
    }
    var match = node[2];
    if(! match) return caml_call1(Lwt[4], acc);
    var x = match[1];
    consume(s, node);
    var _B_ = caml_call2(f, x, acc);
    return caml_call2
            (Lwt[33][1],
             _B_,
             function(acc){return fold_s_rec(node[1], f, s, acc);});
   }
   function fold_s(f, s, acc){return fold_s_rec(s[4], f, s, acc);}
   function iter_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _z_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _z_,
               function(param){return iter_rec(node$0, f, s);});
     }
     var match = node$0[2];
     if(! match) return Lwt[36];
     var x = match[1];
     consume(s, node$0);
     caml_call1(f, x);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function iter(f, s){return iter_rec(s[4], f, s);}
   function iter_s_rec(node, f, s){
    if(node === s[5][1]){
     var _x_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _x_,
              function(param){return iter_s_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    consume(s, node);
    var _y_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _y_,
             function(param){return iter_s_rec(node[1], f, s);});
   }
   function iter_s(f, s){return iter_s_rec(s[4], f, s);}
   function iter_p_rec(node, f, s){
    if(node === s[5][1]){
     var _w_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _w_,
              function(param){return iter_p_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    consume(s, node);
    var res = caml_call1(f, x), rest = iter_p_rec(node[1], f, s);
    return caml_call2(Lwt[33][1], res, function(param){return rest;});
   }
   function iter_p(f, s){return iter_p_rec(s[4], f, s);}
   function iter_n(opt, f, stream){
    if(opt)
     var sth = opt[1], max_concurrency = sth;
    else
     var max_concurrency = 1;
    if(max_concurrency <= 0){
     var message = caml_call2(Stdlib_Printf[4], _b_, max_concurrency);
     caml_call1(Stdlib[1], message);
    }
    function loop(running, available){
     function _r_(param){
      var available = param[2], running = param[1], _v_ = get(stream);
      return caml_call2
              (Lwt[33][1],
               _v_,
               function(param){
                if(! param) return caml_call1(Lwt[14], running);
                var elt = param[1];
                return loop
                        ([0, caml_call1(f, elt), running], available - 1 | 0);
               });
     }
     if(0 < available)
      var _s_ = caml_call1(Lwt[4], [0, running, available]);
     else
      var
       _t_ = caml_call1(Lwt[20], running),
       _s_ =
         caml_call2
          (Lwt[33][1],
           _t_,
           function(param){
            var
             running = param[2],
             complete = param[1],
             _u_ =
               [0,
                running,
                available + caml_call1(Stdlib_List[1], complete) | 0];
            return caml_call1(Lwt[4], _u_);
           });
     return caml_call2(Lwt[33][1], _s_, _r_);
    }
    return loop(0, max_concurrency);
   }
   function find_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _q_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _q_,
               function(param){return find_rec(node$0, f, s);});
     }
     var opt = node$0[2];
     if(! opt) return Lwt[37];
     var x = opt[1];
     consume(s, node$0);
     var test = caml_call1(f, x);
     if(test) return caml_call1(Lwt[4], opt);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function find(f, s){return find_rec(s[4], f, s);}
   function find_s_rec(node, f, s){
    if(node === s[5][1]){
     var _o_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _o_,
              function(param){return find_s_rec(node, f, s);});
    }
    var opt = node[2];
    if(! opt) return Lwt[37];
    var x = opt[1];
    consume(s, node);
    var _p_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _p_,
             function(param){
              return param
                      ? caml_call1(Lwt[4], opt)
                      : find_s_rec(node[1], f, s);
             });
   }
   function find_s(f, s){return find_s_rec(s[4], f, s);}
   function find_map_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _n_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _n_,
               function(param){return find_map_rec(node$0, f, s);});
     }
     var match = node$0[2];
     if(! match) return Lwt[37];
     var x = match[1];
     consume(s, node$0);
     var x$0 = caml_call1(f, x);
     if(0 !== x$0) return caml_call1(Lwt[4], x$0);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function find_map(f, s){return find_map_rec(s[4], f, s);}
   function find_map_s_rec(node, f, s){
    if(node === s[5][1]){
     var _m_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _m_,
              function(param){return find_map_s_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[37];
    var x = match[1];
    consume(s, node);
    var t = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             t,
             function(param){
              return param ? t : find_map_s_rec(node[1], f, s);
             });
   }
   function find_map_s(f, s){return find_map_s_rec(s[4], f, s);}
   function combine(s1, s2){
    function next(param){
     var t1 = get(s1), t2 = get(s2);
     return caml_call2
             (Lwt[33][1],
              t1,
              function(n1){
               return caml_call2
                       (Lwt[33][1],
                        t2,
                        function(n2){
                         if(n1 && n2){
                          var x2 = n2[1], x1 = n1[1];
                          return caml_call1(Lwt[4], [0, [0, x1, x2]]);
                         }
                         return Lwt[37];
                        });
              });
    }
    return from(next);
   }
   function append(s1, s2){
    var current_s = [0, s1];
    function next(param){
     var t = get(current_s[1]);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               return param
                       ? t
                       : current_s
                          [1]
                         === s2
                         ? Lwt[37]
                         : (current_s[1] = s2, next(0));
              });
    }
    return from(next);
   }
   function concat(s_top){
    var current_s = [0, from(function(param){return Lwt[37];})];
    function next(param){
     var t = get(current_s[1]);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(param) return t;
               var _l_ = get(s_top);
               return caml_call2
                       (Lwt[33][1],
                        _l_,
                        function(param){
                         if(! param) return Lwt[37];
                         var s = param[1];
                         current_s[1] = s;
                         return next(0);
                        });
              });
    }
    return from(next);
   }
   function choose(streams){
    function source(s){
     var _k_ = get(s);
     return [0,
             s,
             caml_call2(Lwt[33][2], _k_, function(x){return [0, s, x];})];
    }
    var streams$0 = [0, caml_call2(Stdlib_List[19], source, streams)];
    function next(param){
     var l = streams$0[1];
     if(! l) return Lwt[37];
     var
      _h_ = caml_call2(Stdlib_List[19], function(_j_){return _j_[2];}, l),
      _i_ = caml_call1(Lwt[17], _h_);
     return caml_call2
             (Lwt[33][1],
              _i_,
              function(param){
               var
                x = param[2],
                s = param[1],
                l$0 = caml_call2(Stdlib_List[53], s, l);
               return x
                       ? (streams$0
                          [1]
                         = [0, source(s), l$0],
                         caml_call1(Lwt[4], x))
                       : (streams$0[1] = l$0, next(0));
              });
    }
    return from(next);
   }
   function parse(s, f){
    if(3 === s[1][0]) caml_call1(Stdlib[1], cst_Lwt_stream_parse);
    var node = s[4];
    return caml_call2
            (Lwt[7],
             function(param){return caml_call1(f, s);},
             function(exn){
              s[4] = node;
              throw caml_maybe_attach_backtrace(exn, 0);
             });
   }
   function hexdump(stream){
    var buf = caml_call1(Stdlib_Buffer[1], 80), num = [0, 0];
    return from
            (function(param){
              var _e_ = nget(16, stream);
              return caml_call2
                      (Lwt[33][1],
                       _e_,
                       function(l){
                        if(! l) return Lwt[37];
                        caml_call1(Stdlib_Buffer[8], buf);
                        caml_call3(Stdlib_Printf[5], buf, _c_, num[1]);
                        num[1] = num[1] + 16 | 0;
                        var pos = 0, param = l;
                        for(;;){
                         if(! param) break;
                         var l$0 = param[2], x = param[1];
                         if(8 === pos) caml_call2(Stdlib_Buffer[12], buf, 32);
                         caml_call3(Stdlib_Printf[5], buf, _d_, x);
                         var pos$0 = pos + 1 | 0;
                         pos = pos$0;
                         param = l$0;
                        }
                        var pos$1 = pos;
                        for(;;){
                         if(pos$1 >= 16) break;
                         if(8 === pos$1)
                          caml_call2(Stdlib_Buffer[16], buf, cst$3);
                         else
                          caml_call2(Stdlib_Buffer[16], buf, cst$4);
                         var pos$2 = pos$1 + 1 | 0;
                         pos$1 = pos$2;
                        }
                        caml_call2(Stdlib_Buffer[16], buf, cst$5);
                        caml_call2
                         (Stdlib_List[17],
                          function(ch){
                           a:
                           {
                            if(32 <= ch && 126 >= ch){var _g_ = ch; break a;}
                            var _g_ = 46;
                           }
                           return caml_call2(Stdlib_Buffer[12], buf, _g_);
                          },
                          l);
                        caml_call2(Stdlib_Buffer[12], buf, 124);
                        var _f_ = [0, caml_call1(Stdlib_Buffer[2], buf)];
                        return caml_call1(Lwt[4], _f_);
                       });
             });
   }
   var
    Lwt_stream =
      [0,
       from,
       from_direct,
       Closed,
       create,
       create_with_reference,
       Full,
       create_bounded,
       return$0,
       return_lwt,
       of_seq,
       of_lwt_seq,
       of_list,
       of_array,
       of_string,
       clone,
       to_list,
       to_string,
       Empty,
       peek,
       npeek,
       get,
       nget,
       get_while,
       get_while_s,
       next,
       last_new,
       junk,
       njunk,
       junk_while,
       junk_while_s,
       junk_available,
       get_available,
       get_available_up_to,
       is_empty,
       is_closed,
       closed,
       junk_old,
       choose,
       map,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       map_list,
       map_list_s,
       fold,
       fold_s,
       iter,
       iter_p,
       iter_s,
       iter_n,
       find,
       find_s,
       find_map,
       find_map_s,
       combine,
       append,
       concat,
       flatten,
       wrap_exn,
       parse,
       hexdump];
   runtime.caml_register_global(28, Lwt_stream, "Lwt_stream");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_result
//# unitInfo: Requires: Assert_failure, Lwt
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Assert_failure = global_data.Assert_failure;
   function return$0(x){return caml_call1(Lwt[4], [0, x]);}
   function fail(e){return caml_call1(Lwt[4], [1, e]);}
   var lift = Lwt[4], _a_ = [0, "src/core/lwt_result.ml", 84, 14];
   function ok(x){return caml_call2(Lwt[28], function(y){return [0, y];}, x);}
   function error(x){
    return caml_call2(Lwt[28], function(y){return [1, y];}, x);
   }
   function map(f, e){
    return caml_call2
            (Lwt[28],
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return [0, caml_call1(f, x)];
              }
              var e = param[1];
              return [1, e];
             },
             e);
   }
   function map_error(f, e){
    return caml_call2
            (Lwt[28],
             function(param){
              if(0 === param[0]){var x = param[1]; return [0, x];}
              var e = param[1];
              return [1, caml_call1(f, e)];
             },
             e);
   }
   function map_err(f, e){return map_error(f, e);}
   function catch$0(e){
    return caml_call2
            (Lwt[7], function(param){return ok(caml_call1(e, 0));}, fail);
   }
   function get_exn(e){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return caml_call1(Lwt[4], x);
              }
              var e = param[1];
              return caml_call1(Lwt[5], e);
             });
   }
   function symbol_bind(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
              var e = param[1];
              return caml_call1(Lwt[4], [1, e]);
             });
   }
   function bind_error(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return caml_call1(Lwt[4], [0, x]);
              }
              var e = param[1];
              return caml_call1(f, e);
             });
   }
   function bind_lwt(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return ok(caml_call1(f, x));
              }
              var e = param[1];
              return fail(e);
             });
   }
   function bind_result(e, f){
    return caml_call2
            (Lwt[28],
             function(param){
              if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
              var e = param[1];
              return [1, e];
             },
             e);
   }
   function bind_lwt_error(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){var x = param[1]; return return$0(x);}
              var e = param[1], _d_ = caml_call1(f, e);
              return caml_call2(Lwt[6], _d_, fail);
             });
   }
   function bind_lwt_err(e, f){return bind_lwt_error(e, f);}
   function both(a, b){
    var s = [0, 0];
    function set_once(e){return s[1] ? 0 : (s[1] = [0, e], 0);}
    var
     b$0 = map_error(set_once, b),
     a$0 = map_error(set_once, a),
     _b_ = caml_call2(Lwt[13], a$0, b$0);
    return caml_call2
            (Lwt[28],
             function(param){
              var _c_ = param[1];
              if(0 === _c_[0]){
               var match = param[2], x = _c_[1];
               if(0 === match[0]){var y = match[1]; return [0, [0, x, y]];}
              }
              var param$0 = s[1];
              if(! param$0)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
              var e = param$0[1];
              return [1, e];
             },
             _b_);
   }
   function iter(f, r){
    return caml_call2
            (Lwt[6],
             r,
             function(param){
              if(0 !== param[0]) return Lwt[36];
              var x = param[1];
              return caml_call1(f, x);
             });
   }
   function iter_error(f, r){
    return caml_call2
            (Lwt[6],
             r,
             function(param){
              if(0 === param[0]) return Lwt[36];
              var e = param[1];
              return caml_call1(f, e);
             });
   }
   function symbol(e, f){return map(f, e);}
   function map$0(t, f){return map(f, t);}
   function bind(t, f){return symbol_bind(t, f);}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, map$0, bind, both, Open_on_rhs],
    Let_syntax$0 = [0, Let_syntax];
   function let$0(x, f){return map(f, x);}
   var
    Syntax = [0, symbol_bind, both, let$0, both],
    Lwt_result =
      [0,
       return$0,
       fail,
       lift,
       ok,
       error,
       catch$0,
       get_exn,
       map,
       map_error,
       symbol_bind,
       bind_error,
       bind_lwt,
       bind_lwt_error,
       bind_result,
       both,
       iter,
       iter_error,
       [0, symbol, symbol_bind],
       Let_syntax$0,
       Syntax,
       symbol,
       symbol_bind,
       map_err,
       bind_lwt_err];
   runtime.caml_register_global(3, Lwt_result, "Lwt_result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_pqueue
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, "src/core/lwt_pqueue.ml", 81, 15];
   function Make(Ord){
    function link(t1, t2){
     var
      c2 = t2[3],
      r2 = t2[2],
      x2 = t2[1],
      c1 = t1[3],
      r1 = t1[2],
      x1 = t1[1],
      c = caml_call2(Ord[1], x1, x2);
     return 0 < c
             ? [0, x2, r2 + 1 | 0, [0, t1, c2]]
             : [0, x1, r1 + 1 | 0, [0, t2, c1]];
    }
    function ins(t, ts){
     var t$0 = t, ts$0 = ts;
     for(;;){
      if(! ts$0) return [0, t$0, 0];
      var t$1 = ts$0[1], r$0 = t$1[2], r = t$0[2];
      if(r < r$0) return [0, t$0, ts$0];
      var ts$1 = ts$0[2], t$2 = link(t$0, t$1);
      t$0 = t$2;
      ts$0 = ts$1;
     }
    }
    function is_empty(ts){return 0 === ts ? 1 : 0;}
    function add(x, ts){return ins([0, x, 0, 0], ts);}
    function union(ts$0, ts){
     if(! ts$0) return ts;
     if(! ts) return ts$0;
     var
      ts2 = ts[2],
      t2 = ts[1],
      ts1 = ts$0[2],
      t1 = ts$0[1],
      r = t2[2],
      r$2 = t1[2];
     if(r$2 < r) return [0, t1, union(ts1, [0, t2, ts2])];
     var r$1 = t1[2], r$0 = t2[2];
     if(r$0 < r$1) return [0, t2, union([0, t1, ts1], ts2)];
     var _c_ = union(ts1, ts2);
     return ins(link(t1, t2), _c_);
    }
    function find_min(param){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var t = param[1];
     if(! param[2]){var x$2 = t[1]; return x$2;}
     var
      ts = param[2],
      x = find_min(ts),
      x$1 = t[1],
      c = caml_call2(Ord[1], x$1, x);
     if(0 <= c) return x;
     var x$0 = t[1];
     return x$0;
    }
    function lookup_min(param){
     if(! param) return 0;
     var t = param[1];
     if(! param[2]){var x$2 = t[1]; return [0, x$2];}
     var ts = param[2], result = lookup_min(ts);
     if(! result) return 0;
     var x = result[1], x$1 = t[1], c = caml_call2(Ord[1], x$1, x);
     if(0 <= c) return result;
     var x$0 = t[1];
     return [0, x$0];
    }
    function get_min(param){
     if(! param)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var t = param[1];
     if(! param[2]) return [0, t, 0];
     var
      ts = param[2],
      match = get_min(ts),
      ts$0 = match[2],
      t$0 = match[1],
      x = t$0[1],
      x$0 = t[1],
      c = caml_call2(Ord[1], x$0, x);
     return 0 <= c ? [0, t$0, [0, t, ts$0]] : [0, t, ts];
    }
    function remove_min(ts){
     if(! ts) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var _b_ = get_min(ts), ts$0 = _b_[2], c = _b_[1][3];
     return union(caml_call1(Stdlib_List[9], c), ts$0);
    }
    function size(l){
     return caml_call3
             (Stdlib_List[25],
              function(s, t){
               var tl = t[3];
               return s + (1 + size(tl) | 0) | 0;
              },
              0,
              l);
    }
    return [0,
            0,
            is_empty,
            add,
            union,
            find_min,
            lookup_min,
            remove_min,
            size];
   }
   var Lwt_pqueue = [0, Make];
   runtime.caml_register_global(4, Lwt_pqueue, "Lwt_pqueue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_list
//# unitInfo: Requires: Lwt, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List;
   function tail_recursive_map(f, l){
    var _O_ = caml_call2(Stdlib_List[21], f, l);
    return caml_call1(Stdlib_List[9], _O_);
   }
   function tail_recursive_mapi_rev(f, l){
    var acc = 0, i = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      tl = param[2],
      hd = param[1],
      i$0 = i + 1 | 0,
      acc$0 = [0, caml_call2(f, i, hd), acc];
     acc = acc$0;
     i = i$0;
     param = tl;
    }
   }
   function iter_s(f, l){
    if(! l) return Lwt[36];
    var l$0 = l[2], x = l[1], _N_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1], _N_, function(param){return iter_s(f, l$0);});
   }
   function iter_p(f, l){
    var
     _M_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[21], _M_, l);
    return caml_call1(Lwt[14], ts);
   }
   function _a_(i, f, l){
    if(! l) return Lwt[36];
    var
     l$0 = l[2],
     x = l[1],
     _K_ = caml_call1(f, i),
     _L_ = caml_call2(Lwt[80], _K_, x);
    return caml_call2
            (Lwt[33][1], _L_, function(param){return _a_(i + 1 | 0, f, l$0);});
   }
   function iteri_s(f, l){return _a_(0, f, l);}
   function iteri_p(f, l){
    function f$0(i){
     var _J_ = caml_call1(f, i);
     return caml_call1(Lwt[80], _J_);
    }
    var ts = tail_recursive_mapi_rev(f$0, l);
    return caml_call1(Lwt[14], ts);
   }
   function map_s(f, l){
    function inner(acc, param){
     if(param){
      var tl = param[2], hd = param[1], _H_ = caml_call2(Lwt[80], f, hd);
      return caml_call2
              (Lwt[33][1], _H_, function(r){return inner([0, r, acc], tl);});
     }
     var _I_ = caml_call1(Stdlib_List[9], acc);
     return caml_call1(Lwt[4], _I_);
    }
    return inner(0, l);
   }
   function collect_rev(acc, param){
    if(! param) return caml_call1(Lwt[4], acc);
    var ts = param[2], t = param[1];
    return caml_call2
            (Lwt[33][1], t, function(i){return collect_rev([0, i, acc], ts);});
   }
   function map_p(f, l){
    var
     _G_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[21], _G_, l);
    return collect_rev(0, ts);
   }
   function filter_map_s(f, l){
    function inner(acc, param){
     if(param){
      var tl = param[2], hd = param[1], _E_ = caml_call2(Lwt[80], f, hd);
      return caml_call2
              (Lwt[33][1],
               _E_,
               function(param){
                if(! param) return inner(acc, tl);
                var v = param[1];
                return inner([0, v, acc], tl);
               });
     }
     var _F_ = caml_call1(Stdlib_List[9], acc);
     return caml_call1(Lwt[4], _F_);
    }
    return inner(0, l);
   }
   function filter_map_p(f, l){
    function collect_optional_rev(acc, param){
     if(! param) return caml_call1(Lwt[4], acc);
     var ts = param[2], t = param[1];
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(! param) return collect_optional_rev(acc, ts);
               var v = param[1];
               return collect_optional_rev([0, v, acc], ts);
              });
    }
    var
     _D_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[21], _D_, l);
    return collect_optional_rev(0, ts);
   }
   function mapi_s(f, l){
    function inner(acc, i, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       _A_ = caml_call1(f, i),
       _B_ = caml_call2(Lwt[80], _A_, hd);
      return caml_call2
              (Lwt[33][1],
               _B_,
               function(v){return inner([0, v, acc], i + 1 | 0, tl);});
     }
     var _C_ = caml_call1(Stdlib_List[9], acc);
     return caml_call1(Lwt[4], _C_);
    }
    return inner(0, 0, l);
   }
   function mapi_p(f, l){
    function f$0(i){
     var _z_ = caml_call1(f, i);
     return caml_call1(Lwt[80], _z_);
    }
    var ts = tail_recursive_mapi_rev(f$0, l);
    return collect_rev(0, ts);
   }
   function rev_map_append_s(acc, f, l){
    if(! l) return caml_call1(Lwt[4], acc);
    var l$0 = l[2], x = l[1], _y_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _y_,
             function(x){return rev_map_append_s([0, x, acc], f, l$0);});
   }
   function rev_map_s(f, l){return rev_map_append_s(0, f, l);}
   function rev_map_p(f, l$1){
    var acc$1 = Lwt[38], acc = acc$1, l = l$1;
    for(;;){
     if(! l) return acc;
     var l$0 = l[2], x = l[1];
     let acc$1 = acc;
     var
      _x_ = caml_call2(Lwt[80], f, x),
      acc$0 =
        caml_call2
         (Lwt[33][1],
          _x_,
          function(x){
           return caml_call2
                   (Lwt[33][2], acc$1, function(l){return [0, x, l];});
          });
     acc = acc$0;
     l = l$0;
    }
   }
   function fold_left_s(f, acc, l){
    if(! l) return caml_call1(Lwt[4], acc);
    var
     l$0 = l[2],
     x = l[1],
     _v_ = caml_call1(f, acc),
     _w_ = caml_call2(Lwt[80], _v_, x);
    return caml_call2
            (Lwt[33][1], _w_, function(acc){return fold_left_s(f, acc, l$0);});
   }
   function fold_right_s(f, l, acc){
    function inner(f, a, param){
     if(! param) return caml_call1(Lwt[4], a);
     var
      tl = param[2],
      hd = param[1],
      _t_ = caml_call1(f, hd),
      _u_ = caml_call2(Lwt[80], _t_, a);
     return caml_call2(Lwt[33][1], _u_, function(a){return inner(f, a, tl);});
    }
    return inner(f, acc, caml_call1(Stdlib_List[9], l));
   }
   function for_all_s(f, l){
    if(! l) return Lwt[39];
    var l$0 = l[2], x = l[1], _s_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _s_,
             function(param){return param ? for_all_s(f, l$0) : Lwt[40];});
   }
   function for_all_p(f, l){
    var _q_ = map_p(f, l);
    return caml_call2
            (Lwt[33][1],
             _q_,
             function(bl){
              var
               _r_ = caml_call2(Stdlib_List[32], function(x){return x;}, bl);
              return caml_call1(Lwt[4], _r_);
             });
   }
   function exists_s(f, l){
    if(! l) return Lwt[40];
    var l$0 = l[2], x = l[1], _p_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _p_,
             function(param){return param ? Lwt[39] : exists_s(f, l$0);});
   }
   function exists_p(f, l){
    var _n_ = map_p(f, l);
    return caml_call2
            (Lwt[33][1],
             _n_,
             function(bl){
              var
               _o_ = caml_call2(Stdlib_List[33], function(x){return x;}, bl);
              return caml_call1(Lwt[4], _o_);
             });
   }
   function find_s(f, l){
    if(! l) return caml_call1(Lwt[5], Stdlib[8]);
    var l$0 = l[2], x = l[1], _m_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _m_,
             function(param){
              return param ? caml_call1(Lwt[4], x) : find_s(f, l$0);
             });
   }
   function optionalize(f, x){
    var _l_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _l_,
             function(b){return b ? caml_call1(Lwt[4], [0, x]) : Lwt[37];});
   }
   function filter_s(f, l){
    return filter_map_s(function(_k_){return optionalize(f, _k_);}, l);
   }
   function filter_p(f, l){
    return filter_map_p(function(_j_){return optionalize(f, _j_);}, l);
   }
   function partition_s(f, l){
    function inner(acc1, acc2, param){
     if(param){
      var tl = param[2], hd = param[1], _g_ = caml_call2(Lwt[80], f, hd);
      return caml_call2
              (Lwt[33][1],
               _g_,
               function(b){
                return b
                        ? inner([0, hd, acc1], acc2, tl)
                        : inner(acc1, [0, hd, acc2], tl);
               });
     }
     var
      _h_ = caml_call1(Stdlib_List[9], acc2),
      _i_ = [0, caml_call1(Stdlib_List[9], acc1), _h_];
     return caml_call1(Lwt[4], _i_);
    }
    return inner(0, 0, l);
   }
   function partition_p(f, l){
    function g(x){
     var _f_ = caml_call2(Lwt[80], f, x);
     return caml_call2
             (Lwt[33][1],
              _f_,
              function(b){return caml_call1(Lwt[4], [0, b, x]);});
    }
    var _b_ = map_p(g, l);
    return caml_call2
            (Lwt[33][1],
             _b_,
             function(tl){
              var
               group1 =
                 tail_recursive_map
                  (function(_e_){return _e_[2];},
                   caml_call2
                    (Stdlib_List[41], function(_d_){return _d_[1];}, tl)),
               group2 =
                 tail_recursive_map
                  (function(_c_){return _c_[2];},
                   caml_call2
                    (Stdlib_List[41], function(x){return 1 - x[1];}, tl));
              return caml_call1(Lwt[4], [0, group1, group2]);
             });
   }
   var
    Lwt_list =
      [0,
       iter_s,
       iter_p,
       iteri_s,
       iteri_p,
       map_s,
       map_p,
       mapi_s,
       mapi_p,
       rev_map_s,
       rev_map_p,
       fold_left_s,
       fold_right_s,
       for_all_s,
       for_all_p,
       exists_s,
       exists_p,
       find_s,
       filter_s,
       filter_p,
       filter_map_s,
       filter_map_p,
       partition_s,
       partition_p];
   runtime.caml_register_global(3, Lwt_list, "Lwt_list");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_pool
//# unitInfo: Requires: Lwt, Lwt_list, Lwt_sequence, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Lwt_list = global_data.Lwt_list,
    Lwt = global_data.Lwt;
   function create(m, opt, _n_, _m_, create){
    if(opt)
     var sth = opt[1], validate = sth;
    else
     var validate = function(param){return Lwt[39];};
    if(_n_)
     var sth$0 = _n_[1], check = sth$0;
    else
     var check = function(param, f){return caml_call1(f, 1);};
    if(_m_)
     var sth$1 = _m_[1], dispose = sth$1;
    else
     var dispose = function(param){return Lwt[36];};
    var _o_ = caml_call1(Lwt_sequence[4], 0);
    return [0,
            create,
            check,
            validate,
            dispose,
            [0, [0, 0]],
            m,
            0,
            caml_call1(Stdlib_Queue[2], 0),
            _o_];
   }
   function create_member(p){
    return caml_call2
            (Lwt[7],
             function(param){p[7] = p[7] + 1 | 0; return caml_call1(p[1], 0);},
             function(exn){
              p[7] = p[7] - 1 | 0;
              return caml_call1(Lwt[5], exn);
             });
   }
   function release(p, c){
    var match = caml_call1(Lwt_sequence[13], p[9]);
    if(! match) return caml_call2(Stdlib_Queue[4], c, p[8]);
    var wakener = match[1];
    return caml_call2(Lwt[2], wakener, c);
   }
   function dispose(p, c){
    var _l_ = caml_call1(p[4], c);
    return caml_call2
            (Lwt[33][1],
             _l_,
             function(param){p[7] = p[7] - 1 | 0; return Lwt[36];});
   }
   function validate_and_return(p, c){
    return caml_call3
            (Lwt[9],
             function(param){return caml_call1(p[3], c);},
             function(param){
              if(param) return caml_call1(Lwt[4], c);
              var _k_ = dispose(p, c);
              return caml_call2
                      (Lwt[33][1], _k_, function(param){return create_member(p);});
             },
             function(e){
              var _i_ = dispose(p, c);
              return caml_call2
                      (Lwt[33][1],
                       _i_,
                       function(param){
                        var match = caml_call1(Lwt_sequence[13], p[9]);
                        if(match){
                         var wakener = match[1], _j_ = caml_call2(Lwt[80], p[1], 0);
                         caml_call3
                          (Lwt[32],
                           _j_,
                           function(c){return caml_call2(Lwt[2], wakener, c);},
                           function(exn){return caml_call2(Lwt[3], wakener, exn);});
                        }
                        throw caml_maybe_attach_backtrace(e, 0);
                       });
             });
   }
   function use(p, f){
    function _c_(c){
     var
      cleared = p[5][1],
      promise =
        caml_call2
         (Lwt[7],
          function(param){return caml_call1(f, c);},
          function(e){
           var cleared$0 = cleared[1], ok = [0, 0];
           caml_call2(p[2], c, function(result){ok[1] = result; return 0;});
           a:
           {
            var _g_ = function(param){return caml_call1(Lwt[5], e);};
            if(! cleared$0 && ok[1]){
             release(p, c);
             var _h_ = Lwt[36];
             break a;
            }
            var _h_ = dispose(p, c);
           }
           return caml_call2(Lwt[33][1], _h_, _g_);
          });
     return caml_call2
             (Lwt[33][1],
              promise,
              function(param){
               if(cleared[1]){
                var _f_ = dispose(p, c);
                return caml_call2
                        (Lwt[33][1], _f_, function(param){return promise;});
               }
               release(p, c);
               return promise;
              });
    }
    if(caml_call1(Stdlib_Queue[13], p[8]))
     if(p[7] < p[6])
      var _d_ = create_member(p);
     else
      var
       _b_ = caml_call1(Lwt[55], p[9]),
       _d_ =
         caml_call2
          (Lwt[33][1],
           _b_,
           function(_e_){return validate_and_return(p, _e_);});
    else
     var
      c = caml_call1(Stdlib_Queue[5], p[8]),
      _d_ = validate_and_return(p, c);
    return caml_call2(Lwt[33][1], _d_, _c_);
   }
   function clear(p){
    var
     elements =
       caml_call3
        (Stdlib_Queue[16],
         function(l, element){return [0, element, l];},
         0,
         p[8]);
    caml_call1(Stdlib_Queue[11], p[8]);
    var old_cleared = p[5][1];
    old_cleared[1] = 1;
    p[5][1] = [0, 0];
    return caml_call2
            (Lwt_list[1], function(_a_){return dispose(p, _a_);}, elements);
   }
   function wait_queue_length(p){return caml_call1(Lwt_sequence[7], p[9]);}
   var Lwt_pool = [0, create, use, clear, wait_queue_length];
   runtime.caml_register_global(4, Lwt_pool, "Lwt_pool");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_mvar
//# unitInfo: Requires: Lwt, Lwt_sequence
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence;
   function create_empty(param){
    var _b_ = caml_call1(Lwt_sequence[4], 0);
    return [0, 0, caml_call1(Lwt_sequence[4], 0), _b_];
   }
   function create(v){
    var _a_ = caml_call1(Lwt_sequence[4], 0);
    return [0, [0, v], caml_call1(Lwt_sequence[4], 0), _a_];
   }
   function put(mvar, v){
    if(mvar[1]){
     var
      match = caml_call1(Lwt[22], 0),
      w = match[2],
      res = match[1],
      node = caml_call2(Lwt_sequence[9], [0, v, w], mvar[2]);
     caml_call2
      (Lwt[24],
       res,
       function(param){return caml_call1(Lwt_sequence[3], node);});
     return res;
    }
    var match$0 = caml_call1(Lwt_sequence[13], mvar[3]);
    if(match$0){
     var w$0 = match$0[1];
     caml_call2(Lwt[2], w$0, v);
    }
    else
     mvar[1] = [0, v];
    return Lwt[36];
   }
   function take_available(mvar){
    var match$1 = mvar[1];
    if(! match$1) return 0;
    var v$0 = match$1[1], match = caml_call1(Lwt_sequence[13], mvar[2]);
    if(match){
     var match$0 = match[1], w = match$0[2], v = match$0[1];
     mvar[1] = [0, v];
     caml_call2(Lwt[2], w, 0);
    }
    else
     mvar[1] = 0;
    return [0, v$0];
   }
   function take(mvar){
    var match = take_available(mvar);
    if(! match) return caml_call1(Lwt[55], mvar[3]);
    var v = match[1];
    return caml_call1(Lwt[4], v);
   }
   function is_empty(mvar){return mvar[1] ? 0 : 1;}
   var
    Lwt_mvar = [0, create, create_empty, put, take, take_available, is_empty];
   runtime.caml_register_global(2, Lwt_mvar, "Lwt_mvar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_mutex
//# unitInfo: Requires: Lwt, Lwt_sequence
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Lwt = global_data.Lwt;
   function create(param){return [0, 0, caml_call1(Lwt_sequence[4], 0)];}
   function lock(m){
    return m[1] ? caml_call1(Lwt[55], m[2]) : (m[1] = 1, Lwt[36]);
   }
   function unlock(m){
    var _b_ = m[1];
    if(! _b_) return _b_;
    if(caml_call1(Lwt_sequence[6], m[2])){m[1] = 0; return 0;}
    var _c_ = caml_call1(Lwt_sequence[11], m[2]);
    return caml_call2(Lwt[2], _c_, 0);
   }
   function with_lock(m, f){
    var _a_ = lock(m);
    return caml_call2
            (Lwt[33][1],
             _a_,
             function(param){
              return caml_call2
                      (Lwt[8], f, function(param){unlock(m); return Lwt[36];});
             });
   }
   function is_locked(m){return m[1];}
   function is_empty(m){return caml_call1(Lwt_sequence[6], m[2]);}
   var Lwt_mutex = [0, create, lock, unlock, is_locked, is_empty, with_lock];
   runtime.caml_register_global(2, Lwt_mutex, "Lwt_mutex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_condition
//# unitInfo: Requires: Lwt, Lwt_mutex, Lwt_sequence, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_List = global_data.Stdlib__List,
    Lwt_mutex = global_data.Lwt_mutex,
    create = Lwt_sequence[4];
   function wait(mutex, cvar){
    var waiter = caml_call1(Lwt[55], cvar);
    if(mutex){var m = mutex[1]; caml_call1(Lwt_mutex[3], m);}
    return caml_call2
            (Lwt[8],
             function(param){return waiter;},
             function(param){
              if(! mutex) return Lwt[36];
              var m = mutex[1];
              return caml_call1(Lwt_mutex[2], m);
             });
   }
   function signal(cvar, arg){
    try{
     var
      _b_ = caml_call1(Lwt_sequence[11], cvar),
      _c_ = caml_call2(Lwt[2], _b_, arg);
     return _c_;
    }
    catch(_d_){
     var _a_ = caml_wrap_exception(_d_);
     if(_a_ === Lwt_sequence[10]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   function broadcast(cvar, arg){
    var
     wakeners =
       caml_call3
        (Lwt_sequence[22], function(x, l){return [0, x, l];}, cvar, 0);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], cvar);
    return caml_call2
            (Stdlib_List[17],
             function(wakener){return caml_call2(Lwt[2], wakener, arg);},
             wakeners);
   }
   function broadcast_exn(cvar, exn){
    var
     wakeners =
       caml_call3
        (Lwt_sequence[22], function(x, l){return [0, x, l];}, cvar, 0);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], cvar);
    return caml_call2
            (Stdlib_List[17],
             function(wakener){return caml_call2(Lwt[3], wakener, exn);},
             wakeners);
   }
   var Lwt_condition = [0, create, wait, signal, broadcast, broadcast_exn];
   runtime.caml_register_global(4, Lwt_condition, "Lwt_condition");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJFbXB0eSIsImdldCIsIm5vZGUiLCJzZXQiLCJkYXRhIiwicmVtb3ZlIiwiY3JlYXRlIiwicGFyYW0iLCJzZXEiLCJjbGVhciIsImlzX2VtcHR5IiwibGVuZ3RoIiwiY3VyciIsImxlbiIsImFkZF9sIiwiYWRkX3IiLCJ0YWtlX2wiLCJ0YWtlX3IiLCJ0YWtlX29wdF9sIiwidGFrZV9vcHRfciIsInRyYW5zZmVyX2wiLCJzMSIsInMyIiwidHJhbnNmZXJfciIsIml0ZXJfbCIsIml0ZXJfciIsIml0ZXJfbm9kZV9sIiwiaXRlcl9ub2RlX3IiLCJmb2xkX2wiLCJhY2MiLCJmb2xkX3IiLCJmaW5kX25vZGVfbCIsImZpbmRfbm9kZV9yIiwiZmluZF9ub2RlX29wdF9sIiwiZmluZF9ub2RlX29wdF9yIiwiTHd0X3NlcXVlbmNlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9kb2dhZGlubS8ub3BhbS9lbGlvbS9saWIvbHd0L2x3dF9zZXF1ZW5jZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMs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akIsU0FhakIsUUFBQUEsT0FBQSxRQUFBaUIsUUFBQTtBQUFBO0FBQUEsS0FURSxpQkFDRTtBQUFBLEtBR0E7QUFBQSxVQUFBQSxRQUNzQiwrQkFBQWpCLFNBQXNCO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUEsU0FFMUM7QUFBQTtBQUFBLEdBRVc7QUFBQSxZQUFBbUIsWUFBQXJDLEdBQUFjO0FBQUFBLFFBQUFJLFNBZ0JqQixRQUFBQSxPQUFBO0FBQUE7QUFBQSxLQVpFLGlCQVVFO0FBQUEsS0FSQTtBQUFBLE1BQ0ssMkJBQ0Q7QUFBQSxVQUFBQSxTQUVBO0FBQUE7QUFBQTtBQUFBLGNBQUFBLFNBRUY7QUFBQTtBQUFBLEdBSU87QUFBQSxZQUFBb0IsWUFBQXRDLEdBQUFjO0FBQUFBLFFBQUFJLFNBZ0JiLFFBQUFBLE9BQUE7QUFBQTtBQUFBLEtBWkUsaUJBVUU7QUFBQSxLQVJBO0FBQUEsTUFDSywyQkFDRDtBQUFBLFVBQUFBLFNBRUE7QUFBQTtBQUFBO0FBQUEsY0FBQUEsU0FFRjtBQUFBO0FBQUEsR0FJTztBQUFBLFlBQUFxQixnQkFBQXZDLEdBQUFjO0FBQUFBLElBR2IsY0FBUztBQUFBO0FBQUEsZURsT1g7QUFBQSwyQkNrT2lEO0FBQUEsS0RsT2pEO0FBQUE7QUFBQSxHQ2tPcUQ7QUFBQSxZQUFBMEIsZ0JBQUF4QyxHQUFBYztBQUFBQSxJQUduRCxjQUFTO0FBQUE7QUFBQSxlRHJPWDtBQUFBLDJCQ3FPaUQ7QUFBQSxLRHJPakQ7QUFBQTtBQUFBLEdDcU9xRDtBQUFBO0FBQUEsSUFBQTJCO0FBQUFBLE1Eck9yRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5leGNlcHRpb24gRW1wdHlcblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIHByZXYgOiAnYSB0O1xuICBtdXRhYmxlIG5leHQgOiAnYSB0O1xufVxuXG50eXBlICdhIG5vZGUgPSB7XG4gIG5vZGVfcHJldiA6ICdhIHQ7XG4gIG5vZGVfbmV4dCA6ICdhIHQ7XG4gIG11dGFibGUgbm9kZV9kYXRhIDogJ2E7XG4gIG11dGFibGUgbm9kZV9hY3RpdmUgOiBib29sO1xufVxuXG5leHRlcm5hbCBzZXFfb2Zfbm9kZSA6ICdhIG5vZGUgLT4gJ2EgdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG5vZGVfb2Zfc2VxIDogJ2EgdCAtPiAnYSBub2RlID0gXCIlaWRlbnRpdHlcIlxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IE9wZXJhdGlvbnMgb24gbm9kZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBnZXQgbm9kZSA9XG4gIG5vZGUubm9kZV9kYXRhXG5cbmxldCBzZXQgbm9kZSBkYXRhID1cbiAgbm9kZS5ub2RlX2RhdGEgPC0gZGF0YVxuXG5sZXQgcmVtb3ZlIG5vZGUgPVxuICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gYmVnaW5cbiAgICBub2RlLm5vZGVfYWN0aXZlIDwtIGZhbHNlO1xuICAgIGxldCBzZXEgPSBzZXFfb2Zfbm9kZSBub2RlIGluXG4gICAgc2VxLnByZXYubmV4dCA8LSBzZXEubmV4dDtcbiAgICBzZXEubmV4dC5wcmV2IDwtIHNlcS5wcmV2XG4gIGVuZFxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IE9wZXJhdGlvbnMgb24gc2VxdWVuY2VzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBjcmVhdGUgKCkgPVxuICBsZXQgcmVjIHNlcSA9IHsgcHJldiA9IHNlcTsgbmV4dCA9IHNlcSB9IGluXG4gIHNlcVxuXG5sZXQgY2xlYXIgc2VxID1cbiAgc2VxLnByZXYgPC0gc2VxO1xuICBzZXEubmV4dCA8LSBzZXFcblxubGV0IGlzX2VtcHR5IHNlcSA9IHNlcS5uZXh0ID09IHNlcVxuXG5sZXQgbGVuZ3RoIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyIGxlbiA9XG4gICAgaWYgY3VyciA9PSBzZXEgdGhlblxuICAgICAgbGVuXG4gICAgZWxzZVxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluIGxvb3Agbm9kZS5ub2RlX25leHQgKGxlbiArIDEpXG4gIGluXG4gIGxvb3Agc2VxLm5leHQgMFxuXG5sZXQgYWRkX2wgZGF0YSBzZXEgPVxuICBsZXQgbm9kZSA9IHsgbm9kZV9wcmV2ID0gc2VxOyBub2RlX25leHQgPSBzZXEubmV4dDsgbm9kZV9kYXRhID0gZGF0YTsgbm9kZV9hY3RpdmUgPSB0cnVlIH0gaW5cbiAgc2VxLm5leHQucHJldiA8LSBzZXFfb2Zfbm9kZSBub2RlO1xuICBzZXEubmV4dCA8LSBzZXFfb2Zfbm9kZSBub2RlO1xuICBub2RlXG5cbmxldCBhZGRfciBkYXRhIHNlcSA9XG4gIGxldCBub2RlID0geyBub2RlX3ByZXYgPSBzZXEucHJldjsgbm9kZV9uZXh0ID0gc2VxOyBub2RlX2RhdGEgPSBkYXRhOyBub2RlX2FjdGl2ZSA9IHRydWUgfSBpblxuICBzZXEucHJldi5uZXh0IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIHNlcS5wcmV2IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIG5vZGVcblxubGV0IHRha2VfbCBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIHJhaXNlIEVtcHR5XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIHNlcS5uZXh0IGluXG4gICAgcmVtb3ZlIG5vZGU7XG4gICAgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0YWtlX3Igc2VxID1cbiAgaWYgaXNfZW1wdHkgc2VxIHRoZW5cbiAgICByYWlzZSBFbXB0eVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBzZXEucHJldiBpblxuICAgIHJlbW92ZSBub2RlO1xuICAgIG5vZGUubm9kZV9kYXRhXG4gIGVuZFxuXG5sZXQgdGFrZV9vcHRfbCBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIE5vbmVcbiAgZWxzZSBiZWdpblxuICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgc2VxLm5leHQgaW5cbiAgICByZW1vdmUgbm9kZTtcbiAgICBTb21lIG5vZGUubm9kZV9kYXRhXG4gIGVuZFxuXG5sZXQgdGFrZV9vcHRfciBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIE5vbmVcbiAgZWxzZSBiZWdpblxuICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgc2VxLnByZXYgaW5cbiAgICByZW1vdmUgbm9kZTtcbiAgICBTb21lIG5vZGUubm9kZV9kYXRhXG4gIGVuZFxuXG5sZXQgdHJhbnNmZXJfbCBzMSBzMiA9XG4gIHMyLm5leHQucHJldiA8LSBzMS5wcmV2O1xuICBzMS5wcmV2Lm5leHQgPC0gczIubmV4dDtcbiAgczIubmV4dCA8LSBzMS5uZXh0O1xuICBzMS5uZXh0LnByZXYgPC0gczI7XG4gIHMxLnByZXYgPC0gczE7XG4gIHMxLm5leHQgPC0gczFcblxubGV0IHRyYW5zZmVyX3IgczEgczIgPVxuICBzMi5wcmV2Lm5leHQgPC0gczEubmV4dDtcbiAgczEubmV4dC5wcmV2IDwtIHMyLnByZXY7XG4gIHMyLnByZXYgPC0gczEucHJldjtcbiAgczEucHJldi5uZXh0IDwtIHMyO1xuICBzMS5wcmV2IDwtIHMxO1xuICBzMS5uZXh0IDwtIHMxXG5cbmxldCBpdGVyX2wgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlLm5vZGVfZGF0YTtcbiAgICAgIGxvb3Agbm9kZS5ub2RlX25leHRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBzZXEubmV4dFxuXG5sZXQgaXRlcl9yIGYgc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgPVxuICAgIGlmIGN1cnIgIT0gc2VxIHRoZW4gYmVnaW5cbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuIGYgbm9kZS5ub2RlX2RhdGE7XG4gICAgICBsb29wIG5vZGUubm9kZV9wcmV2XG4gICAgZW5kXG4gIGluXG4gIGxvb3Agc2VxLnByZXZcblxubGV0IGl0ZXJfbm9kZV9sIGYgc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgPVxuICAgIGlmIGN1cnIgIT0gc2VxIHRoZW4gYmVnaW5cbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuIGYgbm9kZTtcbiAgICAgIGxvb3Agbm9kZS5ub2RlX25leHRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBzZXEubmV4dFxuXG5sZXQgaXRlcl9ub2RlX3IgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlO1xuICAgICAgbG9vcCBub2RlLm5vZGVfcHJldlxuICAgIGVuZFxuICBpblxuICBsb29wIHNlcS5wcmV2XG5cbmxldCBmb2xkX2wgZiBzZXEgYWNjID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgYWNjID1cbiAgICBpZiBjdXJyID09IHNlcSB0aGVuXG4gICAgICBhY2NcbiAgICBlbHNlXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlblxuICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0IChmIG5vZGUubm9kZV9kYXRhIGFjYylcbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dCBhY2NcbiAgaW5cbiAgbG9vcCBzZXEubmV4dCBhY2NcblxubGV0IGZvbGRfciBmIHNlcSBhY2MgPVxuICBsZXQgcmVjIGxvb3AgY3VyciBhY2MgPVxuICAgIGlmIGN1cnIgPT0gc2VxIHRoZW5cbiAgICAgIGFjY1xuICAgIGVsc2VcbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXYgKGYgbm9kZS5ub2RlX2RhdGEgYWNjKVxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9wcmV2IGFjY1xuICBpblxuICBsb29wIHNlcS5wcmV2IGFjY1xuXG5sZXQgZmluZF9ub2RlX2wgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW5cbiAgICAgICAgaWYgZiBub2RlLm5vZGVfZGF0YSB0aGVuXG4gICAgICAgICAgbm9kZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dFxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0XG4gICAgZWxzZVxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIGluXG4gIGxvb3Agc2VxLm5leHRcblxubGV0IGZpbmRfbm9kZV9yIGYgc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgPVxuICAgIGlmIGN1cnIgIT0gc2VxIHRoZW5cbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuXG4gICAgICAgIGlmIGYgbm9kZS5ub2RlX2RhdGEgdGhlblxuICAgICAgICAgIG5vZGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXZcbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCBub2RlLm5vZGVfcHJldlxuICAgIGVsc2VcbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICBpblxuICBsb29wIHNlcS5wcmV2XG5cbmxldCBmaW5kX25vZGVfb3B0X2wgZiBzZXEgPVxuICB0cnkgU29tZSAoZmluZF9ub2RlX2wgZiBzZXEpIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcblxubGV0IGZpbmRfbm9kZV9vcHRfciBmIHNlcSA9XG4gIHRyeSBTb21lIChmaW5kX25vZGVfciBmIHNlcSkgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9Md3QiLCJjc3RfTHd0X3MiLCJjc3Rfc3JjX2NvcmVfbHd0X21sIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF90cmFtcG9saW5lIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfdXBkYXRlX2R1bW15IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJjYW1sX2NhbGw2IiwiYTUiLCJjYW1sX2NhbGw3IiwiYTYiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiTHd0X3NlcXVlbmNlIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYiIsIkNhbWxpbnRlcm5hbExhenkiLCJTdGRsaWJfUmFuZG9tIiwiU3RkbGliX1ByaW50ZiIsIlN0ZGxpYl9RdWV1ZSIsIlN0ZGxpYl9QcmludGV4YyIsIlN0ZGxpYl9NYXAiLCJjb21wYXJlIiwiU3RvcmFnZV9tYXAiLCJzdGF0ZV9vZl9yZXN1bHQiLCJwYXJhbSIsIngiLCJleG4iLCJ1bmRlcmx5aW5nIiwicCIsIm1hdGNoIiwicDIiLCJwMSIsImhhbmRsZV9hbGwiLCJoYW5kbGVfYWxsX2V4Y2VwdF9ydW50aW1lIiwidiIsInNldCIsInJ1biIsImUiLCJuZXh0X2tleV9pZCIsIm5ld19rZXkiLCJpZCIsImN1cnJlbnRfc3RvcmFnZSIsImNzdF9GYXRhbF9lcnJvcl9leGNlcHRpb24iLCJnZXQiLCJrZXkiLCJyZWZyZXNoIiwidmFsdWUiLCJ3aXRoX3ZhbHVlIiwibmV3X3N0b3JhZ2UiLCJzYXZlZF9zdG9yYWdlIiwicmVzdWx0IiwiY29uY2F0X3JlZ3VsYXJfY2FsbGJhY2tzIiwibDEiLCJsMiIsImNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzIiwiY2FsbGJhY2tzIiwiY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsIiwiY2VsbCIsInBzIiwiY2xlYW51cHNfZGVmZXJyZWQiLCJhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGUiLCJub2RlIiwiZXhpc3RpbmciLCJhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWMiLCJhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGIiLCJzZWxmX3JlbW92aW5nX2NhbGxiYWNrX3dyYXBwZXIiLCJhZGRfY2FuY2VsX2NhbGxiYWNrIiwiYXN5bmNfZXhjZXB0aW9uX2hvb2siLCJoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG8iLCJDYW5jZWxlZCIsInJ1bl9jYWxsYmFja3MiLCJpc19jYW5jZWxlZCIsImZzIiwiaXRlcl9jYWxsYmFja19saXN0IiwiY291bnRlciIsInJlc3QiLCJzdG9yYWdlIiwiaXRlcl9saXN0IiwiY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIiwiZGVmZXJyZWRfY2FsbGJhY2tzIiwiZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpIiwiY3N0X3dha2V1cF9yZXN1bHQiLCJjc3Rfd2FrZXVwIiwiY3N0X3dha2V1cF9leG4iLCJjc3Rfd2FrZXVwX2xhdGVyX3Jlc3VsdCIsImNzdF93YWtldXBfbGF0ZXIiLCJjc3Rfd2FrZXVwX2xhdGVyX2V4biIsImxlYXZlX3Jlc29sdXRpb25fbG9vcCIsInN0b3JhZ2Vfc25hcHNob3QiLCJydW5faW5fcmVzb2x1dGlvbl9sb29wIiwiYWJhbmRvbl93YWtldXBzIiwicnVuX2NhbGxiYWNrc19vcl9kZWZlcl90aGVtIiwib3B0Iiwic3RoIiwiYWxsb3dfZGVmZXJyaW5nIiwibWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoIiwic2hvdWxkX2RlZmVyIiwicmVzb2x2ZSIsInJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdCIsImlmX2RlZmVycmVkIiwicnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpIiwiZGVmZXJyZWRfcmVzdWx0IiwiZGVmZXJyZWRfY2FsbGJhY2siLCJpbW1lZGlhdGVfcmVzdWx0IiwiZGVmZXJyZWRfcmVjb3JkIiwid2FrZXVwX2dlbmVyYWwiLCJhcGlfZnVuY3Rpb25fbmFtZSIsInIiLCJ3YWtldXBfcmVzdWx0Iiwid2FrZXVwIiwid2FrZXVwX2V4biIsIndha2V1cF9sYXRlcl9nZW5lcmFsIiwid2FrZXVwX2xhdGVyX3Jlc3VsdCIsIndha2V1cF9sYXRlciIsIndha2V1cF9sYXRlcl9leG4iLCJjYW5jZWwiLCJjYW5jZWxlZF9yZXN1bHQiLCJjYW5jZWxfYW5kX2NvbGxlY3RfY2FsbGJhY2tzIiwiY2FsbGJhY2tzX2FjY3VtdWxhdG9yIiwicmV0dXJuIiwib2ZfcmVzdWx0IiwiZmFpbCIsInJldHVybl91bml0IiwicmV0dXJuX25vbmUiLCJyZXR1cm5fc29tZSIsInJldHVybl9uaWwiLCJyZXR1cm5fdHJ1ZSIsInJldHVybl9mYWxzZSIsInJldHVybl9vayIsInJldHVybl9lcnJvciIsImZhaWxfd2l0aCIsIm1zZyIsImZhaWxfaW52YWxpZF9hcmciLCJuZXdfcGVuZGluZyIsImhvd190b19jYW5jZWwiLCJzdGF0ZSIsIndhaXQiLCJ0YXNrIiwiYWRkX3Rhc2tfciIsInNlcXVlbmNlIiwiYWRkX3Rhc2tfbCIsInByb3RlY3RlZCIsInBfaW50ZXJuYWwiLCJjYWxsYmFjayIsInBfcmVzdWx0IiwicmVtb3ZlX3RoZV9jYWxsYmFjayIsInBfY2FsbGJhY2tzIiwibm9fY2FuY2VsIiwibWFrZV9pbnRvX3Byb3h5Iiwib3V0ZXJfcHJvbWlzZSIsInVzZXJfcHJvdmlkZWRfcHJvbWlzZSIsIm91dGVyX2NhbGxiYWNrcyIsInJlZ3VsYXJfY2FsbGJhY2tzIiwiY2FuY2VsX2NhbGxiYWNrcyIsInN5bWJvbF9iaW5kIiwiY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsIiwiYmFja3RyYWNlX2JpbmQiLCJhZGRfbG9jIiwic3ltYm9sIiwiY2F0Y2giLCJoIiwiYmFja3RyYWNlX2NhdGNoIiwidHJ5X2JpbmQiLCJiYWNrdHJhY2VfdHJ5X2JpbmQiLCJmaW5hbGl6ZSIsImJhY2t0cmFjZV9maW5hbGl6ZSIsIm9uX2NhbmNlbCIsIm9uX3N1Y2Nlc3MiLCJjYWxsYmFja19pZl9kZWZlcnJlZCIsIm9uX2ZhaWx1cmUiLCJvbl90ZXJtaW5hdGlvbiIsIm9uX2FueSIsImciLCJ3cmFwX2luX2NhbmNlbGFibGUiLCJwX3VuZGVybHlpbmciLCJkb250X3dhaXQiLCJhc3luYyIsImlnbm9yZV9yZXN1bHQiLCJqb2luIiwibnVtYmVyX3BlbmRpbmdfaW5fcHMiLCJqb2luX3Jlc3VsdCIsIm5ld19yZXN1bHQiLCJib3RoIiwicGFpciIsInYyIiwidjEiLCJhbGwiLCJ5IiwidnMiLCJpIiwiYWNjIiwiaW5kZXgiLCJjb3VudF9yZXNvbHZlZF9wcm9taXNlc19pbiIsInRvdGFsIiwicmVqZWN0ZWQiLCJudGhfcmVzb2x2ZWQiLCJuIiwibnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluIiwicHJuZyIsImNzdF9Md3RfY2hvb3NlX3dvdWxkX3JldHVybl9hXyIsImNzdF9Md3RfcGlja193b3VsZF9yZXR1cm5fYV9wciIsImNzdF9Md3RfbmNob29zZV93b3VsZF9yZXR1cm5fYSIsImNzdF9Md3RfbnBpY2tfd291bGRfcmV0dXJuX2FfcCIsImNzdF9Md3RfbmNob29zZV9zcGxpdF93b3VsZF9yZSIsImNob29zZSIsInBpY2siLCJxcyIsImNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdCIsInJlc3VsdHMiLCJuY2hvb3NlIiwibnBpY2siLCJuY2hvb3NlX3NwbGl0IiwicGVuZGluZ19hY2MiLCJ0b19yZXNvbHZlIiwiZnVsZmlsbGVkIiwicGVuZGluZyIsImRlYnVnX3N0YXRlX2lzIiwiZXhwZWN0ZWRfc3RhdGUiLCJpc19zbGVlcGluZyIsInBvbGwiLCJhcHBseSIsIndyYXAiLCJ3cmFwMSIsIngxIiwid3JhcDIiLCJ4MiIsIndyYXAzIiwieDMiLCJ3cmFwNCIsIng0Iiwid3JhcDUiLCJ4NSIsIndyYXA2IiwieDYiLCJ3cmFwNyIsIng3IiwicGF1c2VfaG9vayIsInBhdXNlZCIsInBhdXNlIiwid2FrZXVwX3BhdXNlZCIsInRtcCIsInJlZ2lzdGVyX3BhdXNlX25vdGlmaWVyIiwiYWJhbmRvbl9wYXVzZWQiLCJwYXVzZWRfY291bnQiLCJtYXAiLCJ0IiwiYmluZCIsIk9wZW5fb25fcmhzIiwiTGV0X3N5bnRheCIsImxldCIsIlN5bnRheCIsIkx3dCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvZG9nYWRpbm0vLm9wYW0vZWxp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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEN2xHckMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxuKCogUmVhZGluZyBndWlkZVxuXG4gICBXZWxjb21lIHRvIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTHd0IGNvcmUhIFRoaXMgaXMgYSBiaWcgZmlsZSwgYnV0IHdlXG4gICBob3BlIHRoYXQgcmVhZGluZyBpdCAocGFydHMgYXQgYSB0aW1lISkgd2lsbCBub3QgYmUgc2NhcnkgOikgSGVyZSBpcyB3aHk6XG5cblxuICAgKiBTZWN0aW9uaW5nXG5cbiAgIFRoZSBjb2RlIGlzIGJyb2tlbiB1cCBpbnRvIHNlY3Rpb25zLCBlYWNoIG9uZSBvZiB3aGljaCBpcyBhbiBpbnRlcm5hbCBtb2R1bGUuXG4gICBNb3N0IG9mIHRoZSBtb2R1bGVzIGhhdmUgYSBzaWduYXR1cmUsIHdoaWNoIHNlcnZlcyBhcyBhIG5lYXQgdGFibGUgb2ZcbiAgIGNvbnRlbnRzLlxuXG4gICBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSByZWFkIHRoaXMgZmlsZSB3aXRoIGNvZGUgZm9sZGluZyBlbmFibGVkLiBJZiB5b3VcbiAgIGZvbGQgYWxsIHRoZSBtb2R1bGVzLCB5b3UgY2FuIHZpc3VhbGl6ZSB0aGUgbG9naWNhbCBzdHJ1Y3R1cmUgb2YgTHd0IHF1aXRlXG4gICBlYXNpbHkuIFlvdSBjYW4gdGhlbiBleHBhbmQgbW9kdWxlcyBhcyBuZWVkZWQsIGRlcGVuZGluZyBvbiB3aGF0IHBhcnQgb2YgdGhlXG4gICBpbXBsZW1lbnRhdGlvbiB5b3UgYXJlIGludGVyZXN0ZWQgaW4uIFdpdGhvdXQgY29kZSBmb2xkaW5nLCB5b3UgZmFjZSBhblxuICAgaW50aW1pZGF0aW5nIHdhbGwgb2YgY29kZSA6KCBZb3UgY2FuIHN0aWxsIHZpc3VhbGx5IHBhcnNlIHRoZSBmaWxlLCBob3dldmVyLFxuICAgYmVjYXVzZSB0aGVyZSBhcmUgcGxlbnR5IG9mIGJsYW5rIGxpbmVzIHRvIGhlbHAgc2VjdGlvbiB0aGluZ3Mgb2ZmLiBZb3UgY2FuXG4gICBhbHNvIHZpZXcgdGhpcyBmaWxlIGZvbGRlZCBvbmxpbmU6XG5cbiAgICAgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYWFudHJvbi85ZmFiMGJkZWFkOThhNjBmY2NmMDZlMDE4OTE4Njg2M1xuICAgICBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9hYW50cm9uLzk3YjU4NTIwZDViYjQ4NThjY2FjNmY1NDcwMGEyNGQ3XG5cbiAgIFRoZSBzaWduYXR1cmVzIGFyZSB1bnVzdWFsOiBiaWcgY29tbWVudHMgYXJlIGFic2VudC4gVGhleSBhcmUgbW92ZWQgaW50byB0aGVcbiAgIG1vZHVsZXMsIHNvIHRoYXQgdGhleSBhcmUgaGlkZGVuIGJ5IGNvZGUgZm9sZGluZyB3aGVuIHlvdSAodGhlIHJlYWRlciEpIGFyZVxuICAgbm90IGludGVyZXN0ZWQgaW4gdGhvc2UgbW9kdWxlcy5cblxuXG4gICAqIERvY3VtZW50YXRpb25cblxuICAgVGhlIGRvY3VtZW50YXRpb24gYmVnaW5zIHdpdGggYW4gb3ZlcnZpZXcgb2YgbWFqb3IgY29uY2VwdHMgYW5kIGNvbXBvbmVudHMuXG4gICBUaGlzIG92ZXJ2aWV3IHB1dHMgZXZlcnl0aGluZyBpbnRvIGNvbnRleHQuIFlvdSBkb24ndCBoYXZlIHRvIHJlYWQgdGhlIHdob2xlXG4gICB0aGluZy4gVGhlIG92ZXJ2aWV3IGJlZ2lucyB3aXRoIGJhc2ljIGNvbmNlcHRzLCBtb3ZlcyBvbiB0byBhZHZhbmNlZCBvbmVzLFxuICAgYW5kIHRoZW4gZ2V0cyBpbnRvIHRoZSB0cnVseSBlc290ZXJpYy4gWW91IGNhbiByZWFkIGFib3V0IGVhY2ggY29uY2VwdCBvbiBhblxuICAgYXMtbmVlZGVkIGJhc2lzLiBIb3dldmVyLCBvbmNlIHlvdSBoYXZlIHJlYWQgdGhlIHdob2xlIG92ZXJ2aWV3LCB5b3Ugd2lsbCBiZVxuICAgYXdhcmUgb2YgKmV2ZXJ5dGhpbmcqIHRoYXQgaXMgbmVlZGVkIHRvIHVuZGVyc3RhbmQsIGFuZCB3b3JrIHdpdGgsIHRoZSBjb3JlXG4gICBvZiBMd3QuXG5cbiAgIExpdHRlcmVkIGluIHRoZSBjb2RlIGFyZSBhZGRpdGlvbmFsIGNvbW1lbnRzLCB0aGF0IGdvIGluLWRlcHRoIG9uIHZhcmlvdXNcbiAgIGxvY2FsIGltcGxlbWVudGF0aW9uIGRldGFpbHMsIG9wcG9ydHVuaXRpZXMsIHJlZ3JldHMsIGFuZCB0aGUgbGlrZS5cblxuICAgVGhlIHNlY3Rpb25zIChtb2R1bGVzKSBvZiB0aGUgY29kZSBjb3JyZXNwb25kIGNsb3NlbHkgdG8gc2VjdGlvbnMgb2YgdGhlXG4gICBvdmVydmlldy5cblxuXG4gICAqIFdoaXRlc3BhY2VcblxuICAgVGhlIHRvdGFsIGxpbmUgY291bnQgb2YgdGhpcyBmaWxlIG1heSBzZWVtIGZyaWdodGVuaW5nLCBidXQgb25lIHRoaXJkIG9mIGl0XG4gICBpcyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYm90aCB0aGVyZSB0byBoZWxwIHlvdSByZWFkIHRoZSByZW1haW5pbmcgdHdvXG4gICB0aGlyZHMhXG5cbiAgIEFsc28sIHdpdGhpbiB0aG9zZSB0d28gdGhpcmRzLCB0aGVyZSBhcmUgbGFyZ2UgZ3JvdXBzIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZVxuICAgcmVwZXRpdGl2ZSBhbmQgZm9ybXVsYWljLCBzbyB0aGVyZSBpcyBtdWNoIGxlc3MgY29uY2VwdHVhbGx5LXVuaXF1ZSBjb2RlIGluXG4gICBMd3QgdGhhbiB5b3UgbWlnaHQgdGhpbmsgYXQgZmlyc3QuXG5cblxuICAgKiBQbGVhc2UgZWRpdCB0aGUgY29kZSBhbmQgdGhlIGRvY3MhXG5cbiAgIFRoaXMgY29kZSBpcyBtZWFudCB0byBiZSByZWFkYWJsZSwgYW5kIHRvIGJlIGVkaXRlZC4gSWYgeW91IGFyZSByZWFkaW5nXG4gICBzb21ldGhpbmcsIGFuZCB0aGluayB0aGVyZSBpcyBhIGJldHRlciB3YXkgdG8gZXhwcmVzcyBpdCwgcGxlYXNlIGdvIGFoZWFkIGFuZFxuICAgb3BlbiBhIHB1bGwgcmVxdWVzdCB0byB0aGUgTHd0IHJlcG9zaXRvcnkgYXRcblxuICAgICBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3RcblxuICAgRXZlbiBpZiB5b3VyIHB1bGwgcmVxdWVzdCBzb21laG93IGRvZXNuJ3QgZ2V0IG1lcmdlZCwgeW91IHdpbGwgaGF2ZSBlZHVjYXRlZFxuICAgdGhlIG1haW50YWluZXJzLCBub3QgdG8gbWVudGlvbiBvdGhlciBjb250cmlidXRvcnMsIGFuZCB1c2Vycy4gVGhpcyBpcyB0cnVlXG4gICBldmVuIGlmIHRoZSBjaGFuZ2UgaXMgdHJpdmlhbCAtLSBzb21ldGltZXMsIG1haW50YWluZXJzIGp1c3QgbmVlZCB0byBiZVxuICAgZWR1Y2F0ZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIHRoZXkgc2VlIHRoZSB3aXNkb20gb2YgaXQgOi9cblxuICAgTGlrZXdpc2UsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIG1ha2UgYSBjb2RlIGNvbnRyaWJ1dGlvbiB0byB0aGUgTHd0IGNvcmUsIGl0XG4gICBpcyBxdWl0ZSB3ZWxjb21lLCBhbmQgd2UgaG9wZSB0aGF0IHRoaXMgY29kZSBpcyByZWFkYWJsZSBlbm91Z2ggZm9yIHlvdSB0byBiZVxuICAgYWJsZSB0byBtYWtlIGl0IVxuXG5cbiAgIEVuam95ISAqKVxuXG5cblxuKCogT3ZlcnZpZXdcblxuICAgSW4gdGhpcyBmaWxlLCB0aGVyZSBpcyBhIFwibW9kZWxcIiBmdW5jdGlvbiAtLSBbTHd0LmJpbmRdIC0tIHdoaWNoIHB1bGxzXG4gICB0b2dldGhlciBtYW55ICh0aG91Z2ggbm90IGFsbCkgb2YgdGhlIGNvbmNlcHRzIGFuZCBoZWxwZXJzIGRpc2N1c3NlZCBpbiB0aGlzXG4gICBvdmVydmlldy4gVG8gZmluZCBpdCwgc2VhcmNoIGZvciBcImxldCBiaW5kLFwiIGFuZCB5b3UgY2FuIGV4YW1pbmUgaXQgd2hpbGVcbiAgIHJlYWRpbmcgdGhlIG92ZXJ2aWV3LiBUaGUgYXV0aG9ycyBvZiB0aGlzIGZpbGUgaW50ZW5kIHRvIHB1dCBleHRyYSBlZmZvcnRcbiAgIGludG8gd3JpdGluZyBuaWNlIGNvbW1lbnRzIGluc2lkZSBbTHd0LmJpbmRdIDopXG5cblxuICAgMC4gTWFpbiBtZWNoYW5pc20gYW5kIHR3byBhc3BlY3RzXG5cbiAgIFRoZSBMd3QgaW50ZXJmYWNlIChbbHd0Lm1saV0pIHByb3ZpZGVzIG9uZSBtYWluIG1lY2hhbmlzbSwgcHJvbWlzZXMsIGFuZCB0d29cbiAgIFwiYXNwZWN0cyxcIiB3aGljaCBhcmUgKm5vdCogbmVjZXNzYXJ5IHRvIHVuZGVyc3RhbmQgdGhlIG1haW4gbWVjaGFuaXNtXG4gICBwcm9taXNlcywgYnV0IHRoZXkgYXJlIHN0aWxsIHRoZXJlOlxuXG4gICAtIHByb21pc2UgY2FuY2VsbGF0aW9uXG4gICAtIHNlcXVlbmNlLWFzc29jaWF0ZWQgc3RvcmFnZVxuXG4gICBJZiB5b3UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIGNhbmNlbGxhdGlvbiBvciBzdG9yYWdlLCB5b3UgY2FuIGlnbm9yZSB0aGVzZVxuICAgdHdvIGNvbXBsaWNhdGlvbnMsIGFuZCBzdGlsbCBnZXQgYSBwcmV0dHkgZ29vZCB1bmRlcnN0YW5kaW5nIG9mIHRoZSBjb2RlLiBUb1xuICAgaGVscCwgYWxsIGlkZW50aWZpZXJzIHJlbGF0ZWQgdG8gY2FuY2VsbGF0aW9uIGNvbnRhaW4gdGhlIHN0cmluZyBcImNhbmNlbCxcIlxuICAgYW5kIGFsbCBpZGVudGlmaWVycyByZWxhdGVkIHRvIHN0b3JhZ2UgY29udGFpbiBcInN0b3JhZ2UuXCJcblxuXG4gICAxLiBQcm9taXNlc1xuXG4gICBBIHByb21pc2UgaXMgYSBjZWxsIHRoYXQgY2FuIGJlIGluIG9uZSBvZiB0d28gc3RhdGVzOiBcInJlc29sdmVkXCIgb3JcbiAgIFwicGVuZGluZy5cIlxuXG4gICAtIFJlc29sdmVkIHByb21pc2VzXG5cbiAgICAgQSByZXNvbHZlZCBwcm9taXNlIGlzIGVpdGhlciBcImZ1bGZpbGxlZFwiIHdpdGggYSB2YWx1ZSwgb3IgXCJyZWplY3RlZFwiIHdpdGhcbiAgICAgYW4gZXhjZXB0aW9uLiBUaGUgc3RhdGUgb2YgYSByZXNvbHZlZCBwcm9taXNlIHdpbGwgbmV2ZXIgY2hhbmdlIGFnYWluOiBhXG4gICAgIHJlc29sdmVkIHByb21pc2UgaXMgaW1tdXRhYmxlLiBBIHJlc29sdmVkIHByb21pc2UgaXMgYmFzaWNhbGx5IGVxdWl2YWxlbnRcbiAgICAgdG8gYW4gWygnYSwgZXhuKSBTdGRsaWIucmVzdWx0XS4gUmVzb2x2ZWQgcHJvbWlzZXMgYXJlIHByb2R1Y2VkIGluIHR3b1xuICAgICB3YXlzOlxuXG4gICAgIC0gW0x3dC5yZXR1cm5dLCBbTHd0LmZhaWxdLCBhbmQgcmVsYXRlZCBmdW5jdGlvbnMsIHByb2R1Y2UgXCJ0cml2aWFsXCJcbiAgICAgICBwcm9taXNlcyB0aGF0IGFyZSByZXNvbHZlZCBmcm9tIHRoZSBzdGFydC5cbiAgICAgLSBUaGUgb3RoZXIgd2F5IGlzIHRvIHJlc29sdmUgYSBwcm9taXNlIHRoYXQgc3RhcnRlZCBvdXQgcGVuZGluZy5cblxuICAgICBOb3RlIHRoYXQgcmVqZWN0ZWQgcHJvbWlzZXMgaGF2ZSBub3RoaW5nIHRvIGRvIHdpdGggdW5oYW5kbGVkIGV4Y2VwdGlvbnMuXG5cbiAgIC0gUGVuZGluZyBwcm9taXNlc1xuXG4gICAgIC4uLmFyZSB0aG9zZSB0aGF0IG1heSBiZWNvbWUgcmVzb2x2ZWQgaW4gdGhlIGZ1dHVyZS4gRWFjaCBwZW5kaW5nIHByb21pc2VcbiAgICAgY2FycmllcyBhIGxpc3Qgb2YgY2FsbGJhY2tzLiBUaGVzZSBjYWxsYmFja3MgYXJlIGFkZGVkIGJ5IGZ1bmN0aW9ucyBsaWtlXG4gICAgIFtMd3QuYmluZF0sIGFuZCBjYWxsZWQgYnkgTHd0IGlmL3doZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQuIFRoZXNlXG4gICAgIGNhbGxiYWNrcyB0eXBpY2FsbHkgZW5kIHVwIHJlc29sdmluZyBhZGRpdGlvbmFsIHByb21pc2VzOyBzZWUgc2VjdGlvblxuICAgICBcIlJlc29sdXRpb24gbG9vcFwiIGJlbG93LlxuXG4gICAgIFBlbmRpbmcgcHJvbWlzZXMgYXJlIHByb2R1Y2VkIGluIHRocmVlIHdheXMsIGFjY29yZGluZyB0byBob3cgdGhleSBjYW4gYmVcbiAgICAgcmVzb2x2ZWQ6XG5cbiAgICAgLSBJbml0aWFsIHByb21pc2VzXG5cbiAgICAgICAuLi5hcmUgY3JlYXRlZCBieSBbTHd0LndhaXRdIGFuZCBbTHd0LnRhc2tdLiBUaGUgdXNlciBvZiBMd3QgcmVzb2x2ZXNcbiAgICAgICB0aGVzZSBwcm9taXNlcyBtYW51YWxseSwgdGhyb3VnaCB0aGUgcmVzb2x2ZXJzIHJldHVybmVkIGJ5IHRob3NlXG4gICAgICAgZnVuY3Rpb25zLlxuXG4gICAgIC0gU2VxdWVudGlhbCBjb21wb3NpdGlvblxuXG4gICAgICAgRm9yIGV4YW1wbGUsIFtMd3QuYmluZF0uIFRoZXNlIHByb21pc2VzIGFyZSBvbmx5IHJlc29sdmVkIHdoZW4gdGhlXG4gICAgICAgcHJlY2VkaW5nIHNlcXVlbmNlIG9mIHByb21pc2VzIHJlc29sdmVzLiBUaGUgdXNlciBjYW5ub3QgcmVzb2x2ZSB0aGVzZVxuICAgICAgIHByb21pc2VzIGRpcmVjdGx5IChidXQgc2VlIHRoZSBzZWN0aW9uIG9uIGNhbmNlbGxhdGlvbiBiZWxvdykuXG5cbiAgICAgLSBDb25jdXJyZW50IGNvbXBvc2l0aW9uXG5cbiAgICAgICBGb3IgZXhhbXBsZSwgW0x3dC5qb2luXSBvciBbTHd0LmNob29zZV0uIFRoZXNlIHByb21pc2VzIGFyZSBvbmx5IHJlc29sdmVkXG4gICAgICAgd2hlbiBhbGwgb3Igb25lIG9mIGEgc2V0IG9mIFwicHJlY2VkaW5nXCIgcHJvbWlzZXMgcmVzb2x2ZS4gVGhlIHVzZXIgY2Fubm90XG4gICAgICAgcmVzb2x2ZSB0aGVzZSBwcm9taXNlcyBkaXJlY3RseSAoYnV0IHNlZSB0aGUgc2VjdGlvbiBvbiBjYW5jZWxsYXRpb25cbiAgICAgICBiZWxvdykuXG5cblxuICAgMi4gUmVzb2x2ZXJzXG5cbiAgIFJlc29sdmVycyBhcmUgZ2l2ZW4gdG8gdGhlIHVzZXIgYnkgW0x3dC53YWl0XSBhbmQgW0x3dC50YXNrXSwgYW5kIGNhbiBiZSB1c2VkXG4gICBieSB0aGUgdXNlciB0byByZXNvbHZlIHRoZSBjb3JyZXNwb25kaW5nIHByb21pc2VzLiBOb3RlIHRoYXQgdGhpcyBtZWFucyB0aGVcbiAgIHVzZXIgb25seSBldmVyIGdldHMgcmVzb2x2ZXJzIGZvciBpbml0aWFsIHByb21pc2VzLlxuXG4gICBJbnRlcm5hbGx5LCByZXNvbHZlcnMgYXJlIHRoZSBleGFjdCBzYW1lIG9iamVjdHMgYXMgdGhlIHByb21pc2VzIHRoZXlcbiAgIHJlc29sdmUsIGV2ZW4gdGhvdWdoIHRoZSByZXNvbHZlciBpcyBleHBvc2VkIGFzIGEgcmVmZXJlbmNlIG9mIGEgZGlmZmVyZW50XG4gICB0eXBlIGJ5IFtsd3QubWxpXS4gRm9yIGRldGFpbHMgb24gd2h5LCBzZWUgc2VjdGlvbiBcIlR5cGUgc3lzdGVtIGFidXNlXCIgYmVsb3cuXG5cblxuICAgMy4gQ2FsbGJhY2tzXG5cbiAgIC4uLmFyZSBhdHRhY2hlZCBieSBMd3QgdG8gcGVuZGluZyBwcm9taXNlcywgYW5kIGFyZSBydW4gYnkgTHd0IGlmL3doZW4gdGhvc2VcbiAgIHByb21pc2VzIGFyZSByZXNvbHZlZC4gVGhlc2UgY2FsbGJhY2tzIGFyZSBub3QgZGlyZWN0bHkgZXhwb3NlZCB0aHJvdWdoXG4gICBbbHd0Lm1saV0gLS0gdGhleSBhcmUgYSBsb3ctbGV2ZWwgbWVjaGFuaXNtLiBGb3IgZXhhbXBsZSwgdG8gaW1wbGVtZW50XG4gICBbTHd0LmJpbmQgcCBmXSwgTHd0IGF0dGFjaGVzIGEgY2FsbGJhY2sgdG8gW3BdIHRoYXQgZG9lcyBzb21lIGludGVybmFsIEx3dFxuICAgYm9vay1rZWVwaW5nLCBhbmQgdGhlbiBjYWxscyBbZl0gaWYgW3BdIGlzIGZ1bGZpbGxlZCwgYW5kIGRvZXMgc29tZXRoaW5nIGVsc2VcbiAgIGlmIFtwXSBpcyByZWplY3RlZC5cblxuICAgQ2FsbGJhY2tzIGNvbWUgaW4gdHdvIGZsYXZvcnM6IHJlZ3VsYXIgY2FsbGJhY2tzIGFuZCBjYW5jZWwgY2FsbGJhY2tzLiBUaGVcbiAgIG9ubHkgbWF0ZXJpYWwgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGVtIGFyZSB0aGF0OlxuXG4gICAtIHJlZ3VsYXIgY2FsbGJhY2tzIGFyZSBhbHdheXMgY2FsbGVkIHdoZW4gYSBwcm9taXNlIGlzIHJlc29sdmVkLCBidXQgY2FuY2VsXG4gICAgIGNhbGxiYWNrcyBhcmUgY2FsbGVkLCBpbiBhZGRpdGlvbiwgb25seSBpZiB0aGUgcHJvbWlzZSBpcyBjYW5jZWxlZCwgYW5kXG4gICAtIGFsbCBjYW5jZWwgY2FsbGJhY2tzIG9mIGEgcHJvbWlzZSBhcmUgY2FsbGVkIGJlZm9yZSBhbnkgcmVndWxhciBjYWxsYmFja1xuICAgICBpcyBjYWxsZWQuXG5cbiAgIENhbmNlbGxhdGlvbiBpcyBhIHNwZWNpYWwgY2FzZSBvZiByZXNvbHV0aW9uLCBpbiBwYXJ0aWN1bGFyLCBhIHNwZWNpYWwgY2FzZVxuICAgb2YgcmVqZWN0aW9uLCBidXQgc2VlIHRoZSBzZWN0aW9uIG9uIGNhbmNlbGxhdGlvbiBsYXRlciBiZWxvdy5cblxuXG4gICA0LiBSZXNvbHV0aW9uIGxvb3BcblxuICAgUmVzb2x2aW5nIGEgcGVuZGluZyBwcm9taXNlIHRyaWdnZXJzIGl0cyBjYWxsYmFja3MsIGFuZCB0aG9zZSBtaWdodCByZXNvbHZlXG4gICBtb3JlIHBlbmRpbmcgcHJvbWlzZXMsIHRyaWdnZXJpbmcgbW9yZSBjYWxsYmFja3MsIGV0Yy4gVGhpcyBiZWhhdmlvciBpcyB0aGVcbiAgICpyZXNvbHV0aW9uIGxvb3AqLiBMd3QgaGFzIHNvbWUgbWFjaGluZXJ5IHRvIGF2b2lkIHN0YWNrIG92ZXJmbG93IGFuZCBvdGhlclxuICAgdW5mb3J0dW5hdGUgc2l0dWF0aW9ucyBkdXJpbmcgdGhpcyBsb29wLlxuXG4gICBUaGlzIGNoYWluaW5nIG9mIHByb21pc2UgcmVzb2x1dGlvbnMgdGhyb3VnaCBjYWxsYmFja3MgY2FuIGJlIHNlZW4gYXMgYSBraW5kXG4gICBvZiBwcm9taXNlIGRlcGVuZGVuY3kgZ3JhcGgsIGluIHdoaWNoIHRoZSBub2RlcyBhcmUgcGVuZGluZyBwcm9taXNlcywgYW5kIHRoZVxuICAgZWRnZXMgYXJlIGNhbGxiYWNrcy4gRHVyaW5nIHRoZSByZXNvbHV0aW9uIGxvb3AsIEx3dCBzdGFydHMgYXQgc29tZSBpbml0aWFsXG4gICBwcm9taXNlIHRoYXQgaXMgZ2V0dGluZyByZXNvbHZlZCBieSB0aGUgdXNlciwgYW5kIHJlY3Vyc2l2ZWx5IHJlc29sdmVzIGFsbFxuICAgZGVwZW5kZW50IHByb21pc2VzLiBUaGUgZ3JhcGggaXMgbW9kaWZpZWQ6IHJlc29sdmVkIHByb21pc2VzIGFyZSBubyBsb25nZXJcbiAgIHBlbmRpbmcsIHNvIHRoZXkgYXJlIG5vIGxvbmdlciBwYXJ0IG9mIHRoZSBncmFwaC5cblxuICAgU29tZSBvZiB0aGVzZSBkZXBlbmRlbmNpZXMgYXJlIGV4cGxpY2l0IHRvIEx3dCwgZS5nLiB0aGUgY2FsbGJhY2tzIHJlZ2lzdGVyZWRcbiAgIGJ5IFtMd3QuYmluZF0uIE90aGVycyBhcmUgbm90IHZpc2libGUgdG8gTHd0LCBiZWNhdXNlIHRoZSB1c2VyIGNhbiBhbHdheXNcbiAgIHJlZ2lzdGVyIGEgY2FsbGJhY2sgdXNpbmcgYSBmdW5jdGlvbiBsaWtlIFtMd3Qub25fc3VjY2Vzc10sIGFuZCB1c2UgdGhhdFxuICAgY2FsbGJhY2sgdG8gcmVzb2x2ZSBhbm90aGVyIGluaXRpYWwgcHJvbWlzZS4gQWxsIHRoZSBleHBsaWNpdCBkZXBlbmRlbmNpZXNcbiAgIGFyZSBjcmVhdGVkIGJ5IEx3dCdzIG93biBzZXF1ZW50aWFsIGFuZCBjb25jdXJyZW50IGNvbXBvc2l0aW9uIGZ1bmN0aW9uc1xuICAgKHNvLCBbTHd0LmJpbmRdLCBbTHd0LmpvaW5dLCBldGMpLiBXaGV0aGVyIGRlcGVuZGVuY2llcyBhcmUgZXhwbGljaXQgb3Igbm90XG4gICBpcyByZWxldmFudCBvbmx5IHRvIGNhbmNlbGxhdGlvbi5cblxuXG4gICA1LiBDYW5jZWxsYXRpb25cblxuICAgQXMgZGVzY3JpYmVkIGFib3ZlLCBvcmRpbmFyeSBwcm9taXNlIHJlc29sdXRpb24gcHJvY2VlZHMgZnJvbSBhbiBpbml0aWFsXG4gICBwcm9taXNlLCBmb3J3YXJkIGFsb25nIGNhbGxiYWNrcyB0aHJvdWdoIHRoZSBkZXBlbmRlbmN5IGdyYXBoLiBTaW5jZSBpdFxuICAgc3RhcnRzIGZyb20gYW4gaW5pdGlhbCBwcm9taXNlLCBpdCBjYW4gb25seSBiZSB0cmlnZ2VyZWQgdXNpbmcgYSByZXNvbHZlci5cblxuICAgQ2FuY2VsbGF0aW9uIGlzIGEgc29ydCBvZiBkdWFsIHRvIG9yZGluYXJ5IHJlc29sdXRpb24uIEluc3RlYWQgb2Ygc3RhcnRpbmcgYXRcbiAgIGFuIGluaXRpYWwgcHJvbWlzZS9yZXNvbHZlciwgY2FuY2VsbGF0aW9uIHN0YXJ0cyBhdCAqYW55KiBwcm9taXNlLiBJdCB0aGVuXG4gICBnb2VzICpiYWNrd2FyZHMqIHRocm91Z2ggdGhlIGV4cGxpY2l0IGRlcGVuZGVuY3kgZ3JhcGgsIGxvb2tpbmcgZm9yXG4gICBjYW5jZWxhYmxlIGluaXRpYWwgcHJvbWlzZXMgdG8gY2FuY2VsIC0tIHRob3NlIHRoYXQgd2VyZSBjcmVhdGVkIGJ5XG4gICBbTHd0LnRhc2tdLiBBZnRlciBmaW5kaW5nIHRoZW0sIGNhbmNlbGxhdGlvbiByZXNvbHZlcyB0aGVtIG5vcm1hbGx5IHdpdGhcbiAgIFtSZWplY3RlZCBMd3QuQ2FuY2VsZWRdLCBjYXVzaW5nIGFuIG9yZGluYXJ5IHByb21pc2UgcmVzb2x1dGlvbiBwcm9jZXNzLlxuXG4gICBUbyBzdW1tYXJpemUsIGNhbmNlbGxhdGlvbiBpcyBhIHdheSB0byB0cmlnZ2VyIGFuICpvcmRpbmFyeSogcmVzb2x1dGlvbiBvZlxuICAgcHJvbWlzZXMgY3JlYXRlZCB3aXRoIFtMd3QudGFza10sIGJ5IGZpcnN0IHNlYXJjaGluZyBmb3IgdGhlbSBpbiB0aGUgcHJvbWlzZVxuICAgZGVwZW5kZW5jeSBncmFwaCAod2hpY2ggaXMgYXNzZW1ibGVkIGJ5IFtMd3QuYmluZF0sIFtMd3Quam9pbl0sIGV0YykuXG5cbiAgIFRoaXMgYmFja3dhcmRzIHNlYXJjaCBpcyB0cmlnZ2VyZWQgb25seSBieSBbTHd0LmNhbmNlbF0uIEl0IGlzIGFsc28gcG9zc2libGVcbiAgIGZvciB0aGUgdXNlciB0byBjYW5jZWwgYSBwcm9taXNlIGRpcmVjdGx5IGJ5IHJlamVjdGluZyBpdCB3aXRoXG4gICBbTHd0LkNhbmNlbGVkXSwgYnV0IGluIGFsbCBjYXNlcyB3aGVyZSB0aGUgdXNlciBjYW4gZG8gc28sIHRoZSBzZWFyY2ggd291bGRcbiAgIGJlIHJlZHVuZGFudCBhbnl3YXkgLS0gdGhlIHVzZXIgaGFzIG9ubHkgdHdvIHdheXMgb2YgZGlyZWN0bHkgcmVqZWN0aW5nIGFcbiAgIHByb21pc2Ugd2l0aCBbTHd0LkNhbmNlbGVkXSAob3IgYW55IGV4Y2VwdGlvbiwgZm9yIHRoYXQgbWF0dGVyKTpcblxuICAgLSBUaGUgdXNlciBjYW4gY3JlYXRlIGFuIGluaXRpYWwgcHJvbWlzZSwgdGhlbiByZWplY3QgaXQgdGhyb3VnaCBpdHNcbiAgICAgcmVzb2x2ZXIuIFRoZSBzZWFyY2ggaXMgcmVkdW5kYW50IGJlY2F1c2UgaXQgd291bGQgZmluZCBvbmx5IHRoZSBzYW1lXG4gICAgIGluaXRpYWwgcHJvbWlzZSB0byBjYW5jZWwuXG4gICAtIFRoZSB1c2VyIGNhbiBjcmVhdGUgYSB0cml2aWFsIHByb21pc2UgYnkgY2FsbGluZyBbTHd0LmZhaWwgTHd0LkNhbmNlbGVkXS5cbiAgICAgVGhlIHNlYXJjaCBpcyBhZ2FpbiByZWR1bmRhbnQ7IGluIHRoaXMgY2FzZSBpdCB3b3VsZCBmaW5kIG5vdGhpbmcgdG9cbiAgICAgY2FuY2VsLlxuXG4gICBOb3RlIHRoYXQgdGhlcmUgaXMgYSBxdWlyazogb25seSBwcm9taXNlcyBjcmVhdGVkIGJ5IFtMd3QudGFza10gYXJlXG4gICBzdXNjZXB0aWJsZSB0byBiZWluZyBjYW5jZWxlZCBieSBbTHd0LmNhbmNlbF0sIGJ1dCB0aGUgdXNlciBjYW4gbWFudWFsbHlcbiAgIGNhbmNlbCBpbml0aWFsIHByb21pc2VzIGNyZWF0ZWQgYnkgYm90aCBbTHd0LnRhc2tdIGFuZCBbTHd0LndhaXRdLlxuXG4gICBEdWUgdG8gW0x3dC5jYW5jZWxdLCBwcm9taXNlIGNhbmNlbGxhdGlvbiwgYW5kIHRoZXJlZm9yZSByZXNvbHV0aW9uLCBjYW4gYmVcbiAgIGluaXRpYXRlZCBieSB0aGUgdXNlciB3aXRob3V0IGFjY2VzcyB0byBhIHJlc29sdmVyLiBUaGlzIGlzIGltcG9ydGFudCBmb3JcbiAgIHJlYXNvbmluZyBhYm91dCBzdGF0ZSBjaGFuZ2VzIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBMd3QsIGFuZCBpcyByZWZlcmVuY2VkXG4gICBpbiBzb21lIGltcGxlbWVudGF0aW9uIGRldGFpbCBjb21tZW50cy5cblxuXG4gICA2LiBObyBJL09cblxuICAgVGhlIEx3dCBjb3JlIGRlbGliZXJhdGVseSBkb2Vzbid0IGRvIEkvTy4gVGhlIHJlc29sdXRpb24gbG9vcCBzdG9wcyBydW5uaW5nXG4gICBvbmNlIG5vIHByb21pc2VzIGNhbiBiZSByZXNvbHZlZCBpbW1lZGlhdGVseS4gSXQgaGFzIHRvIGJlIHJlc3RhcnRlZCBsYXRlclxuICAgYnkgc29tZSBzdXJyb3VuZGluZyBJL08gbG9vcC4gVGhpcyBJL08gbG9vcCB0eXBpY2FsbHkga2VlcHMgdHJhY2sgb2YgcGVuZGluZ1xuICAgcHJvbWlzZXMgdGhhdCByZXByZXNlbnQgYmxvY2tlZCBvciBpbi1wcm9ncmVzcyBJL087IG90aGVyIHBlbmRpbmcgcHJvbWlzZXNcbiAgIHRoYXQgaW5kaXJlY3RseSBkZXBlbmQgb24gSS9PIGFyZSBub3QgZXhwbGljaXRseSB0cmFja2VkLiBUaGV5IGFyZSByZXRhaW5lZFxuICAgaW4gbWVtb3J5IGJ5IHJlZmVyZW5jZXMgY2FwdHVyZWQgaW5zaWRlIGNhbGxiYWNrcy5cblxuICAgT24gVW5peCBhbmQgV2luZG93cywgYSBzZXBhcmF0ZSB0b3AtbGV2ZWwgbG9vcCwgdHlwaWNhbGx5IFtMd3RfbWFpbi5ydW5dLCBpc1xuICAgbmVjZXNzYXJ5IHRvIHJlcGVhdGVkbHkgY2FsbCBbc2VsZWN0XSwgW2Vwb2xsXSwgb3IgW2tldmVudF0sIGFuZCByZXNvbHZlXG4gICBibG9ja2VkIEkvTyBwcm9taXNlcy5cblxuICAgSW4gSmF2YVNjcmlwdCwgcmVmZXJlbmNlcyB0byBwcm9taXNlcyBhcmUgcmV0YWluZWQgYnkgSmF2YVNjcmlwdCBjb2RlLCB3aGljaFxuICAgaXMsIGluIHR1cm4sIHRyaWdnZXJlZCBieSB0aGUgSlMgZW5naW5lLiBJbiBvdGhlciB3b3JkcywgdGhlIHRvcC1sZXZlbCBsb29wXG4gICBpcyBidXJpZWQgaW5zaWRlIHRoZSBKUyBlbmdpbmUuXG5cbiAgIFRoaXMgc2VwYXJhdGlvbiBvZiB0aGUgTHd0IGNvcmUgZnJvbSB0aGUgdG9wLWxldmVsIEkvTyBsb29wIGtlZXBzIHRoZSBjb3JlXG4gICBwb3J0YWJsZS5cblxuXG4gICA3LiBQcm9taXNlIFwicHJveHlpbmdcIlxuXG4gICBJbiBbTHd0LmJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XSwgdGhlIG91dGVyIFsnYiB0XSBpcyBjcmVhdGVkIGJ5XG4gICBbYmluZF0gZmlyc3QsIGFuZCByZXR1cm5lZCB0byB0aGUgdXNlci4gVGhlIGlubmVyIFsnYiB0XSBpcyBjcmVhdGVkIGJ5IHRoZVxuICAgdXNlciBsYXRlciwgYW5kIHRoZW4gcmV0dXJuZWQgdG8gW2JpbmRdLiBBdCB0aGF0IHBvaW50LCBbYmluZF0gbmVlZHMgdG8gbWFrZVxuICAgdGhlIGlubmVyIGFuZCBvdXRlciBbJ2IgdF1zIGJlaGF2ZSBpZGVudGljYWxseS5cblxuICAgVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgbWFraW5nIG9uZSBvZiB0aGUgcHJvbWlzZXMgcG9pbnQgdG8gdGhlIG90aGVyLiBUaGVcbiAgIGZpcnN0IG9mIHRoZSBwcm9taXNlcyB0aHVzIGJlY29tZXMgYSBcInByb3h5LFwiIGFuZCB0aGUgb3RoZXIgaXMgaXRzXG4gICBcInVuZGVybHlpbmdcIiBwcm9taXNlLlxuXG4gICBBZnRlciB0aGF0LCBhbGwgb3BlcmF0aW9ucyB0aGF0IHdvdWxkIGJlIHBlcmZvcm1lZCBieSBMd3Qgb24gdGhlIHByb3h5IGFyZVxuICAgaW5zdGVhZCBwZXJmb3JtZWQgb24gdGhlIHVuZGVybHlpbmcgcHJvbWlzZS4gVGhpcyBpcyBlbnN1cmVkIGJ5IHRoZSBudW1lcm91c1xuICAgY2FsbHMgdG8gdGhlIGludGVybmFsIGZ1bmN0aW9uIFt1bmRlcmx5aW5nXSBpbiB0aGlzIGZpbGUuXG5cbiAgIEJlY2F1c2Ugb2YgdGhlIHBlcnZhc2l2ZSB1c2Ugb2YgW3VuZGVybHlpbmddLCBwcm94aWVzIGNhbiBiZSBtb3JlIG9yIGxlc3NcbiAgIGlnbm9yZWQgb24gYSBmaXJzdCByZWFkaW5nIHRoZSBjb2RlLiBIb3dldmVyLCBiZWNvbWluZyBhIHByb3h5IGlzIGEga2luZCBvZlxuICAgc3RhdGUgY2hhbmdlLCBhbmQgYW55IHByb21pc2UgdGhhdCBpcyByZXR1cm5lZCBieSBhIGNhbGxiYWNrIHRvIFtiaW5kXSwgb3IgdG9cbiAgIGEgc2ltaWxhciBMd3QgZnVuY3Rpb24sIG1pZ2h0IGJlY29tZSBhIHByb3h5LiBUaGF0IG1lYW5zOiBqdXN0IGFib3V0IGFueVxuICAgcHJvbWlzZSB0aGF0IGlzIGhhbmRlZCB0byB0aGUgdXNlciwgbWlnaHQgYmVjb21lIGEgcHJveHkgcHJvbWlzZSBieSB0aGUgbmV4dFxuICAgdGltZSBMd3Qgc2VlcyBpdC4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIHJlYXNvbmluZyBhYm91dCBwb3NzaWJsZSBzdGF0ZVxuICAgY2hhbmdlcyBpbiBpbXBsZW1lbnRhdGlvbiBvZiBMd3QsIGFuZCBpcyByZWZlcmVuY2VkIGluIHNvbWUgaW1wbGVtZW50YXRpb25cbiAgIGRldGFpbCBjb21tZW50cy5cblxuXG4gICA4LiBTZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2VcblxuICAgTHd0IGhhcyBhIGdsb2JhbCBrZXktdmFsdWUgbWFwLiBUaGUgbWFwIGNhbiBiZSBwcmVzZXJ2ZWQgYWNyb3NzIHNlcXVlbnRpYWxcbiAgIGNvbXBvc2l0aW9uIGZ1bmN0aW9ucywgc28gdGhhdCBpdCBoYXMgdGhlIHNhbWUgc3RhdGUgaW4gdGhlIHVzZXIncyBjYWxsYmFja1xuICAgW2ZdIGFzIGl0IGRpZCBhdCB0aGUgdGltZSB0aGUgdXNlciBjYWxsZWQgW0x3dC5iaW5kIHAgZl0uXG5cbiAgIFRoZSBkZXRhaWxzIGFyZSBwcmV0dHkgc3RyYWlnaHRmb3J3YXJkLCBhbmQgZGlzY3Vzc2VkIGluIG1vZHVsZVxuICAgW1NlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZV0uIFRoZSBtYWluIHRoaW5nIHRvIGJlIGF3YXJlIG9mIGlzIHRoZSBtYW55XG4gICByZWZlcmVuY2VzIHRvIFtjdXJyZW50X3N0b3JhZ2VdIHRocm91Z2hvdXQgTHd0LCB3aGljaCBhcmUgbmVlZGVkIHRvIHByb3Blcmx5XG4gICBzYXZlIGFuZCByZXN0b3JlIHRoZSBtYXBwaW5nLlxuXG5cbiAgIDkuIFR5cGUgc3lzdGVtIGFidXNlXG5cbiAgIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSB0eXBlIHN5c3RlbSBzb21ld2hhdCBleHRlbnNpdmVseS4gR2VudGxlXG4gICBpbnRyb2R1Y3Rpb25zIGNhbiBiZSBmb3VuZCBoZXJlOlxuXG4gICAgIGh0dHBzOi8vZGlzY3Vzcy5vY2FtbC5vcmcvdC8xNjEvN1xuICAgICBodHRwczovL2Rpc2N1c3Mub2NhbWwub3JnL3QvMTYxLzE2XG5cbiAgIEEgc2hvcnQgc3VtbWFyeSBmb2xsb3dzLlxuXG4gICBUaGUgcHJvbWlzZSBzdGF0ZSBpcywgaW50ZXJuYWxseSwgYSBHQURUIHdoaWNoIGVuY29kZXMgdGhlIHN0YXRlIGluIGl0cyB0eXBlXG4gICBwYXJhbWV0ZXJzLiBUaHVzLCBpZiB5b3UgZG8gW2xldCBwID0gdW5kZXJseWluZyBwXSwgdGhlIHNoYWRvd2luZyByZWZlcmVuY2VcbiAgIFtwXSBpcyBzdGF0aWNhbGx5IGtub3duICpub3QqIHRvIGJlIGEgcHJveHksIGFuZCB0aGUgY29tcGlsZXIga25vd3MgdGhhdCB0aGVcbiAgIGNvcnJlc3BvbmRpbmcgbWF0Y2ggY2FzZSBbUHJveHkgX10gaXMgaW1wb3NzaWJsZS5cblxuICAgVGhlIGV4dGVybmFsIHByb21pc2UgdHlwZSwgWydhIHRdLCBhbmQgdGhlIGV4dGVybmFsIHJlc29sdmVyIHR5cGUsIFsnYSB1XSxcbiAgIGFyZSBub3QgR0FEVHMuIEZ1cnRoZXJtb3JlLCB0aGV5IGFyZSwgcmVzcGVjdGl2ZWx5LCBjb3ZhcmlhbnQgYW5kXG4gICBjb250cmF2YXJpYW50IGluIFsnYV0sIHdoaWxlIHRoZSBpbnRlcm5hbCBwcm9taXNlIHR5cGUgaXMgaW52YXJpYW50IGluIFsnYV0uXG4gICBGb3IgdGhlc2UgcmVhc29ucywgdGhlcmUgYXJlIG5hc3R5IGNhc3RzIGJldHdlZW4gWydhIHRdLCBbJ2EgdV0sIGFuZCB0aGVcbiAgIGludGVybmFsIHByb21pc2UgdHlwZS4gVGhlIGltcGxlbWVudGF0aW9uIGlzLCBvZiBjb3Vyc2UsIHdyaXR0ZW4gaW4gdGVybXMgb2ZcbiAgIHRoZSBpbnRlcm5hbCB0eXBlLlxuXG4gICBDYXN0aW5nIGZyb20gYW4gWydhIHRdIHRvIGFuIGludGVybmFsIHByb21pc2UgcHJvZHVjZXMgYSByZWZlcmVuY2UgZm9yXG4gICB3aGljaCB0aGUgc3RhdGUgaXMgXCJ1bmtub3duXCI6IHRoaXMgaXMgc2ltdWxhdGVkIHdpdGggYSBoZWxwZXIgR0FEVCwgd2hpY2hcbiAgIGVuY29kZXMgZXhpc3RlbnRpYWwgdHlwZXMuIFRoZXJlIGFyZSBzZXZlcmFsIHNpbWlsYXIgY2FzdHMsIHdoaWNoIGFyZSB1c2VkXG4gICB0byBkb2N1bWVudCBwb3NzaWJsZSBzdGF0ZSBjaGFuZ2VzIGJldHdlZW4gdGhlIHRpbWUgYSBwcm9taXNlIGlzIGNyZWF0ZWQsXG4gICBhbmQgdGhlIGxhdGVyIHRpbWUgaXQgaXMgdXNlZCBpbiBhIGNhbGxiYWNrLiBZb3UgY2FuIHNlZSB0aGVzZSBjYXN0cyBpblxuICAgYWN0aW9uIGluIFtMd3QuYmluZF0uIFRoZSBjYXN0IHN5bnRheCBpcyBwcmV0dHkgbGlnaHQsIGFuZCwgYmVzaWRlcyBiZWluZ1xuICAgY29tbWVudGVkIGluIFtiaW5kXSwgYWxsIHN1Y2ggY2FzdHMgYXJlIGRvY3VtZW50ZWQgaW4gbW9kdWxlcyBbUHVibGljX3R5cGVzXVxuICAgYW5kIFtCYXNpY19oZWxwZXJzXS5cblxuXG4gICBJZiB5b3UndmUgbWFkZSBpdCB0aGlzIGZhciwgeW91IGFyZSBhbiBMd3QgZXhwZXJ0ISBSZWpvaWNlISAqKVxuXG5cblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcblxuKCogU29tZSBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UgdHlwZXNcblxuICAgU2VxdWVuY2UtYXNzb2NpYXRlZCBzdG9yYWdlIGlzIGRlZmluZWQgYW5kIGRvY3VtZW50ZWQgbGF0ZXIsIGluIG1vZHVsZVxuICAgW1NlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZV0uIEhvd2V2ZXIsIHRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIG1lbnRpb25lZCBpblxuICAgdGhlIGRlZmluaXRpb24gb2YgW3Byb21pc2VdLCBzbyB0aGV5IG11c3QgYmUgZGVmaW5lZCBoZXJlIGZpcnN0LiAqKVxubW9kdWxlIFN0b3JhZ2VfbWFwID1cbiAgTWFwLk1ha2VcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBpbnRcbiAgICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgIGVuZClcbnR5cGUgc3RvcmFnZSA9ICh1bml0IC0+IHVuaXQpIFN0b3JhZ2VfbWFwLnRcblxuXG5cbm1vZHVsZSBNYWluX2ludGVybmFsX3R5cGVzID1cbnN0cnVjdFxuICAoKiBQaGFudG9tIHR5cGVzIGZvciB1c2Ugd2l0aCB0eXBlcyBbcHJvbWlzZV0gYW5kIFtzdGF0ZV0uIFRoZXNlIGFyZSBuZXZlclxuICAgICBjb25zdHJ1Y3RlZDsgdGhlIHB1cnBvc2Ugb2YgdGhlIGNvbnN0cnVjdG9ycyBpcyB0byBwcm92ZSB0byB0aGUgdHlwZVxuICAgICBjaGVja2VyIHRoYXQgdGhlc2UgdHlwZXMgYXJlIGRpc3RpbmN0IGZyb20gZWFjaCBvdGhlci4gV2FybmluZyAzNywgXCJ1bnVzZWRcbiAgICAgY29uc3RydWN0b3IsXCIgdGhlcmVmb3JlIGhhcyB0byBiZSB0ZW1wb3JhcmlseSBzdXBwcmVzc2VkLiAqKVxuXG4gIFtAQEBvY2FtbC53YXJuaW5nIFwiLTM3XCJdXG5cbiAgdHlwZSB1bmRlcmx5aW5nID0gcHJpdmF0ZSBVbmRlcmx5aW5nX2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG4gIHR5cGUgcHJveHkgPSBwcml2YXRlIFByb3h5X2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG5cbiAgdHlwZSByZXNvbHZlZCA9IHByaXZhdGUgUmVzb2x2ZWRfYW5kX3RoaXNfY29uc3RydWN0b3JfaXNfbm90X3VzZWRcbiAgdHlwZSBwZW5kaW5nID0gcHJpdmF0ZSBQZW5kaW5nX2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG5cbiAgW0BAQG9jYW1sLndhcm5pbmcgXCIrMzdcIl1cblxuXG5cbiAgKCogUHJvbWlzZXMgcHJvcGVyLiAqKVxuXG4gIHR5cGUgKCdhLCAndSwgJ2MpIHByb21pc2UgPSB7XG4gICAgbXV0YWJsZSBzdGF0ZSA6ICgnYSwgJ3UsICdjKSBzdGF0ZTtcbiAgfVxuXG4gIGFuZCAoXywgXywgXykgc3RhdGUgPVxuICAgIHwgRnVsZmlsbGVkIDogJ2EgICAgICAgICAgICAgICAgICAtPiAoJ2EsIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZVxuICAgIHwgUmVqZWN0ZWQgIDogZXhuICAgICAgICAgICAgICAgICAtPiAoIF8sIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZVxuICAgIHwgUGVuZGluZyAgIDogJ2EgY2FsbGJhY2tzICAgICAgICAtPiAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpICBzdGF0ZVxuICAgIHwgUHJveHkgICAgIDogKCdhLCBfLCAnYykgcHJvbWlzZSAtPiAoJ2EsIHByb3h5LCAgICAgICdjKSAgICAgICBzdGF0ZVxuXG4gICgqIE5vdGU6XG5cbiAgICAgQSBwcm9taXNlIHdob3NlIHN0YXRlIGlzIFtQcm94eSBfXSBpcyBhIFwicHJveHlcIiBwcm9taXNlLiBBIHByb21pc2Ugd2hvc2VcbiAgICAgc3RhdGUgaXMgKm5vdCogW1Byb3h5IF9dIGlzIGFuIFwidW5kZXJseWluZ1wiIHByb21pc2UuXG5cbiAgICAgVGhlIFwidW5kZXJseWluZyBwcm9taXNlIG9mIFtwXVwiIGlzOlxuXG4gICAgIC0gW3BdLCBpZiBbcF0gaXMgaXRzZWxmIHVuZGVybHlpbmcuXG4gICAgIC0gT3RoZXJ3aXNlLCBbcF0gaXMgYSBwcm94eSBhbmQgaGFzIHN0YXRlIFtQcm94eSBwJ10uIFRoZSB1bmRlcmx5aW5nXG4gICAgICAgcHJvbWlzZSBvZiBbcF0gaXMgdGhlIHVuZGVybHlpbmcgcHJvbWlzZSBvZiBbcCddLlxuXG4gICAgIEluIG90aGVyIHdvcmRzLCB0byBmaW5kIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgYSBwcm94eSwgTHd0IGZvbGxvd3MgdGhlXG4gICAgIFtQcm94eSBfXSBsaW5rcyB0byB0aGUgZW5kLiAqKVxuXG4gICgqIE5vdGU6XG5cbiAgICAgV2hlbiBhIHByb21pc2UgaXMgcmVzb2x2ZWQsIG9yIGJlY29tZXMgYSBwcm94eSwgaXRzIHN0YXRlIGZpZWxkIGlzXG4gICAgIG11dGF0ZWQuIFRoaXMgaW52YWxpZGF0ZXMgdGhlIHR5cGUgaW52YXJpYW50cyBvbiB0aGUgcHJvbWlzZS4gU2VlIGludGVybmFsXG4gICAgIGZ1bmN0aW9uIFtzZXRfcHJvbWlzZV9zdGF0ZV0gZm9yIGRldGFpbHMgYWJvdXQgdGhhdC5cblxuICAgICBXaGVuIGFuIEx3dCBmdW5jdGlvbiBoYXMgYSByZWZlcmVuY2UgdG8gYSBwcm9taXNlLCBhbmQgYWxzbyByZWdpc3RlcnMgYVxuICAgICBjYWxsYmFjayB0aGF0IGhhcyBhIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBwcm9taXNlLCB0aGUgaW52YXJpYW50cyBvbiB0aGVcbiAgICAgcmVmZXJlbmNlIG1heSBiZWNvbWUgaW52YWxpZCBieSB0aGUgdGltZSB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkLiBBbGwgc3VjaFxuICAgICBjYWxsYmFja3MgaGF2ZSBjb21tZW50cyBleHBsYWluaW5nIHdoYXQgdGhlIHZhbGlkIGludmFyaWFudHMgYXJlIGF0IHRoYXRcbiAgICAgcG9pbnQsIGFuZC9vciBjYXN0cyB0byAoMSkgZ2V0IHRoZSBjb3JyZWN0IHR5cGluZyBhbmQgKDIpIGRvY3VtZW50IHRoZVxuICAgICBwb3RlbnRpYWwgc3RhdGUgY2hhbmdlIGZvciByZWFkZXJzIG9mIHRoZSBjb2RlLiAqKVxuXG5cblxuICAoKiBDYWxsYmFjayBpbmZvcm1hdGlvbiBmb3IgcGVuZGluZyBwcm9taXNlcy4gKilcblxuICBhbmQgJ2EgY2FsbGJhY2tzID0ge1xuICAgIG11dGFibGUgcmVndWxhcl9jYWxsYmFja3MgOiAnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3Q7XG4gICAgbXV0YWJsZSBjYW5jZWxfY2FsbGJhY2tzICA6ICdhIGNhbmNlbF9jYWxsYmFja19saXN0O1xuICAgIG11dGFibGUgaG93X3RvX2NhbmNlbCAgICAgOiBob3dfdG9fY2FuY2VsO1xuICAgIG11dGFibGUgY2xlYW51cHNfZGVmZXJyZWQgOiBpbnQ7XG4gIH1cblxuICBhbmQgJ2EgcmVndWxhcl9jYWxsYmFjayA9ICdhIHJlc29sdmVkX3N0YXRlIC0+IHVuaXRcblxuICBhbmQgY2FuY2VsX2NhbGxiYWNrID0gdW5pdCAtPiB1bml0XG5cbiAgYW5kICdhIHJlc29sdmVkX3N0YXRlID0gKCdhLCB1bmRlcmx5aW5nLCByZXNvbHZlZCkgc3RhdGVcblxuICBhbmQgaG93X3RvX2NhbmNlbCA9XG4gICAgfCBOb3RfY2FuY2VsYWJsZSAgICAgICAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvd190b19jYW5jZWxcbiAgICB8IENhbmNlbF90aGlzX3Byb21pc2UgICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgaG93X3RvX2NhbmNlbFxuICAgIHwgUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgICAgIDogKF8sIF8sIF8pIHByb21pc2UgICAgICAtPiBob3dfdG9fY2FuY2VsXG4gICAgfCBQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgOiAoXywgXywgXykgcHJvbWlzZSBsaXN0IC0+IGhvd190b19jYW5jZWxcblxuICBhbmQgJ2EgcmVndWxhcl9jYWxsYmFja19saXN0ID1cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eVxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCBvZlxuICAgICAgJ2EgcmVndWxhcl9jYWxsYmFja19saXN0ICogJ2EgcmVndWxhcl9jYWxsYmFja19saXN0XG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIG9mXG4gICAgICAnYSByZWd1bGFyX2NhbGxiYWNrXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2sgb2ZcbiAgICAgICdhIHJlZ3VsYXJfY2FsbGJhY2sgb3B0aW9uIHJlZlxuXG4gIGFuZCBfIGNhbmNlbF9jYWxsYmFja19saXN0ID1cbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5IDpcbiAgICAgIF8gY2FuY2VsX2NhbGxiYWNrX2xpc3RcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCA6XG4gICAgICAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdCAqICdhIGNhbmNlbF9jYWxsYmFja19saXN0IC0+XG4gICAgICAgICdhIGNhbmNlbF9jYWxsYmFja19saXN0XG4gICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jYWxsYmFjayA6XG4gICAgICBzdG9yYWdlICogY2FuY2VsX2NhbGxiYWNrIC0+XG4gICAgICAgIF8gY2FuY2VsX2NhbGxiYWNrX2xpc3RcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIDpcbiAgICAgICgnYSwgXywgXykgcHJvbWlzZSBMd3Rfc2VxdWVuY2Uubm9kZSAtPlxuICAgICAgICAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdFxuXG4gICgqIE5vdGVzOlxuXG4gICAgIFRoZXNlIHR5cGUgZGVmaW5pdGlvbnMgYXJlIGd1aWx0eSBvZiBwZXJmb3JtaW5nIHNldmVyYWwgb3B0aW1pemF0aW9ucyxcbiAgICAgd2l0aG91dCB3aGljaCB0aGV5IHdvdWxkIGJlIG11Y2ggZWFzaWVyIHRvIHVuZGVyc3RhbmQuXG5cbiAgICAgLSBUaGUgdHlwZSBwYXJhbWV0ZXJzIG9mIFsnYSByZXNvbHZlZF9zdGF0ZV0gZ3VhcmFudGVlIHRoYXQgaXQgaXMgZWl0aGVyXG4gICAgICAgW0Z1bGZpbGxlZCBfXSBvciBbUmVqZWN0ZWQgX10uIFNvLCBpdCBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgWygnYSwgZXhuKSBTdGRsaWIucmVzdWx0XSwgYW5kLCBpbmRlZWQsIHNob3VsZCBoYXZlIGFuIGlkZW50aWNhbFxuICAgICAgIG1lbW9yeSByZXByZXNlbnRhdGlvbi5cblxuICAgICAtIEFzIHBlciB0aGUgT3ZlcnZpZXcsIHRoZXJlIGFyZSByZWd1bGFyIGNhbGxiYWNrcyBhbmQgY2FuY2VsIGNhbGxiYWNrcy5cbiAgICAgICBDYW5jZWwgY2FsbGJhY2tzIGFyZSBjYWxsZWQgb25seSBvbiBjYW5jZWxsYXRpb24sIGFuZCwgdGhlbiwgYmVmb3JlIGFueVxuICAgICAgIHJlZ3VsYXIgY2FsbGJhY2tzIGFyZSBjYWxsZWQuXG5cbiAgICAgICBEZXNwaXRlIHRoZSBkaWZmZXJlbnQgdHlwZXMgZm9yIHRoZSB0d28ga2luZHMgb2YgY2FsbGJhY2tzLCB0aGV5IGFyZVxuICAgICAgIG90aGVyd2lzZSB0aGUgc2FtZS4gQ2FuY2VsIGNhbGxiYWNrcyBqdXN0IGRvbid0IG5lZWQgYSByZXN1bHQgc3RhdGVcbiAgICAgICBhcmd1bWVudCwgYmVjYXVzZSBpdCBpcyBrbm93biB0byBiZSBbUmVqZWN0ZWQgQ2FuY2VsZWRdLlxuXG4gICAgIC0gUmVndWxhciBjYWxsYmFja3MgYXJlIG5vdCBhbGxvd2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMuIEFsbCByZWd1bGFyXG4gICAgICAgY2FsbGJhY2tzIGFyZSBjcmVhdGVkIGluIHRoaXMgZmlsZSwgc28gdGhpcyBjYW4gYmUgY2hlY2tlZC5cblxuICAgICAgIENhbmNlbCBjYWxsYmFja3MgY2FuIHJhaXNlIGV4Y2VwdGlvbnMsIGJ1dCBpZiB0aGV5IGRvIHNvLCB0aGUgZXhjZXB0aW9uc1xuICAgICAgIGFyZSBwYXNzZWQgdG8gW2FzeW5jX2V4Y2VwdGlvbl9ob29rXS5cblxuICAgICAtIFtob3dfdG9fY2FuY2VsXSBpbXBsZW1lbnRzIHRoZSBkZXBlbmRlbmN5IGdyYXBoIG1lbnRpb25lZCBpbiB0aGVcbiAgICAgICBPdmVydmlldy4gSXQgaXMgdHJhdmVyc2VkIGJhY2t3YXJkcyBkdXJpbmcgW0x3dC5jYW5jZWxdLiBJdCBpcyBhIEdBRFRcbiAgICAgICBiZWNhdXNlIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGFjdHVhbCB0eXBlcyBvZiB0aGUgcHJvbWlzZSByZWZlcmVuY2VzXG4gICAgICAgc3RvcmVkLCBvciB0aGVpciBpbnZhcmlhbnRzLiBUaGUgY29uc3RydWN0b3JzIGNvcnJlc3BvbmQgdG8gcGVuZGluZ1xuICAgICAgIHByb21pc2Uga2luZHMgYXMgZm9sbG93czpcbiAgICAgICAgIC0gW05vdF9jYW5jZWxhYmxlXTogaW5pdGlhbCwgW0x3dC53YWl0XS5cbiAgICAgICAgIC0gW0NhbmNlbF90aGlzX3Byb21pc2VdOiBpbml0aWFsLCBbTHd0LnRhc2tdLlxuICAgICAgICAgLSBbUHJvcGFnYXRlX2NhbmNlbF90b19vbmVdOiBzZXF1ZW50aWFsIGNvbXBvc2l0aW9uLCBlLmcuIFtMd3QuYmluZF0uXG4gICAgICAgICAtIFtQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWxdOiBjb25jdXJyZW50IGNvbXBvc2l0aW9uLCBlLmcuXG4gICAgICAgICAgIFtMd3Quam9pbl0uXG5cbiAgICAgLSBUaGUgdHdvIGNhbGxiYWNrIGxpc3QgdHlwZXMgYXJlIG9yZGluYXJ5IGFwcGVuZC1mcmllbmRseSBsaXN0cywgd2l0aCB0d29cbiAgICAgICBvcHRpbWl6YXRpb25zIGlubGluZWQ6XG5cbiAgICAgICAtIFsnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3RdIGFwcGFyZW50bHkgaGFzIHR3byBcImtpbmRzXCIgb2YgcmVndWxhclxuICAgICAgICAgY2FsbGJhY2tzLCBpbXBsaWNpdGx5IHJlbW92ZWQgYW5kIGV4cGxpY2l0bHkgcmVtb3ZhYmxlLiBBbGwgY2FsbGJhY2tzXG4gICAgICAgICBhcmUgcmVtb3ZhYmxlLiBJdCdzIGp1c3QgdGhhdCwgZm9yIHNvbWUgY2FsbGJhY2tzLCB0aGV5IHdpbGwgb25seSBiZVxuICAgICAgICAgcmVtb3ZlZCBhdCB0aGUgc2FtZSB0aW1lIHRoYXQgdGhlIHByb21pc2UgdGhleSBhcmUgYXR0YWNoZWQgdG8gYmVjb21lc1xuICAgICAgICAgcmVzb2x2ZWQuIFdoZW4gdGhhdCBoYXBwZW5zLCB0aGUgZW50aXJlIHN0YXRlIG9mIHRoYXQgcHJvbWlzZSBjaGFuZ2VzXG4gICAgICAgICB0byBbRnVsZmlsbGVkIF9dIG9yIFtSZWplY3RlZCBfXSwgYW5kIHRoZSByZWZlcmVuY2UgdG8gdGhlIHdob2xlXG4gICAgICAgICBjYWxsYmFjayBsaXN0IGlzIHNpbXBseSBsb3N0LiBUaGlzIFwicmVtb3Zlc1wiIHRoZSBjYWxsYmFjay4gRm9yIHRoZXNlXG4gICAgICAgICBjYWxsYmFja3MsIFsnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3RdIGF0dGVtcHRzIHRvIHRyaW0gYW4gb3B0aW9uIGFuZCBhXG4gICAgICAgICByZWZlcmVuY2UgY2VsbCB3aXRoIHRoZVxuICAgICAgICAgW1JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2tdIGNvbnN0cnVjdG9yLlxuXG4gICAgICAgLSBbJ2EgY2FuY2VsX2NhbGxiYWNrX2xpc3RdIGhhc1xuICAgICAgICAgW0NhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGVdLCB3aGljaCBpcyB0aGUgc2FtZSBhc1xuICAgICAgICAgW0NhbmNlbF9jYWxsYmFja19saXN0X2NhbGxiYWNrIChfLCAoZnVuIF8gLT5cbiAgICAgICAgICAgTHd0X3NlcXVlbmNlLnJlbW92ZSBub2RlKSldLlxuICAgICAgICAgVGhpcyB3YXMgcHJvYmFibHkgZG9uZSB0byBhdm9pZCBhIGNsb3N1cmUgYWxsb2NhdGlvbi5cblxuICAgICAtIFRoZSBbY2xlYW51cHNfZGVmZXJyZWRdIGZpZWxkIGlzIGV4cGxhaW5lZCBpbiBtb2R1bGVcbiAgICAgICBbUGVuZGluZ19jYWxsYmFja3NdLiAqKVxuZW5kXG5vcGVuIE1haW5faW50ZXJuYWxfdHlwZXNcblxuXG5cbm1vZHVsZSBQdWJsaWNfdHlwZXMgPVxuc3RydWN0XG4gIHR5cGUgKydhIHRcbiAgdHlwZSAtJ2EgdVxuXG4gIGxldCB0b19wdWJsaWNfcHJvbWlzZSA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAnYSB0ID0gT2JqLm1hZ2ljXG4gIGxldCB0b19wdWJsaWNfcmVzb2x2ZXIgOiAoJ2EsIF8sIF8pIHByb21pc2UgLT4gJ2EgdSA9IE9iai5tYWdpY1xuXG4gIHR5cGUgXyBwYWNrZWRfcHJvbWlzZSA9XG4gICAgfCBJbnRlcm5hbCA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAnYSBwYWNrZWRfcHJvbWlzZVxuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgbGV0IHRvX2ludGVybmFsX3Byb21pc2UgKHAgOiAnYSB0KSA6ICdhIHBhY2tlZF9wcm9taXNlID1cbiAgICBJbnRlcm5hbCAoT2JqLm1hZ2ljIHApXG4gIGxldCB0b19pbnRlcm5hbF9yZXNvbHZlciAociA6ICdhIHUpIDogJ2EgcGFja2VkX3Byb21pc2UgPVxuICAgIEludGVybmFsIChPYmoubWFnaWMgcilcblxuICAoKiBNb3N0IGZ1bmN0aW9ucyB0aGF0IHRha2UgYSBwdWJsaWMgcHJvbWlzZSAoWydhIHRdKSBjb252ZXJ0IGl0IHRvIGFuXG4gICAgIGludGVybmFsIHByb21pc2UgYXMgZm9sbG93czpcblxuICAgICAgICgqIHAgOiAnYSB0ICopXG5cbiAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgICAgKCogcCA6ICgnYSwgdSwgYykgcHJvbWlzZSwgd2hlcmUgdSBhbmQgYyBhcmUgZnJlc2ggdHlwZXMsIGkuZS4gdGhlXG4gICAgICAgICAgaW52YXJpYW50cyBvbiBwIGFyZSB1bmtub3duLiAqKVxuXG4gICAgIFRoaXMgY2FzdCBpcyBhIG5vLW9wIGNhc3QuIEl0IG9ubHkgcHJvZHVjZXMgYSByZWZlcmVuY2Ugd2l0aCBhIGRpZmZlcmVudFxuICAgICB0eXBlLiBUaGUgaW50cm9kdWN0aW9uIGFuZCBpbW1lZGlhdGUgZWxpbWluYXRpb24gb2YgW0ludGVybmFsIF9dIHNlZW1zIHRvXG4gICAgIGJlIG9wdGltaXplZCBhd2F5IGV2ZW4gb24gb2xkZXIgdmVyc2lvbnMgb2YgT0NhbWwgdGhhdCBkb24ndCBoYXZlIEZsYW1iZGFcbiAgICAgYW5kIGRvbid0IHN1cHBvcnQgW1tAQG9jYW1sLnVuYm94ZWRdXS4gKilcblxuICAoKiBUaGlzIGNvdWxkIHByb2JhYmx5IHNhdmUgYW4gYWxsb2NhdGlvbiBieSB1c2luZyBbT2JqLm1hZ2ljXS4gKilcbiAgbGV0IHN0YXRlX29mX3Jlc3VsdCA9IGZ1bmN0aW9uXG4gICAgfCBPayB4IC0+IEZ1bGZpbGxlZCB4XG4gICAgfCBFcnJvciBleG4gLT4gUmVqZWN0ZWQgZXhuXG5lbmRcbmluY2x1ZGUgUHVibGljX3R5cGVzXG5cblxuXG5tb2R1bGUgQmFzaWNfaGVscGVycyA6XG5zaWdcbiAgdmFsIGlkZW50aWNhbCA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAoJ2EsIF8sIF8pIHByb21pc2UgLT4gYm9vbFxuICB2YWwgdW5kZXJseWluZyA6ICgnYSwgJ3UsICdjKSBwcm9taXNlIC0+ICgnYSwgdW5kZXJseWluZywgJ2MpIHByb21pc2VcblxuICB0eXBlICgnYSwgJ3UsICdjKSBzdGF0ZV9jaGFuZ2VkID1cbiAgICB8IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgb2YgKCdhLCAndSwgJ2MpIHByb21pc2VcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuICB2YWwgc2V0X3Byb21pc2Vfc3RhdGUgOlxuICAgICgnYSwgXywgXykgcHJvbWlzZSAtPiAoJ2EsICd1LCAnYykgc3RhdGUgLT4gKCdhLCAndSwgJ2MpIHN0YXRlX2NoYW5nZWRcblxuICB0eXBlICdhIG1heV9ub3dfYmVfcHJveHkgPVxuICAgIHwgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IDpcbiAgICAgICgnYSwgXywgcGVuZGluZykgcHJvbWlzZSAtPiAnYSBtYXlfbm93X2JlX3Byb3h5XG4gICAgW0BAb2NhbWwudW5ib3hlZF1cbiAgdmFsIG1heV9ub3dfYmVfcHJveHkgOlxuICAgICgnYSwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZSAtPiAnYSBtYXlfbm93X2JlX3Byb3h5XG5lbmQgPVxuc3RydWN0XG4gICgqIENoZWNrcyBwaHlzaWNhbCBlcXVhbGl0eSAoWz09XSkgb2YgdHdvIGludGVybmFsIHByb21pc2VzLiBVbmxpa2UgWz09XSwgZG9lc1xuICAgICBub3QgZm9yY2UgdW5pZmljYXRpb24gb2YgdGhlaXIgaW52YXJpYW50cy4gKilcbiAgbGV0IGlkZW50aWNhbCBwMSBwMiA9XG4gICAgKHRvX3B1YmxpY19wcm9taXNlIHAxKSA9PSAodG9fcHVibGljX3Byb21pc2UgcDIpXG5cbiAgKCogW3VuZGVybHlpbmcgcF0gZXZhbHVhdGVzIHRvIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgW3BdLlxuXG4gICAgIElmIG11bHRpcGxlIFtQcm94eSBfXSBsaW5rcyBhcmUgdHJhdmVyc2VkLCBbdW5kZXJseWluZ10gdXBkYXRlcyBhbGwgdGhlXG4gICAgIHByb3hpZXMgdG8gcG9pbnQgaW1tZWRpYXRlbHkgdG8gdGhlaXIgZmluYWwgdW5kZXJseWluZyBwcm9taXNlLiAqKVxuICBsZXQgcmVjIHVuZGVybHlpbmdcbiAgICAgIDogdHlwZSB1IGMuICgnYSwgdSwgYykgcHJvbWlzZSAtPiAoJ2EsIHVuZGVybHlpbmcsIGMpIHByb21pc2UgPVxuICAgIGZ1biBwIC0+XG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+IChwIDogKF8sIHVuZGVybHlpbmcsIF8pIHByb21pc2UpXG4gICAgfCBSZWplY3RlZCBfIC0+IHBcbiAgICB8IFBlbmRpbmcgXyAtPiBwXG4gICAgfCBQcm94eSBwJyAtPlxuICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcgaW5cbiAgICAgIGlmIG5vdCAoaWRlbnRpY2FsIHAnJyBwJykgdGhlblxuICAgICAgICBwLnN0YXRlIDwtIFByb3h5IHAnJztcbiAgICAgIHAnJ1xuXG5cblxuICB0eXBlICgnYSwgJ3UsICdjKSBzdGF0ZV9jaGFuZ2VkID1cbiAgICB8IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgb2YgKCdhLCAndSwgJ2MpIHByb21pc2VcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gIGxldCBzZXRfcHJvbWlzZV9zdGF0ZSBwIHN0YXRlID1cbiAgICBsZXQgcCA6IChfLCBfLCBfKSBwcm9taXNlID0gT2JqLm1hZ2ljIHAgaW5cbiAgICBwLnN0YXRlIDwtIHN0YXRlO1xuICAgIFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcFxuXG4gICgqIFtzZXRfcHJvbWlzZV9zdGF0ZSBwIHN0YXRlXSBtdXRhdGVzIHRoZSBzdGF0ZSBvZiBbcF0sIGFuZCBldmFsdWF0ZXMgdG8gYVxuICAgICAod3JhcHBlZCkgcmVmZXJlbmNlIHRvIFtwXSB3aXRoIHRoZSBzYW1lIGludmFyaWFudHMgYXMgb24gW3N0YXRlXS4gVGhlXG4gICAgIG9yaWdpbmFsIHJlZmVyZW5jZSBbcF0gc2hvdWxkIGJlIHNoYWRvd2VkIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uOlxuXG4gICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9IHNldF9wcm9taXNlX3N0YXRlIHAgKEZ1bGZpbGxlZCA0MikgaW4gLi4uXG5cbiAgICAgVGhpcyBpcyBhIGtpbmQgb2YgY2hlYXAgaW1pdGF0aW9uIG9mIGxpbmVhciB0eXBpbmcsIHdoaWNoIGlzIGdvb2QgZW5vdWdoXG4gICAgIGZvciB0aGUgbmVlZHMgb2YgW2x3dC5tbF0uXG5cbiAgICAgSW50ZXJuYWwgZnVuY3Rpb25zIHRoYXQgdHJhbnNpdGl2ZWx5IGNhbGwgW3NldF9wcm9taXNlX3N0YXRlXSBsaWtld2lzZVxuICAgICByZXR1cm4gdGhlIG5ldyByZWZlcmVuY2UuIFRoaXMgZW5kcyBhdCBzb21lIHRvcC1sZXZlbCBmdW5jdGlvbiwgdHlwaWNhbGx5XG4gICAgIGVpdGhlciBhIGNhbGxiYWNrIG9yIGEgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuIFRoZXJlLCB0aGUgbmV3IHJlZmVyZW5jZVxuICAgICBpcyBzdGlsbCBib3VuZCwgYnV0IGlzIHRoZW4gZXhwbGljaXRseSBpZ25vcmVkLlxuXG4gICAgIFRoZSBzdGF0ZSBvZiBhIHByb21pc2UgaXMgbmV2ZXIgdXBkYXRlZCBkaXJlY3RseSBvdXRzaWRlIHRoaXMgbW9kdWxlXG4gICAgIFtCYXNpY19oZWxwZXJzXS4gQWxsIHVwZGF0ZXMgZWxzZXdoZXJlIGFyZSBkb25lIHRocm91Z2hcbiAgICAgW3NldF9wcm9taXNlX3N0YXRlXS5cblxuICAgICBUbyBhdm9pZCBwcm9ibGVtcyB3aXRoIHR5cGUtbGV2ZWwgaW52YXJpYW50cyBub3QgbWF0Y2hpbmcgcmVhbGl0eSwgZGF0YVxuICAgICBzdHJ1Y3R1cmVzIGRvIG5vdCBzdG9yZSBwcm9taXNlcyB3aXRoIGNvbmNyZXRlIGludmFyaWFudHMgLS0gZXhjZXB0XG4gICAgIHJlc29sdmVkIHByb21pc2VzLCB3aGljaCBhcmUgaW1tdXRhYmxlLiBJbmRlZWQsIGlmIG9uZSBsb29rcyBhdFxuICAgICBkZWZpbml0aW9ucyBvZiBkYXRhIHN0cnVjdHVyZXMgdGhhdCBjYW4gc3RvcmUgcGVuZGluZyBwcm9taXNlcywgZS5nLiB0aGVcbiAgICAgW2hvd190b19jYW5jZWxdIGdyYXBoLCB0aGUgaW52YXJpYW50cyBhcmUgZXhpc3RlbnRpYWxseSBxdWFudGlmaWVkLlxuXG4gICAgIE5vdGU6IGl0J3MgcG9zc2libGUgdG8gc3RhdGljYWxseSBkaXNhbGxvdyB0aGUgc2V0dGluZyBvZiB0aGUgW3N0YXRlXSBmaWVsZFxuICAgICBieSBtYWtpbmcgdHlwZSBbcHJvbWlzZV0gcHJpdmF0ZS4gSG93ZXZlciwgdGhhdCBzZWVtcyB0byByZXF1aXJlIHdyaXRpbmcgYVxuICAgICBzaWduYXR1cmUgdGhhdCBpcyBhIG5lYXItZHVwbGljYXRlIG9mIFtNYWluX2ludGVybmFsX3R5cGVzXSwgb3Igc29tZSBhYnVzZVxuICAgICBvZiBmdW5jdG9ycy4gKilcblxuXG5cbiAgdHlwZSAnYSBtYXlfbm93X2JlX3Byb3h5ID1cbiAgICB8IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSA6XG4gICAgICAoJ2EsIF8sIHBlbmRpbmcpIHByb21pc2UgLT4gJ2EgbWF5X25vd19iZV9wcm94eVxuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgbGV0IG1heV9ub3dfYmVfcHJveHkgcCA9IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwXG5cbiAgKCogTWFueSBmdW5jdGlvbnMsIGZvciBleGFtcGxlIFtMd3QuYmluZF0gYW5kIFtMd3Quam9pbl0sIGNyZWF0ZSBhIGZyZXNoXG4gICAgIHBlbmRpbmcgcHJvbWlzZSBbcF0gYW5kIHJldHVybiBpdCB0byB0aGUgdXNlci5cblxuICAgICBUaGV5IGRvIG5vdCByZXR1cm4gYSBjb3JyZXNwb25kaW5nIHJlc29sdmVyLiBUaGF0IG1lYW5zIHRoYXQgb25seSB0aGVcbiAgICAgZnVuY3Rpb24gaXRzZWxmICh0eXBpY2FsbHksIGEgY2FsbGJhY2sgcmVnaXN0ZXJlZCBieSBpdCkgY2FuIHJlc29sdmUgW3BdLlxuICAgICBUaGUgb25seSB0aGluZyB0aGUgdXNlciBjYW4gZG8gZGlyZWN0bHkgaXMgdHJ5IHRvIGNhbmNlbCBbcF0sIGJ1dCwgc2luY2VcbiAgICAgW3BdIGlzIG5vdCBhbiBpbml0aWFsIHByb21pc2UsIHRoZSBjYW5jZWxsYXRpb24gYXR0ZW1wdCBzaW1wbHkgcHJvcGFnYXRlc1xuICAgICBwYXN0IFtwXSB0byBbcF0ncyBwcmVkZWNlc3NvcnMuIElmIHRoYXQgZXZlbnR1YWxseSByZXN1bHRzIGluIGNhbmNlbGluZ1xuICAgICBbcF0sIGl0IHdpbGwgYmUgdGhyb3VnaCB0aGUgbm9ybWFsIG1lY2hhbmlzbXMgb2YgdGhlIGZ1bmN0aW9uIChlLmcuXG4gICAgIFtMd3QuYmluZF0ncyBjYWxsYmFjaykuXG5cbiAgICAgQXMgYSByZXN1bHQsIHRoZSBvbmx5IHBvc3NpYmxlIHN0YXRlIGNoYW5nZSwgYmVmb3JlIHRoZSBjYWxsYmFjaywgaXMgdGhhdFxuICAgICBbcF0gbWF5IGhhdmUgYmVjb21lIGEgcHJveHkuIE5vdyxcblxuICAgICAtIElmIFtwXSBkb2VzIG5vdCB1bmRlcmdvIHRoaXMgc3RhdGUgY2hhbmdlIGFuZCBiZWNvbWUgYSBwcm94eSwgaXQgcmVtYWluc1xuICAgICAgIGFuIHVuZGVybHlpbmcsIHBlbmRpbmcgcHJvbWlzZS5cbiAgICAgLSBJZiBbcF0gZG9lcyBiZWNvbWUgYSBwcm94eSwgaXQgd2lsbCBiZSBhIHByb3h5IGZvciBhbm90aGVyIHByb21pc2UgW3AnXVxuICAgICAgIGNyZWF0ZWQgZnJlc2ggYnkgW0x3dC5iaW5kXSwgdG8gd2hpY2ggdGhpcyBzYW1lIGFyZ3VtZW50IGFwcGxpZXMuIFNlZVxuICAgICAgIFttYWtlX2ludG9fcHJveHldLlxuXG4gICAgIFNvLCBieSBpbmR1Y3Rpb24gb24gdGhlIGxlbmd0aCBvZiB0aGUgcHJveHkgKFtQcm94eSBfXSkgY2hhaW4sIGF0IHRoZSB0aW1lXG4gICAgIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQsIFtwXSBpcyBlaXRoZXIgYW4gdW5kZXJseWluZywgcGVuZGluZyBwcm9taXNlLCBvciBhXG4gICAgIHByb3h5IGZvciBhIHBlbmRpbmcgcHJvbWlzZS5cblxuICAgICBUaGUgY2FzdFxuXG4gICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluIC4uLlxuXG4gICAgIGVuY29kZXMgdGhlIHBvc3NpYmlsaXR5IG9mIHRoaXMgc3RhdGUgY2hhbmdlLiBJdCByZXBsYWNlcyBhIHJlZmVyZW5jZVxuXG4gICAgICAgcCA6ICgnYSwgdW5kZXJseWluZywgcGVuZGluZylcblxuICAgICB3aXRoXG5cbiAgICAgICBwIDogKCdhLCAkVW5rbm93biwgcGVuZGluZylcblxuICAgICBhbmQgaXMgdHlwaWNhbGx5IHNlZW4gYXQgdGhlIGJlZ2lubmluZyBvZiBjYWxsYmFja3MgcmVnaXN0ZXJlZCBieVxuICAgICBbTHd0LmJpbmRdIGFuZCBzaW1pbGFyIGZ1bmN0aW9ucy5cblxuICAgICBUaGUgY2FzdCBpcyBhIG5vLW9wIGNhc3QuIFRoZSBpbnRyb2R1Y3Rpb24gYW5kIGltbWVkaWF0ZSBlbGltaW5hdGlvbiBvZlxuICAgICBbU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBfXSBzZWVtcyB0byBiZSBvcHRpbWl6ZWQgYXdheSBldmVuIG9uIG9sZCB2ZXJzaW9uc1xuICAgICBvZiBPQ2FtbC4gKilcbmVuZFxub3BlbiBCYXNpY19oZWxwZXJzXG5cbigqIFNtYWxsIGhlbHBlcnMgdG8gYXZvaWQgY2F0Y2hpbmcgb2NhbWwtcnVudGltZSBleGNlcHRpb25zICopXG5tb2R1bGUgRXhjZXB0aW9uX2ZpbHRlciA9IHN0cnVjdFxuICB0eXBlIHQgPSBleG4gLT4gYm9vbFxuICBsZXQgaGFuZGxlX2FsbCA9IGZ1biBfIC0+IHRydWVcbiAgbGV0IGhhbmRsZV9hbGxfZXhjZXB0X3J1bnRpbWUgPSBmdW5jdGlvblxuICAgIHwgT3V0X29mX21lbW9yeSAtPiBmYWxzZVxuICAgIHwgU3RhY2tfb3ZlcmZsb3cgLT4gZmFsc2VcbiAgICB8IF8gLT4gdHJ1ZVxuICBsZXQgdiA9XG4gICAgKCogRGVmYXVsdCB2YWx1ZTogdGhlIGxlZ2FjeSBiZWhhdmlvdXIgdG8gYXZvaWQgYnJlYWtpbmcgcHJvZ3JhbXMgKilcbiAgICByZWYgaGFuZGxlX2FsbFxuICBsZXQgc2V0IGYgPSB2IDo9IGZcbiAgbGV0IHJ1biBlID0gIXYgZVxuZW5kXG5cbm1vZHVsZSBTZXF1ZW5jZV9hc3NvY2lhdGVkX3N0b3JhZ2UgOlxuc2lnXG4gICgqIFB1YmxpYyBpbnRlcmZhY2UgKilcbiAgdHlwZSAndiBrZXlcbiAgdmFsIG5ld19rZXkgOiB1bml0IC0+IF8ga2V5XG4gIHZhbCBnZXQgOiAndiBrZXkgLT4gJ3Ygb3B0aW9uXG4gIHZhbCB3aXRoX3ZhbHVlIDogJ3Yga2V5IC0+ICd2IG9wdGlvbiAtPiAodW5pdCAtPiAnYikgLT4gJ2JcblxuICAoKiBJbnRlcm5hbCBpbnRlcmZhY2UgKilcbiAgdmFsIGN1cnJlbnRfc3RvcmFnZSA6IHN0b3JhZ2UgcmVmXG5lbmQgPVxuc3RydWN0XG4gICgqIFRoZSBpZGVhIGJlaGluZCBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UgaXMgdG8gcHJlc2VydmUgc29tZSB2YWx1ZXNcbiAgICAgZHVyaW5nIGEgY2FsbCB0byBbYmluZF0gb3Igb3RoZXIgc2VxdWVudGlhbCBjb21wb3NpdGlvbiBvcGVyYXRpb24sIGFuZFxuICAgICByZXN0b3JlIHRob3NlIHZhbHVlcyBpbiB0aGUgY2FsbGJhY2sgZnVuY3Rpb246XG5cbiAgICAgICBMd3Qud2l0aF92YWx1ZSBteV9rZXkgKFNvbWUgXCJmb29cIikgKGZ1biAoKSAtPlxuICAgICAgIHAgPnw9IGZ1biAoKSAtPlxuICAgICAgIGFzc2VydCAoTHd0LmdldCBteV9rZXkgPSBTb21lIFwiZm9vXCIpKVxuICAgICAgICAgKCogV2lsbCBzdWNjZWVkIGV2ZW4gaWYgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgbGF0ZXIuICopXG5cbiAgICAgTm90ZSB0aGF0IGl0IGRvZXMgbm90IG1hdHRlciB0aGF0IHRoZSBjYWxsYmFjayBpcyBkZWZpbmVkIHdpdGhpbiBhblxuICAgICBhcmd1bWVudCBvZiBbd2l0aF92YWx1ZV0sIGkuZS4sIHRoaXMgZG9lcyB0aGUgc2FtZTpcblxuICAgICAgIGxldCBmID0gZnVuICgpIC0+IGFzc2VydCAoTHd0LmdldCBteV9rZXkgPSBTb21lIFwiZm9vXCIpIGluXG4gICAgICAgTHd0LndpdGhfdmFsdWUgbXlfa2V5IChTb21lIFwiZm9vXCIpIChmdW4gKCkgLT4gcCA+fD0gZilcblxuICAgICBBbGwgdGhhdCBtYXR0ZXJzIGlzIHRoYXQgdGhlIHRvcC1tb3N0IHNlcXVlbmNpbmcgb3BlcmF0aW9uIChpbiB0aGlzIGNhc2UsXG4gICAgIG1hcCkgaXMgZXhlY3V0ZWQgYnkgdGhhdCBhcmd1bWVudC5cblxuICAgICBUaGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc2luZ2xlIGdsb2JhbCBoZXRlcm9nZW5lb3VzIGtleS12YWx1ZSBtYXAuXG4gICAgIFNlcXVlbnRpYWwgY29tcG9zaXRpb24gZnVuY3Rpb25zIHNuYXBzaG90IHRoaXMgbWFwIHdoZW4gdGhleSBhcmUgY2FsbGVkLFxuICAgICBhbmQgcmVzdG9yZSB0aGUgc25hcHNob3QgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIHVzZXIncyBjYWxsYmFjay4gVGhlIHNhbWVcbiAgICAgaGFwcGVucyBmb3IgY2FuY2VsIHRyaWdnZXJzIGFkZGVkIGJ5IFtvbl9jYW5jZWxdLlxuXG4gICAgIE1haW50YWluZXIncyBub3RlOiBJIHRoaW5rIHVzaW5nIHRoaXMgbWVjaGFuaXNtIHNob3VsZCBiZSBkaXNjb3VyYWdlZCBpblxuICAgICBuZXcgY29kZS4gKilcblxuICB0eXBlICd2IGtleSA9IHtcbiAgICBpZCA6IGludDtcbiAgICBtdXRhYmxlIHZhbHVlIDogJ3Ygb3B0aW9uO1xuICB9XG5cbiAgbGV0IG5leHRfa2V5X2lkID0gcmVmIDBcblxuICBsZXQgbmV3X2tleSAoKSA9XG4gICAgbGV0IGlkID0gIW5leHRfa2V5X2lkIGluXG4gICAgbmV4dF9rZXlfaWQgOj0gaWQgKyAxO1xuICAgIHtpZCA9IGlkOyB2YWx1ZSA9IE5vbmV9XG5cbiAgbGV0IGN1cnJlbnRfc3RvcmFnZSA9IHJlZiBTdG9yYWdlX21hcC5lbXB0eVxuXG4gIGxldCBnZXQga2V5ID1cbiAgICBpZiBTdG9yYWdlX21hcC5tZW0ga2V5LmlkICFjdXJyZW50X3N0b3JhZ2UgdGhlbiBiZWdpblxuICAgICAgbGV0IHJlZnJlc2ggPSBTdG9yYWdlX21hcC5maW5kIGtleS5pZCAhY3VycmVudF9zdG9yYWdlIGluXG4gICAgICByZWZyZXNoICgpO1xuICAgICAgbGV0IHZhbHVlID0ga2V5LnZhbHVlIGluXG4gICAgICBrZXkudmFsdWUgPC0gTm9uZTtcbiAgICAgIHZhbHVlXG4gICAgZW5kXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG4gIGxldCB3aXRoX3ZhbHVlIGtleSB2YWx1ZSBmID1cbiAgICBsZXQgbmV3X3N0b3JhZ2UgPVxuICAgICAgbWF0Y2ggdmFsdWUgd2l0aFxuICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgbGV0IHJlZnJlc2ggPSBmdW4gKCkgLT4ga2V5LnZhbHVlIDwtIHZhbHVlIGluXG4gICAgICAgIFN0b3JhZ2VfbWFwLmFkZCBrZXkuaWQgcmVmcmVzaCAhY3VycmVudF9zdG9yYWdlXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgU3RvcmFnZV9tYXAucmVtb3ZlIGtleS5pZCAhY3VycmVudF9zdG9yYWdlXG4gICAgaW5cblxuICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBuZXdfc3RvcmFnZTtcbiAgICB0cnlcbiAgICAgIGxldCByZXN1bHQgPSBmICgpIGluXG4gICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgIHJlc3VsdFxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgIHJhaXNlIGV4blxuZW5kXG5pbmNsdWRlIFNlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZVxuXG5cblxubW9kdWxlIFBlbmRpbmdfY2FsbGJhY2tzIDpcbnNpZ1xuICAoKiBNdXRhdGluZyBjYWxsYmFjayBsaXN0cyBhdHRhY2hlZCB0byBwZW5kaW5nIHByb21pc2VzICopXG4gIHZhbCBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIDpcbiAgICAnYSBjYWxsYmFja3MgLT4gJ2EgcmVndWxhcl9jYWxsYmFjayAtPiB1bml0XG4gIHZhbCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiA6XG4gICAgJ2EgdCBsaXN0IC0+ICdhIHJlZ3VsYXJfY2FsbGJhY2sgLT4gdW5pdFxuICB2YWwgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX3JlbW92ZV9mdW5jdGlvbiA6XG4gICAgJ2EgdCBsaXN0IC0+ICdhIHJlZ3VsYXJfY2FsbGJhY2sgLT4gY2FuY2VsX2NhbGxiYWNrXG4gIHZhbCBhZGRfY2FuY2VsX2NhbGxiYWNrIDogJ2EgY2FsbGJhY2tzIC0+IGNhbmNlbF9jYWxsYmFjayAtPiB1bml0XG4gIHZhbCBtZXJnZV9jYWxsYmFja3MgOiBmcm9tOidhIGNhbGxiYWNrcyAtPiBpbnRvOidhIGNhbGxiYWNrcyAtPiB1bml0XG5lbmQgPVxuc3RydWN0XG4gIGxldCBjb25jYXRfcmVndWxhcl9jYWxsYmFja3MgbDEgbDIgPVxuICAgIGJlZ2luIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHksIF8gLT4gbDJcbiAgICB8IF8sIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPiBsMVxuICAgIHwgXywgXyAtPiBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChsMSwgbDIpXG4gICAgZW5kXG5cbiAgbGV0IGNvbmNhdF9jYW5jZWxfY2FsbGJhY2tzIGwxIGwyID1cbiAgICBiZWdpbiBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHksIF8gLT4gbDJcbiAgICB8IF8sIENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5IC0+IGwxXG4gICAgfCBfLCBfIC0+IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCAobDEsIGwyKVxuICAgIGVuZFxuXG4gICgqIEluIGEgY2FsbGJhY2sgbGlzdCwgZmlsdGVycyBvdXQgY2VsbHMgb2YgZXhwbGljaXRseSByZW1vdmFibGUgY2FsbGJhY2tzXG4gICAgIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuICopXG4gIGxldCByZWMgY2xlYW5fdXBfY2FsbGJhY2tfY2VsbHMgPSBmdW5jdGlvblxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIHtjb250ZW50cyA9IE5vbmV9IC0+XG4gICAgICBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHlcblxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIHtjb250ZW50cyA9IFNvbWUgX31cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgX1xuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5IGFzIGNhbGxiYWNrcyAtPlxuICAgICAgY2FsbGJhY2tzXG5cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGwxLCBsMikgLT5cbiAgICAgIGxldCBsMSA9IGNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzIGwxIGluXG4gICAgICBsZXQgbDIgPSBjbGVhbl91cF9jYWxsYmFja19jZWxscyBsMiBpblxuICAgICAgY29uY2F0X3JlZ3VsYXJfY2FsbGJhY2tzIGwxIGwyXG5cbiAgKCogU2VlIFtjbGVhcl9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19jZWxsXSBhbmQgW21lcmdlX2NhbGxiYWNrc10uICopXG4gIGxldCBjbGVhbnVwX3Rocm90dGxlID0gNDJcblxuICAoKiBFeHBsaWNpdGx5IHJlbW92YWJsZSBjYWxsYmFja3MgYXJlIGFkZGVkIChtYWlubHkpIGJ5IFtMd3QuY2hvb3NlXSBhbmQgaXRzXG4gICAgIHNpbWlsYXIgZnVuY3Rpb25zLiBJbiBbTHd0LmNob29zZSBbcDsgcCddXSwgaWYgW3AnXSByZXNvbHZlcyBmaXJzdCwgdGhlXG4gICAgIGNhbGxiYWNrIGFkZGVkIGJ5IFtMd3QuY2hvb3NlXSB0byBbcF0gaXMgcmVtb3ZlZC5cblxuICAgICBUaGUgcmVtb3ZhbCBpdHNlbGYgaXMgYWNjb21wbGlzaGVkIHdoZW4gdGhpcyBmdW5jdGlvbiBjbGVhcnMgdGhlIHJlZmVyZW5jZVxuICAgICBjZWxsIFtjZWxsXSwgd2hpY2ggY29udGFpbnMgdGhlIHJlZmVyZW5jZSB0byB0aGF0IGNhbGxiYWNrLlxuXG4gICAgIElmIFtwXSBpcyBhIGxvbmctcGVuZGluZyBwcm9taXNlIHRoYXQgcmVwZWF0ZWRseSBwYXJ0aWNpcGF0ZXMgaW5cbiAgICAgW0x3dC5jaG9vc2VdLCBwZXJoYXBzIGluIGEgbG9vcCwgaXQgd2lsbCBhY2N1bXVsYXRlIGEgbGFyZ2UgbnVtYmVyIG9mXG4gICAgIGNsZWFyZWQgcmVmZXJlbmNlIGNlbGxzIGluIHRoaXMgZmFzaGlvbi4gVG8gYXZvaWQgYSBtZW1vcnkgbGVhaywgdGhleSBtdXN0XG4gICAgIGJlIGNsZWFuZWQgdXAuIEhvd2V2ZXIsIHRoZSBjZWxscyBhcmUgbm90IGNsZWFuZWQgdXAgb24gKmV2ZXJ5KiByZW1vdmFsLFxuICAgICBwcmVzdW1hYmx5IGJlY2F1c2Ugc2Nhbm5pbmcgdGhlIGNhbGxiYWNrIGxpc3QgdGhhdCBvZnRlbiwgYW5kIHJlYnVpbGRpbmdcbiAgICAgaXQsIGNhbiBnZXQgZXhwZW5zaXZlLlxuXG4gICAgIENsZWFudXAgaXMgdGhyb3R0bGVkIGJ5IG1haW50YWluaW5nIGEgY291bnRlciwgW2NsZWFudXBzX2RlZmVycmVkXSwgb24gZWFjaFxuICAgICBwZW5kaW5nIHByb21pc2UuIFRoZSBjb3VudGVyIGlzIGluY3JlbWVudGVkIGVhY2ggdGltZSB0aGlzIGZ1bmN0aW9uIHdhbnRzXG4gICAgIHRvIGNsZWFuIHRoZSBjYWxsYmFjayBsaXN0IChyaWdodCBhZnRlciBjbGVhcmluZyBhIGNlbGwpLiBXaGVuIHRoZSBjb3VudGVyXG4gICAgIHJlYWNoZXMgW2NsZWFudXBfdGhyb3R0bGVdLCB0aGUgY2FsbGJhY2sgbGlzdCBpcyBhY3R1YWxseSBzY2FubmVkIGFuZFxuICAgICBjbGVhcmVkIGNhbGxiYWNrIGNlbGxzIGFyZSByZW1vdmVkLiAqKVxuICBsZXQgY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbCBjZWxsIH5vcmlnaW5hbGx5X2FkZGVkX3RvOnBzID1cbiAgICBjZWxsIDo9IE5vbmU7XG5cbiAgICAoKiBHbyB0aHJvdWdoIHRoZSBwcm9taXNlcyB0aGUgY2VsbCBoYWQgb3JpZ2luYWxseSBiZWVuIGFkZGVkIHRvLCBhbmQgZWl0aGVyXG4gICAgICAgZGVmZXIgYSBjbGVhbnVwLCBvciBhY3R1YWxseSBjbGVhbiB1cCB0aGVpciBjYWxsYmFjayBsaXN0cy4gKilcbiAgICBwcyB8PiBMaXN0Lml0ZXIgKGZ1biBwIC0+XG4gICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgKCogU29tZSBvZiB0aGUgcHJvbWlzZXMgbWF5IGFscmVhZHkgaGF2ZSBiZWVuIHJlc29sdmVkIGF0IHRoZSB0aW1lIHRoaXNcbiAgICAgICAgIGZ1bmN0aW9uIGlzIGNhbGxlZC4gKilcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT4gKClcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPiAoKVxuXG4gICAgICB8IFBlbmRpbmcgY2FsbGJhY2tzIC0+XG4gICAgICAgIG1hdGNoIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyB3aXRoXG4gICAgICAgICgqIElmIHRoZSBwcm9taXNlIGhhcyBvbmx5IG9uZSByZWd1bGFyIGNhbGxiYWNrLCBhbmQgaXQgaXMgcmVtb3ZhYmxlLCBpdFxuICAgICAgICAgICBtdXN0IGhhdmUgYmVlbiB0aGUgY2VsbCBjbGVhcmVkIGluIHRoaXMgZnVuY3Rpb24sIGFib3ZlLiBJbiB0aGF0XG4gICAgICAgICAgIGNhc2UsIGp1c3Qgc2V0IGl0cyBjYWxsYmFjayBsaXN0IHRvIGVtcHR5LiAqKVxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayBfIC0+XG4gICAgICAgICAgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzIDwtIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eVxuXG4gICAgICAgICgqIE1haW50YWluZXIncyBub3RlOiBJIHRoaW5rIHRoaXMgZnVuY3Rpb24gc2hvdWxkbid0IHRyeSB0byB0cmlnZ2VyIGFcbiAgICAgICAgICAgY2xlYW51cCBpbiB0aGUgZmlyc3QgdHdvIGNhc2VzLCBidXQgSSBhbSBwcmVzZXJ2aW5nIHRoZW0gZm9yIG5vdywgYXNcbiAgICAgICAgICAgdGhpcyBpcyBob3cgdGhlIGNvZGUgd2FzIHdyaXR0ZW4gaW4gdGhlIHBhc3QuICopXG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBfXG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCBfIC0+XG4gICAgICAgICAgbGV0IGNsZWFudXBzX2RlZmVycmVkID0gY2FsbGJhY2tzLmNsZWFudXBzX2RlZmVycmVkICsgMSBpblxuICAgICAgICAgIGlmIGNsZWFudXBzX2RlZmVycmVkID4gY2xlYW51cF90aHJvdHRsZSB0aGVuIGJlZ2luXG4gICAgICAgICAgICBjYWxsYmFja3MuY2xlYW51cHNfZGVmZXJyZWQgPC0gMDtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyA8LVxuICAgICAgICAgICAgICBjbGVhbl91cF9jYWxsYmFja19jZWxscyBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3NcbiAgICAgICAgICBlbmQgZWxzZVxuICAgICAgICAgICAgY2FsbGJhY2tzLmNsZWFudXBzX2RlZmVycmVkIDwtIGNsZWFudXBzX2RlZmVycmVkKVxuXG4gICgqIENvbmNhdGVuYXRlcyBib3RoIGtpbmRzIG9mIGNhbGxiYWNrcyBvbiBbfmZyb21dIHRvIHRoZSBjb3JyZXNwb25kaW5nIGxpc3RzXG4gICAgIG9mIFt+aW50b10uIFRoZSBjYWxsYmFjayBsaXN0cyBvbiBbfmZyb21dIGFyZSAqbm90KiB0aGVuIGNsZWFyZWQsIGJlY2F1c2VcbiAgICAgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBieSBbU2VxdWVudGlhbF9jb21wb3NpdGlvbi5tYWtlX2ludG9fcHJveHldLFxuICAgICB3aGljaCBpbW1lZGlhdGVseSBjaGFuZ2VzIHRoZSBzdGF0ZSBvZiBbfmZyb21dIGFuZCBsb3NlcyByZWZlcmVuY2VzIHRvIHRoZVxuICAgICBvcmlnaW5hbCBjYWxsYmFjayBsaXN0cy5cblxuICAgICBUaGUgW2NsZWFudXBzX2RlZmVycmVkXSBmaWVsZHMgb2YgYm90aCBwcm9taXNlcyBhcmUgc3VtbWVkLCBhbmQgaWYgdGhlIHN1bVxuICAgICBleGNlZWRzIFtjbGVhbnVwX3Rocm90dGxlXSwgYSBjbGVhbnVwIG9mIHJlZ3VsYXIgY2FsbGJhY2tzIGlzIHRyaWdnZXJlZC5cbiAgICAgVGhpcyBpcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrczsgc2VlXG4gICAgIFtjbGVhcl9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19jZWxsXS4gKilcbiAgbGV0IG1lcmdlX2NhbGxiYWNrcyB+ZnJvbSB+aW50byA9XG4gICAgbGV0IHJlZ3VsYXJfY2FsbGJhY2tzID1cbiAgICAgIGNvbmNhdF9yZWd1bGFyX2NhbGxiYWNrcyBpbnRvLnJlZ3VsYXJfY2FsbGJhY2tzIGZyb20ucmVndWxhcl9jYWxsYmFja3MgaW5cbiAgICBsZXQgY2xlYW51cHNfZGVmZXJyZWQgPSBpbnRvLmNsZWFudXBzX2RlZmVycmVkICsgZnJvbS5jbGVhbnVwc19kZWZlcnJlZCBpblxuXG4gICAgbGV0IHJlZ3VsYXJfY2FsbGJhY2tzLCBjbGVhbnVwc19kZWZlcnJlZCA9XG4gICAgICBpZiBjbGVhbnVwc19kZWZlcnJlZCA+IGNsZWFudXBfdGhyb3R0bGUgdGhlblxuICAgICAgICBjbGVhbl91cF9jYWxsYmFja19jZWxscyByZWd1bGFyX2NhbGxiYWNrcywgMFxuICAgICAgZWxzZVxuICAgICAgICByZWd1bGFyX2NhbGxiYWNrcywgY2xlYW51cHNfZGVmZXJyZWRcbiAgICBpblxuXG4gICAgbGV0IGNhbmNlbF9jYWxsYmFja3MgPVxuICAgICAgY29uY2F0X2NhbmNlbF9jYWxsYmFja3MgaW50by5jYW5jZWxfY2FsbGJhY2tzIGZyb20uY2FuY2VsX2NhbGxiYWNrcyBpblxuXG4gICAgaW50by5yZWd1bGFyX2NhbGxiYWNrcyA8LSByZWd1bGFyX2NhbGxiYWNrcztcbiAgICBpbnRvLmNhbmNlbF9jYWxsYmFja3MgPC0gY2FuY2VsX2NhbGxiYWNrcztcbiAgICBpbnRvLmNsZWFudXBzX2RlZmVycmVkIDwtIGNsZWFudXBzX2RlZmVycmVkXG5cblxuXG4gICgqIEdlbmVyYWwsIGludGVybmFsLCBmdW5jdGlvbiBmb3IgYWRkaW5nIGEgcmVndWxhciBjYWxsYmFjay4gKilcbiAgbGV0IGFkZF9yZWd1bGFyX2NhbGxiYWNrX2xpc3Rfbm9kZSBjYWxsYmFja3Mgbm9kZSA9XG4gICAgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzIDwtXG4gICAgICBtYXRjaCBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3Mgd2l0aFxuICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT5cbiAgICAgICAgbm9kZVxuICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIF9cbiAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIF9cbiAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCBfIGFzIGV4aXN0aW5nIC0+XG4gICAgICAgIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgKG5vZGUsIGV4aXN0aW5nKVxuXG4gIGxldCBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIGNhbGxiYWNrcyBmID1cbiAgICBhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGVcbiAgICAgIGNhbGxiYWNrcyAoUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBmKVxuXG4gICgqIEFkZHMgW2NhbGxiYWNrXSBhcyByZW1vdmFibGUgdG8gZWFjaCBwcm9taXNlIGluIFtwc10uIFRoZSBmaXJzdCBwcm9taXNlIGluXG4gICAgIFtwc10gdG8gdHJpZ2dlciBbY2FsbGJhY2tdIHJlbW92ZXMgW2NhbGxiYWNrXSBmcm9tIHRoZSBvdGhlciBwcm9taXNlczsgdGhpc1xuICAgICBndWFyYW50ZWVzIHRoYXQgW2NhbGxiYWNrXSBpcyBjYWxsZWQgYXQgbW9zdCBvbmNlLiBBbGwgdGhlIHByb21pc2VzIGluIFtwc11cbiAgICAgbXVzdCBiZSBwZW5kaW5nLlxuXG4gICAgIFRoaXMgaXMgYW4gaW50ZXJuYWwgZnVuY3Rpb24sIGluZGlyZWN0bHkgdXNlZCBieSB0aGUgaW1wbGVtZW50YXRpb25zIG9mXG4gICAgIFtMd3QuY2hvb3NlXSBhbmQgcmVsYXRlZCBmdW5jdGlvbnMuICopXG4gIGxldCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfY2VsbCBwcyBmID1cbiAgICBsZXQgcmVjIGNlbGwgPSByZWYgKFNvbWUgc2VsZl9yZW1vdmluZ19jYWxsYmFja193cmFwcGVyKVxuICAgIGFuZCBzZWxmX3JlbW92aW5nX2NhbGxiYWNrX3dyYXBwZXIgcmVzdWx0ID1cbiAgICAgIGNsZWFyX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2NlbGwgY2VsbCB+b3JpZ2luYWxseV9hZGRlZF90bzpwcztcbiAgICAgIGYgcmVzdWx0XG4gICAgaW5cblxuICAgIGxldCBub2RlID0gUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIGNlbGwgaW5cbiAgICBwcyB8PiBMaXN0Lml0ZXIgKGZ1biBwIC0+XG4gICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgfCBQZW5kaW5nIGNhbGxiYWNrcyAtPiBhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGUgY2FsbGJhY2tzIG5vZGVcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IFJlamVjdGVkIF8gLT4gYXNzZXJ0IGZhbHNlKTtcblxuICAgIGNlbGxcblxuICBsZXQgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgZiA9XG4gICAgaWdub3JlIChhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfY2VsbCBwcyBmKVxuXG4gICgqIFRoaXMgaXMgYmFzaWNhbGx5IGp1c3QgdG8gc3VwcG9ydCBbTHd0LnByb3RlY3RlZF0sIHdoaWNoIG5lZWRzIHRvIHJlbW92ZVxuICAgICB0aGUgY2FsbGJhY2sgaW4gY2lyY3Vtc3RhbmNlcyBvdGhlciB0aGFuIHRoZSBjYWxsYmFjayBiZWluZyBjYWxsZWQuICopXG4gIGxldCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfcmVtb3ZlX2Z1bmN0aW9uIHBzIGYgPVxuICAgIGxldCBjZWxsID0gYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX2NlbGwgcHMgZiBpblxuICAgIGZ1biAoKSAtPlxuICAgICAgY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbCBjZWxsIH5vcmlnaW5hbGx5X2FkZGVkX3RvOnBzXG5cbiAgbGV0IGFkZF9jYW5jZWxfY2FsbGJhY2sgY2FsbGJhY2tzIGYgPVxuICAgIGxldCBub2RlID0gQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgKCFjdXJyZW50X3N0b3JhZ2UsIGYpIGluXG5cbiAgICBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcyA8LVxuICAgICAgbWF0Y2ggY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3Mgd2l0aFxuICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPlxuICAgICAgICBub2RlXG5cbiAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgX1xuICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSBfXG4gICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCBfIC0+XG4gICAgICAgIENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCAobm9kZSwgY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3MpXG5lbmRcbm9wZW4gUGVuZGluZ19jYWxsYmFja3NcblxuXG5cbm1vZHVsZSBSZXNvbHV0aW9uX2xvb3AgOlxuc2lnXG4gICgqIEFsbCB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrcyBhcmUgY2FsbGVkIGJ5IEx3dCBvbmx5IHRocm91Z2ggdGhpcyBtb2R1bGUuIEl0XG4gICAgIHRyYWNrcyB0aGUgY3VycmVudCBjYWxsYmFjayBzdGFjayBkZXB0aCwgYW5kIGRlY2lkZXMgd2hldGhlciBlYWNoIGNhbGxiYWNrXG4gICAgIGNhbGwgc2hvdWxkIGJlIGRlZmVycmVkIG9yIG5vdC4gKilcblxuICAoKiBJbnRlcm5hbCBpbnRlcmZhY2UgdXNlZCBvbmx5IGluIHRoaXMgbW9kdWxlIEx3dCAqKVxuICB2YWwgcmVzb2x2ZSA6XG4gICAgP2FsbG93X2RlZmVycmluZzpib29sIC0+XG4gICAgP21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aDppbnQgLT5cbiAgICAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpIHByb21pc2UgLT5cbiAgICAnYSByZXNvbHZlZF9zdGF0ZSAtPlxuICAgICAgKCdhLCB1bmRlcmx5aW5nLCByZXNvbHZlZCkgc3RhdGVfY2hhbmdlZFxuXG4gIHZhbCBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW0gOlxuICAgID9hbGxvd19kZWZlcnJpbmc6Ym9vbCAtPlxuICAgID9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGg6aW50IC0+XG4gICAgKCdhIGNhbGxiYWNrcykgLT5cbiAgICAnYSByZXNvbHZlZF9zdGF0ZSAtPlxuICAgICAgdW5pdFxuXG4gIHZhbCBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXQgOlxuICAgID9ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6Ym9vbCAtPlxuICAgIGNhbGxiYWNrOih1bml0IC0+ICdhKSAtPlxuICAgIGlmX2RlZmVycmVkOih1bml0IC0+ICdhICogJ2IgcmVndWxhcl9jYWxsYmFjayAqICdiIHJlc29sdmVkX3N0YXRlKSAtPlxuICAgICAgJ2FcblxuICB2YWwgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdFxuXG4gICgqIEludGVybmFsIGludGVyZmFjZSBleHBvc2VkIHRvIG90aGVyIG1vZHVsZXMgaW4gTHd0ICopXG4gIHZhbCBhYmFuZG9uX3dha2V1cHMgOiB1bml0IC0+IHVuaXRcblxuICAoKiBQdWJsaWMgaW50ZXJmYWNlICopXG4gIGV4Y2VwdGlvbiBDYW5jZWxlZFxuXG4gIHZhbCBhc3luY19leGNlcHRpb25faG9vayA6IChleG4gLT4gdW5pdCkgcmVmXG5lbmQgPVxuc3RydWN0XG4gICgqIFdoZW4gTHd0IG5lZWRzIHRvIGNhbGwgYSBjYWxsYmFjaywgaXQgZW50ZXJzIHRoZSByZXNvbHV0aW9uIGxvb3AuIFRoaXNcbiAgICAgdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiBMd3Qgc2V0cyB0aGUgc3RhdGUgb2Ygb25lIHByb21pc2UgdG8gW0Z1bGZpbGxlZCBfXVxuICAgICBvciBbUmVqZWN0ZWQgX10uIFRoZSBjYWxsYmFja3MgdGhhdCB3ZXJlIGF0dGFjaGVkIHRvIHRoZSBwcm9taXNlIHdoZW4gaXRcbiAgICAgd2FzIHBlbmRpbmcgbXVzdCB0aGVuIGJlIGNhbGxlZC5cblxuICAgICBUaGlzIGFsc28gaGFwcGVucyBpbiBhIGZldyBvdGhlciBzaXR1YXRpb25zLiBGb3IgZXhhbXBsZSwgd2hlbiBbTHd0LmJpbmRdXG4gICAgIGlzIGNhbGxlZCBvbiBhIHByb21pc2UsIGJ1dCB0aGF0IHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCwgdGhlIGNhbGxiYWNrXG4gICAgIHBhc3NlZCB0byBbYmluZF0gbXVzdCBiZSBjYWxsZWQuXG5cbiAgICAgVGhlIGNhbGxiYWNrcyB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZXNvbHV0aW9uIGxvb3AgbWlnaHQgcmVzb2x2ZSBtb3JlXG4gICAgIHByb21pc2VzLCB0cmlnZ2VyaW5nIG1vcmUgY2FsbGJhY2tzLCBhbmQgc28gb24uIFRoaXMgaXMgd2hhdCBtYWtlcyB0aGVcbiAgICAgcmVzb2x1dGlvbiBsb29wIGEge2UgbG9vcH0uXG5cbiAgICAgTHd0IGdlbmVyYWxseSB0cmllcyB0byBjYWxsIGVhY2ggY2FsbGJhY2sgaW1tZWRpYXRlbHkuIEhvd2V2ZXIsIHRoaXMgY2FuXG4gICAgIGxlYWQgdG8gYSBwcm9ncmVzc2l2ZSBkZWVwZW5pbmcgb2YgdGhlIGNhbGwgc3RhY2ssIHVudGlsIHRoZXJlIGlzIGEgc3RhY2tcbiAgICAgb3ZlcmZsb3cuIFRoaXMgY2FuJ3QgYmUgYXZvaWRlZCBieSBkb2luZyB0YWlsIGNhbGxzLCBiZWNhdXNlIEx3dCBhbHdheXNcbiAgICAgbmVlZHMgdG8gZG8gZXhjZXB0aW9uIGhhbmRsaW5nIGFyb3VuZCBjYWxsYmFja3MgY2FsbHM6IGVhY2ggY2FsbGJhY2sgY2FsbFxuICAgICBpcyBmb2xsb3dlZCBieSBhbiBleGNlcHRpb24gaGFuZGxlci4gSW5zdGVhZCwgd2hhdCBMd3QgZG9lcyBpcyB0cmFjayB0aGVcbiAgICAgY3VycmVudCBjYWxsYmFjayBjYWxsIGRlcHRoLiBPbmNlIHRoYXQgZGVwdGggcmVhY2hlcyBhIGNlcnRhaW4gbnVtYmVyLFxuICAgICBbZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGhdLCBkZWZpbmVkIGJlbG93LCBmdXJ0aGVyIGNhbGxiYWNrc1xuICAgICBhcmUgZGVmZXJyZWQgaW50byBhIHF1ZXVlIGluc3RlYWQuIFRoYXQgcXVldWUgaXMgZHJhaW5lZCB3aGVuIEx3dCBleGl0c1xuICAgICBmcm9tIHRoZSB0b3AtbW9zdCBjYWxsYmFjayBjYWxsIHRoYXQgdHJpZ2dlcmVkIHRoZSByZXNvbHV0aW9uIGxvb3AgaW4gdGhlXG4gICAgIGZpcnN0IHBsYWNlLlxuXG4gICAgIFRvIGVuc3VyZSB0aGF0IHRoaXMgZGVmZXJyYWwgbWVjaGFuaXNtIGlzIGFsd2F5cyBwcm9wZXJseSBpbnZva2VkLCBhbGxcbiAgICAgY2FsbGJhY2tzIGNhbGxlZCBieSBMd3QgYXJlIGNhbGxlZCB0aHJvdWdoIG9uZSBvZiB0aHJlZSBmdW5jdGlvbnMgcHJvdmlkZWRcbiAgICAgYnkgdGhpcyBtb2R1bGU6XG5cbiAgICAgLSBbcmVzb2x2ZV0sIHdoaWNoIGNhbGxzIGFsbCB0aGUgY2FsbGJhY2tzIGFzc29jaWF0ZWQgdG8gYSBwZW5kaW5nIHByb21pc2VcbiAgICAgICAoYW5kIHJlc29sdmVzIGl0LCBjaGFuZ2luZyBpdHMgc3RhdGUpLlxuICAgICAtIFtydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1dLCB3aGljaCBpcyBpbnRlcm5hbGx5IHVzZWQgYnkgW3Jlc29sdmVdIHRvXG4gICAgICAgY2FsbCBjYWxsYmFja3MgdGhhdCBhcmUgaW4gYSByZWNvcmQgb2YgdHlwZSBbJ2EgY2FsbGJhY2tzXSwgd2hpY2ggcmVjb3Jkc1xuICAgICAgIGFyZSBhc3NvY2lhdGVkIHdpdGggcGVuZGluZyBwcm9taXNlcy4gVGhpcyBmdW5jdGlvbiBpcyBleHBvc2VkIGJlY2F1c2VcbiAgICAgICB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiBbTHd0LmNhbmNlbF0gbmVlZHMgdG8gY2FsbCBpdCBkaXJlY3RseS5cbiAgICAgICBQcm9taXNlIHJlc29sdXRpb24gYW5kIGNhbGxiYWNrIGNhbGxpbmcgYXJlIHNlcGFyYXRlZCBpbiBhIHVuaXF1ZSB3YXkgaW5cbiAgICAgICBbY2FuY2VsXS5cbiAgICAgLSBbcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XSwgd2hpY2ggaXMgdXNlZCBieSBbTHd0LmJpbmRdIGFuZCBzaW1pbGFyXG4gICAgICAgZnVuY3Rpb25zIHRvIGNhbGwgc2luZ2xlIGNhbGxiYWNrcyB3aGVuIHRoZSBwcm9taXNlcyBwYXNzZWQgdG9cbiAgICAgICBbTHd0LmJpbmRdLCBldGMuLCBhcmUgYWxyZWFkeSByZXNvbHZlZC5cblxuICAgICBDdXJyZW50IEx3dCBhY3R1YWxseSBoYXMgYSBtZXNzeSBtaXggb2YgY2FsbGJhY2stY2FsbGluZyBiZWhhdmlvcnMuIEZvclxuICAgICBleGFtcGxlLCBbTHd0LmJpbmRdIGlzIGV4cGVjdGVkIHRvIGFsd2F5cyBjYWxsIGl0cyBjYWxsYmFjayBpbW1lZGlhdGVseSxcbiAgICAgd2hpbGUgW0x3dC53YWtldXBfbGF0ZXJdIGlzIGV4cGVjdGVkIHRvIGRlZmVyIGFsbCBjYWxsYmFja3Mgb2YgdGhlIHByb21pc2VcbiAgICAgcmVzb2x2ZWQsIHtlIHVubGVzc30gTHd0IGlzIG5vdCBhbHJlYWR5IGluc2lkZSB0aGUgcmVzb2x1dGlvbiBsb29wLlxuXG4gICAgIFdlIHBsYW5uZWQgdG8gbWFrZSB0aGVzZSBiZWhhdmlvcnMgdW5pZm9ybSBpbiBMd3QgNC4wLjAsIGJ1dCBkZWNpZGVkXG4gICAgIGFnYWluc3QgaXQgZHVlIHRvIHRoZSByaXNrIG9mIGJyZWFraW5nIHVzZXJzLiBTZWVcblxuICAgICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9wdWxsLzUwMFxuICAgICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9wdWxsLzUxOVxuXG4gICAgIEFzIHBhcnQgb2YgdGhlIHByZXBhcmF0aW9uIGZvciB0aGUgY2hhbmdlLCB0aGUgYWJvdmUgY2FsbGJhY2staW52b2tpbmdcbiAgICAgZnVuY3Rpb25zIHN1cHBvcnQgc2V2ZXJhbCBvcHRpb25hbCBhcmd1bWVudHMgdG8gZW11bGF0ZSB0aGUgdmFyaW91c1xuICAgICBiZWhhdmlvcnMuIFdlIGRlY2lkZWQgbm90IHRvIHJlbW92ZSB0aGlzIG1hY2hpbmVyeSwgYmVjYXVzZSB3ZSBtaWdodCB3YW50XG4gICAgIHRvIGV4cG9zZSBkaWZmZXJlbnQgQVBJcyB0byBMd3QgaW4gdGhlIGZ1dHVyZS5cblxuICAgICAtIFt+YWxsb3dfZGVmZXJyaW5nOmZhbHNlXSBhbGxvd3MgaWdub3JpbmcgdGhlIGNhbGxiYWNrIHN0YWNrIGRlcHRoLCBhbmRcbiAgICAgICBjYWxsaW5nIHRoZSBjYWxsYmFja3MgaW1tZWRpYXRlbHkuIFRoaXMgZW11bGF0ZXMgdGhlIG9sZCByZXNvbHV0aW9uXG4gICAgICAgYmVoYXZpb3IuXG4gICAgIC0gW35tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGg6MV0gYWxsb3dzIGxpbWl0aW5nIHRoZSBkZXB0aCB3aGljaFxuICAgICAgIHRyaWdnZXJzIGRlZmVycmFsIG9uIGEgcGVyLWNhbGwtc2l0ZSBiYXNpcy4gVGhpcyBpcyB1c2VkIGJ5XG4gICAgICAgW0x3dC53YWtldXBfbGF0ZXJdLlxuICAgICAtIFt+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVdIGlzIGxpa2VcbiAgICAgICBbfmFsbG93X2RlZmVycmluZzpmYWxzZV0sIHdoaWNoIGlnbm9yZXMgdGhlIGNhbGxiYWNrIHN0YWNrIGRlcHRoLlxuICAgICAgIEhvd2V2ZXIsIHRvIGVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayBpcyB0YWlsLWNhbGxlZCwgTHd0IGRvZXNuJ3QgZXZlblxuICAgICAgIHVwZGF0ZSB0aGUgY2FsbGJhY2sgc3RhY2sgZGVwdGggZm9yIHRoZSBiZW5lZml0IG9mICpvdGhlciogY2FsbGJhY2tcbiAgICAgICBjYWxscy4gSXQganVzdCBibGluZGx5IGNhbGxzIHRoZSBjYWxsYmFjay5cblxuICAgICBTZWUgZGlzY3Vzc2lvbiBvZiBjYWxsYmFjay1jYWxsaW5nIHNlbWFudGljcyBpbjpcblxuICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9pc3N1ZXMvMzI5XG5cbiAgICAgKiBDb250ZXh0XG5cbiAgICAgVGhlIHJlc29sdXRpb24gbG9vcCBlZmZlY3RpdmVseSBoYW5kbGVzIGFsbCBwcm9taXNlcyB0aGF0IGNhbiBiZSByZXNvbHZlZFxuICAgICBpbW1lZGlhdGVseSwgd2l0aG91dCBibG9ja2luZyBvbiBJL08uIEEgY29tcGxldGUgcHJvZ3JhbSB0aGF0IGRvZXMgSS9PXG4gICAgIGNhbGxzIFtMd3RfbWFpbi5ydW5dLiBTZWUgXCJObyBJL09cIiBpbiB0aGUgT3ZlcnZpZXcuICopXG5cblxuXG4gIGxldCBhc3luY19leGNlcHRpb25faG9vayA9XG4gICAgcmVmIChmdW4gZXhuIC0+XG4gICAgICBwcmVycl9zdHJpbmcgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uIFwiO1xuICAgICAgcHJlcnJfc3RyaW5nIChQcmludGV4Yy50b19zdHJpbmcgZXhuKTtcbiAgICAgIHByZXJyX2NoYXIgJ1xcbic7XG4gICAgICBQcmludGV4Yy5wcmludF9iYWNrdHJhY2Ugc3RkZXJyO1xuICAgICAgZmx1c2ggc3RkZXJyO1xuICAgICAgZXhpdCAyKVxuXG4gIGxldCBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIHYgPVxuICAgICgqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNhcmUgaWYgW2ZdIGV2YWx1YXRlcyB0byBhIHByb21pc2UuIEluXG4gICAgICAgcGFydGljdWxhciwgaWYgW2Ygdl0gZXZhbHVhdGVzIHRvIFtwXSBhbmQgW3BdIGlzIGFscmVhZHkgcmVqZWN0ZWQgb3Igd2lsbFxuICAgICAgIGJlIHJlamVjdCBsYXRlciwgaXQgaXMgbm90IHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGlzIGZ1bmN0aW9uIHRvIHBhc3NcbiAgICAgICB0aGUgZXhjZXB0aW9uIHRvIFshYXN5bmNfZXhjZXB0aW9uX2hvb2tdLiAqKVxuICAgIHRyeSBmIHZcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuXG5cblxuICBleGNlcHRpb24gQ2FuY2VsZWRcblxuXG5cbiAgKCogUnVucyB0aGUgY2FsbGJhY2tzIChmb3JtZXJseSkgYXNzb2NpYXRlZCB0byBhIHByb21pc2UuIENhbmNlbCBjYWxsYmFja3MgYXJlXG4gICAgIHJ1biBmaXJzdCwgaWYgdGhlIHByb21pc2Ugd2FzIGNhbmNlbGVkLiBUaGVzZSBhcmUgZm9sbG93ZWQgYnkgcmVndWxhclxuICAgICBjYWxsYmFja3MuXG5cbiAgICAgVGhlIHJlYXNvbiBmb3IgdGhlIFwiZm9ybWVybHlcIiBpcyB0aGF0IHRoZSBwcm9taXNlJ3Mgc3RhdGUgaGFzIGFscmVhZHkgYmVlblxuICAgICBzZXQgdG8gW0Z1bGZpbGxlZCBfXSBvciBbUmVqZWN0ZWQgX10sIHNvIHRoZSBjYWxsYmFja3MgYXJlIG5vIGxvbmdlclxuICAgICByZWFjaGFibGUgdGhyb3VnaCB0aGUgcHJvbWlzZSByZWZlcmVuY2UuIFRoaXMgaXMgd2h5IHRoZSBkaXJlY3QgW2NhbGxiYWNrc11cbiAgICAgcmVjb3JkIG11c3QgYmUgZ2l2ZW4gdG8gdGhpcyBmdW5jdGlvbi4gKilcbiAgbGV0IHJ1bl9jYWxsYmFja3NcbiAgICAgIChjYWxsYmFja3MgOiAnYSBjYWxsYmFja3MpXG4gICAgICAocmVzdWx0IDogJ2EgcmVzb2x2ZWRfc3RhdGUpIDogdW5pdCA9XG5cbiAgICBsZXQgcnVuX2NhbmNlbF9jYWxsYmFja3MgZnMgPVxuICAgICAgbGV0IHJlYyBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgcmVzdCA9XG4gICAgICAgIG1hdGNoIGZzIHdpdGhcbiAgICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPlxuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgKHN0b3JhZ2UsIGYpIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHN0b3JhZ2U7XG4gICAgICAgICAgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKTtcbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGUgLT5cbiAgICAgICAgICBMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGU7XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGZzLCBmcycpIC0+XG4gICAgICAgICAgaXRlcl9jYWxsYmFja19saXN0IGZzIChmcyc6OnJlc3QpXG5cbiAgICAgIGFuZCBpdGVyX2xpc3QgcmVzdCA9XG4gICAgICAgIG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgZnM6OnJlc3QgLT4gaXRlcl9jYWxsYmFja19saXN0IGZzIHJlc3RcblxuICAgICAgaW5cblxuICAgICAgaXRlcl9jYWxsYmFja19saXN0IGZzIFtdXG4gICAgaW5cblxuICAgIGxldCBydW5fcmVndWxhcl9jYWxsYmFja3MgZnMgPVxuICAgICAgbGV0IHJlYyBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgcmVzdCA9XG4gICAgICAgIG1hdGNoIGZzIHdpdGhcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT5cbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgZiAtPlxuICAgICAgICAgIGYgcmVzdWx0O1xuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrXG4gICAgICAgICAgICB7Y29udGVudHMgPSBOb25lfSAtPlxuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrXG4gICAgICAgICAgICB7Y29udGVudHMgPSBTb21lIGZ9IC0+XG4gICAgICAgICAgZiByZXN1bHQ7XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChmcywgZnMnKSAtPlxuICAgICAgICAgIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyAoZnMnOjpyZXN0KVxuXG4gICAgICBhbmQgaXRlcl9saXN0IHJlc3QgPVxuICAgICAgICBtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGZzOjpyZXN0IC0+IGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyByZXN0XG5cbiAgICAgIGluXG5cbiAgICAgIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyBbXVxuICAgIGluXG5cbiAgICAoKiBQYXR0ZXJuIG1hdGNoaW5nIGlzIG11Y2ggZmFzdGVyIHRoYW4gcG9seW1vcnBoaWMgY29tcGFyaXNvbi4gKilcbiAgICBsZXQgaXNfY2FuY2VsZWQgPVxuICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgIHwgUmVqZWN0ZWQgQ2FuY2VsZWQgLT4gdHJ1ZVxuICAgICAgfCBSZWplY3RlZCBfIC0+IGZhbHNlXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBpZiBpc19jYW5jZWxlZCB0aGVuXG4gICAgICBydW5fY2FuY2VsX2NhbGxiYWNrcyBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcztcbiAgICBydW5fcmVndWxhcl9jYWxsYmFja3MgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzXG5cblxuXG4gIGxldCBkZWZhdWx0X21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IDQyXG5cbiAgbGV0IGN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IHJlZiAwXG5cbiAgdHlwZSBkZWZlcnJlZF9jYWxsYmFja3MgPVxuICAgIERlZmVycmVkIDogKCdhIGNhbGxiYWNrcyAqICdhIHJlc29sdmVkX3N0YXRlKSAtPiBkZWZlcnJlZF9jYWxsYmFja3NcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gIGxldCBkZWZlcnJlZF9jYWxsYmFja3MgOiBkZWZlcnJlZF9jYWxsYmFja3MgUXVldWUudCA9IFF1ZXVlLmNyZWF0ZSAoKVxuXG4gICgqIEJlZm9yZSBlbnRlcmluZyBhIHJlc29sdXRpb24gbG9vcCwgaXQgaXMgbmVjZXNzYXJ5IHRvIHRha2UgYSBzbmFwc2hvdCBvZlxuICAgICB0aGUgY3VycmVudCBzdGF0ZSBvZiBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UuIFRoaXMgaXMgYmVjYXVzZSBtYW55IG9mXG4gICAgIHRoZSBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIHJ1biB3aWxsIG1vZGlmeSB0aGUgc3RvcmFnZS4gVGhlIHN0b3JhZ2UgaXNcbiAgICAgcmVzdG9yZWQgdG8gdGhlIHNuYXBzaG90IHdoZW4gdGhlIHJlc29sdXRpb24gbG9vcCBpcyBleGl0ZWQuICopXG4gIGxldCBlbnRlcl9yZXNvbHV0aW9uX2xvb3AgKCkgPVxuICAgIGN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA6PSAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoICsgMTtcbiAgICBsZXQgc3RvcmFnZV9zbmFwc2hvdCA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cbiAgICBzdG9yYWdlX3NuYXBzaG90XG5cbiAgbGV0IGxlYXZlX3Jlc29sdXRpb25fbG9vcCAoc3RvcmFnZV9zbmFwc2hvdCA6IHN0b3JhZ2UpIDogdW5pdCA9XG4gICAgaWYgIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IDEgdGhlbiBiZWdpblxuICAgICAgd2hpbGUgbm90IChRdWV1ZS5pc19lbXB0eSBkZWZlcnJlZF9jYWxsYmFja3MpIGRvXG4gICAgICAgIGxldCBEZWZlcnJlZCAoY2FsbGJhY2tzLCByZXN1bHQpID0gUXVldWUucG9wIGRlZmVycmVkX2NhbGxiYWNrcyBpblxuICAgICAgICBydW5fY2FsbGJhY2tzIGNhbGxiYWNrcyByZXN1bHRcbiAgICAgIGRvbmVcbiAgICBlbmQ7XG4gICAgY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIDo9ICFjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggLSAxO1xuICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzdG9yYWdlX3NuYXBzaG90XG5cbiAgbGV0IHJ1bl9pbl9yZXNvbHV0aW9uX2xvb3AgZiA9XG4gICAgbGV0IHN0b3JhZ2Vfc25hcHNob3QgPSBlbnRlcl9yZXNvbHV0aW9uX2xvb3AgKCkgaW5cbiAgICBsZXQgcmVzdWx0ID0gZiAoKSBpblxuICAgIGxlYXZlX3Jlc29sdXRpb25fbG9vcCBzdG9yYWdlX3NuYXBzaG90O1xuICAgIHJlc3VsdFxuXG4gICgqIFRoaXMgaXMgYmFzaWNhbGx5IGEgaGFjayB0byBmaXggaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2lzc3Vlcy80OC5cbiAgICAgSWYgY3VycmVudGx5IHJlc29sdmluZyBwcm9taXNlcywgaXQgaW1tZWRpYXRlbHkgZXhpdHMgYWxsIHJlY3Vyc2l2ZVxuICAgICBlbnRyaWVzIG9mIHRoZSByZXNvbHV0aW9uIGxvb3AsIGdvZXMgdG8gdGhlIHRvcCBsZXZlbCwgcnVucyBhbnkgZGVmZXJyZWRcbiAgICAgY2FsbGJhY2tzLCBhbmQgZXhpdHMgdGhlIHRvcC1sZXZlbCByZXNvbHV0aW9uIGxvb3AuXG5cbiAgICAgVGhlIG5hbWUgc2hvdWxkIHByb2JhYmx5IGJlIFthYmFvbmRvbl9yZXNvbHV0aW9uX2xvb3BdLiAqKVxuICBsZXQgYWJhbmRvbl93YWtldXBzICgpID1cbiAgICBpZiAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIDw+IDAgdGhlblxuICAgICAgbGVhdmVfcmVzb2x1dGlvbl9sb29wIFN0b3JhZ2VfbWFwLmVtcHR5XG5cblxuXG4gIGxldCBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgID8oYWxsb3dfZGVmZXJyaW5nID0gdHJ1ZSlcbiAgICAgID8obWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoID0gZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGgpXG4gICAgICBjYWxsYmFja3MgcmVzdWx0ID1cblxuICAgIGxldCBzaG91bGRfZGVmZXIgPVxuICAgICAgYWxsb3dfZGVmZXJyaW5nXG4gICAgICAmJiAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoID49IG1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aFxuICAgIGluXG5cbiAgICBpZiBzaG91bGRfZGVmZXIgdGhlblxuICAgICAgUXVldWUucHVzaCAoRGVmZXJyZWQgKGNhbGxiYWNrcywgcmVzdWx0KSkgZGVmZXJyZWRfY2FsbGJhY2tzXG4gICAgZWxzZVxuICAgICAgcnVuX2luX3Jlc29sdXRpb25fbG9vcCAoZnVuICgpIC0+XG4gICAgICAgIHJ1bl9jYWxsYmFja3MgY2FsbGJhY2tzIHJlc3VsdClcblxuICBsZXQgcmVzb2x2ZSA/YWxsb3dfZGVmZXJyaW5nID9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGggcCByZXN1bHQgPVxuICAgIGxldCBQZW5kaW5nIGNhbGxiYWNrcyA9IHAuc3RhdGUgaW5cbiAgICBsZXQgcCA9IHNldF9wcm9taXNlX3N0YXRlIHAgcmVzdWx0IGluXG5cbiAgICBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgID9hbGxvd19kZWZlcnJpbmcgP21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCBjYWxsYmFja3MgcmVzdWx0O1xuXG4gICAgcFxuXG4gIGxldCBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgID8ocnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsID0gZmFsc2UpXG4gICAgICB+Y2FsbGJhY2s6ZlxuICAgICAgfmlmX2RlZmVycmVkID1cblxuICAgIGlmIHJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbCB0aGVuXG4gICAgICBmICgpXG5cbiAgICBlbHNlXG4gICAgICBsZXQgc2hvdWxkX2RlZmVyID1cbiAgICAgICAgIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aFxuICAgICAgICAgID49IGRlZmF1bHRfbWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoXG4gICAgICBpblxuXG4gICAgICBpZiBzaG91bGRfZGVmZXIgdGhlbiBiZWdpblxuICAgICAgICBsZXQgaW1tZWRpYXRlX3Jlc3VsdCwgZGVmZXJyZWRfY2FsbGJhY2ssIGRlZmVycmVkX3Jlc3VsdCA9XG4gICAgICAgICAgaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgbGV0IGRlZmVycmVkX3JlY29yZCA9XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVndWxhcl9jYWxsYmFja3MgPVxuICAgICAgICAgICAgICBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrXG4gICAgICAgICAgICAgICAgZGVmZXJyZWRfY2FsbGJhY2s7XG4gICAgICAgICAgICBjYW5jZWxfY2FsbGJhY2tzID0gQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHk7XG4gICAgICAgICAgICBob3dfdG9fY2FuY2VsID0gTm90X2NhbmNlbGFibGU7XG4gICAgICAgICAgICBjbGVhbnVwc19kZWZlcnJlZCA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIGluXG4gICAgICAgIFF1ZXVlLnB1c2hcbiAgICAgICAgICAoRGVmZXJyZWQgKGRlZmVycmVkX3JlY29yZCwgZGVmZXJyZWRfcmVzdWx0KSkgZGVmZXJyZWRfY2FsbGJhY2tzO1xuICAgICAgICBpbW1lZGlhdGVfcmVzdWx0XG4gICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgcnVuX2luX3Jlc29sdXRpb25fbG9vcCAoZnVuICgpIC0+XG4gICAgICAgICAgZiAoKSlcbmVuZFxuaW5jbHVkZSBSZXNvbHV0aW9uX2xvb3BcblxuXG5cbm1vZHVsZSBSZXNvbHZpbmcgOlxuc2lnXG4gIHZhbCB3YWtldXBfbGF0ZXJfcmVzdWx0IDogJ2EgdSAtPiAoJ2EsIGV4bikgcmVzdWx0IC0+IHVuaXRcbiAgdmFsIHdha2V1cF9sYXRlciA6ICdhIHUgLT4gJ2EgLT4gdW5pdFxuICB2YWwgd2FrZXVwX2xhdGVyX2V4biA6IF8gdSAtPiBleG4gLT4gdW5pdFxuXG4gIHZhbCB3YWtldXBfcmVzdWx0IDogJ2EgdSAtPiAoJ2EsIGV4bikgcmVzdWx0IC0+IHVuaXRcbiAgdmFsIHdha2V1cCA6ICdhIHUgLT4gJ2EgLT4gdW5pdFxuICB2YWwgd2FrZXVwX2V4biA6IF8gdSAtPiBleG4gLT4gdW5pdFxuXG4gIHZhbCBjYW5jZWwgOiAnYSB0IC0+IHVuaXRcbmVuZCA9XG5zdHJ1Y3RcbiAgKCogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGV2aWF0ZXMgZnJvbSB0aGUgXCJpZGVhbFwiIGNhbGxiYWNrIGRlZmVycmFsXG4gICAgIGJlaGF2aW9yOiBpdCBydW5zIGNhbGxiYWNrcyBkaXJlY3RseSBvbiB0aGUgY3VycmVudCBzdGFjay4gSXQgc2hvdWxkXG4gICAgIHRoZXJlZm9yZSBiZSBwb3NzaWJsZSB0byBjYXVzZSBhIHN0YWNrIG92ZXJmbG93IHVzaW5nIHRoaXMgZnVuY3Rpb24uICopXG4gIGxldCB3YWtldXBfZ2VuZXJhbCBhcGlfZnVuY3Rpb25fbmFtZSByIHJlc3VsdCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9yZXNvbHZlciByIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgUmVqZWN0ZWQgQ2FuY2VsZWQgLT5cbiAgICAgICgpXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnIFwiTHd0LiVzXCIgYXBpX2Z1bmN0aW9uX25hbWVcbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZyBcIkx3dC4lc1wiIGFwaV9mdW5jdGlvbl9uYW1lXG5cbiAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgbGV0IHJlc3VsdCA9IHN0YXRlX29mX3Jlc3VsdCByZXN1bHQgaW5cbiAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPSByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgIGlnbm9yZSBwXG5cbiAgbGV0IHdha2V1cF9yZXN1bHQgciByZXN1bHQgPSB3YWtldXBfZ2VuZXJhbCBcIndha2V1cF9yZXN1bHRcIiByIHJlc3VsdFxuICBsZXQgd2FrZXVwIHIgdiA9IHdha2V1cF9nZW5lcmFsIFwid2FrZXVwXCIgciAoT2sgdilcbiAgbGV0IHdha2V1cF9leG4gciBleG4gPSB3YWtldXBfZ2VuZXJhbCBcIndha2V1cF9leG5cIiByIChFcnJvciBleG4pXG5cbiAgbGV0IHdha2V1cF9sYXRlcl9nZW5lcmFsIGFwaV9mdW5jdGlvbl9uYW1lIHIgcmVzdWx0ID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Jlc29sdmVyIHIgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBSZWplY3RlZCBDYW5jZWxlZCAtPlxuICAgICAgKClcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICBQcmludGYua3NwcmludGYgaW52YWxpZF9hcmcgXCJMd3QuJXNcIiBhcGlfZnVuY3Rpb25fbmFtZVxuICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnIFwiTHd0LiVzXCIgYXBpX2Z1bmN0aW9uX25hbWVcblxuICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICBsZXQgcmVzdWx0ID0gc3RhdGVfb2ZfcmVzdWx0IHJlc3VsdCBpblxuICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgIHJlc29sdmUgfm1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aDoxIHAgcmVzdWx0IGluXG4gICAgICBpZ25vcmUgcFxuXG4gIGxldCB3YWtldXBfbGF0ZXJfcmVzdWx0IHIgcmVzdWx0ID1cbiAgICB3YWtldXBfbGF0ZXJfZ2VuZXJhbCBcIndha2V1cF9sYXRlcl9yZXN1bHRcIiByIHJlc3VsdFxuICBsZXQgd2FrZXVwX2xhdGVyIHIgdiA9XG4gICAgd2FrZXVwX2xhdGVyX2dlbmVyYWwgXCJ3YWtldXBfbGF0ZXJcIiByIChPayB2KVxuICBsZXQgd2FrZXVwX2xhdGVyX2V4biByIGV4biA9XG4gICAgd2FrZXVwX2xhdGVyX2dlbmVyYWwgXCJ3YWtldXBfbGF0ZXJfZXhuXCIgciAoRXJyb3IgZXhuKVxuXG5cblxuICB0eXBlIHBhY2tlZF9jYWxsYmFja3MgPVxuICAgIHwgUGFja2VkIDogXyBjYWxsYmFja3MgLT4gcGFja2VkX2NhbGxiYWNrc1xuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgKCogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGV2aWF0ZXMgZnJvbSB0aGUgXCJpZGVhbFwiIGNhbGxiYWNrIGRlZmVycmFsXG4gICAgIGJlaGF2aW9yOiBpdCBydW5zIGNhbGxiYWNrcyBkaXJlY3RseSBvbiB0aGUgY3VycmVudCBzdGFjay4gSXQgc2hvdWxkXG4gICAgIHRoZXJlZm9yZSBiZSBwb3NzaWJsZSB0byBjYXVzZSBhIHN0YWNrIG92ZXJmbG93IHVzaW5nIHRoaXMgZnVuY3Rpb24uICopXG4gIGxldCBjYW5jZWwgcCA9XG4gICAgbGV0IGNhbmNlbGVkX3Jlc3VsdCA9IFJlamVjdGVkIENhbmNlbGVkIGluXG5cbiAgICAoKiBXYWxrcyB0aGUgcHJvbWlzZSBkZXBlbmRlbmN5IGdyYXBoIGJhY2t3YXJkcywgbG9va2luZyBmb3IgY2FuY2VsYWJsZVxuICAgICAgIGluaXRpYWwgcHJvbWlzZXMsIGFuZCBjYW5jZWxzIChvbmx5KSB0aGVtLlxuXG4gICAgICAgRm91bmQgaW5pdGlhbCBwcm9taXNlcyBhcmUgY2FuY2VsZWQgaW1tZWRpYXRlbHksIGFzIHRoZXkgYXJlIGZvdW5kLCBieVxuICAgICAgIHNldHRpbmcgdGhlaXIgc3RhdGUgdG8gW1JlamVjdGVkIENhbmNlbGVkXS4gVGhpcyBpcyB0byBwcmV2ZW50IHRoZW0gZnJvbVxuICAgICAgIGJlaW5nIFwiZm91bmQgdHdpY2VcIiBpZiB0aGV5IGFyZSByZWFjaGFibGUgYnkgdHdvIG9yIG1vcmUgZGlzdGluY3QgcGF0aHNcbiAgICAgICB0aHJvdWdoIHRoZSBwcm9taXNlIGRlcGVuZGVuY3kgZ3JhcGguXG5cbiAgICAgICBUaGUgY2FsbGJhY2tzIG9mIHRoZXNlIGluaXRpYWwgcHJvbWlzZXMgYXJlIHRoZW4gcnVuLCBpbiBhIHNlcGFyYXRlXG4gICAgICAgcGhhc2UuIFRoZXNlIGNhbGxiYWNrcyBwcm9wYWdhdGUgY2FuY2VsbGF0aW9uIGZvcndhcmRzIHRvIGFueSBkZXBlbmRlbnRcbiAgICAgICBwcm9taXNlcy4gU2VlIFwiQ2FuY2VsbGF0aW9uXCIgaW4gdGhlIE92ZXJ2aWV3LiAqKVxuICAgIGxldCBwcm9wYWdhdGVfY2FuY2VsIDogKF8sIF8sIF8pIHByb21pc2UgLT4gcGFja2VkX2NhbGxiYWNrcyBsaXN0ID1cbiAgICAgICAgZnVuIHAgLT5cbiAgICAgIGxldCByZWMgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyA6XG4gICAgICAgICAgJ2EgJ3UgJ2MuIHBhY2tlZF9jYWxsYmFja3MgbGlzdCAtPiAoJ2EsICd1LCAnYykgcHJvbWlzZSAtPlxuICAgICAgICAgICAgcGFja2VkX2NhbGxiYWNrcyBsaXN0ID1cbiAgICAgICAgICBmdW4gKHR5cGUgYykgY2FsbGJhY2tzX2FjY3VtdWxhdG9yIChwIDogKF8sIF8sIGMpIHByb21pc2UpIC0+XG5cbiAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgICAgICgqIElmIHRoZSBwcm9taXNlIGlzIG5vdCBzdGlsbCBwZW5kaW5nLCBpdCBjYW4ndCBiZSBjYW5jZWxlZC4gKilcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgIGNhbGxiYWNrc19hY2N1bXVsYXRvclxuICAgICAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICAgICBjYWxsYmFja3NfYWNjdW11bGF0b3JcblxuICAgICAgICB8IFBlbmRpbmcgY2FsbGJhY2tzIC0+XG4gICAgICAgICAgbWF0Y2ggY2FsbGJhY2tzLmhvd190b19jYW5jZWwgd2l0aFxuICAgICAgICAgIHwgTm90X2NhbmNlbGFibGUgLT5cbiAgICAgICAgICAgIGNhbGxiYWNrc19hY2N1bXVsYXRvclxuICAgICAgICAgIHwgQ2FuY2VsX3RoaXNfcHJvbWlzZSAtPlxuICAgICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgICAgIHNldF9wcm9taXNlX3N0YXRlIHAgY2FuY2VsZWRfcmVzdWx0IGluXG4gICAgICAgICAgICBpZ25vcmUgcDtcbiAgICAgICAgICAgIChQYWNrZWQgY2FsbGJhY2tzKTo6Y2FsbGJhY2tzX2FjY3VtdWxhdG9yXG4gICAgICAgICAgfCBQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwJyAtPlxuICAgICAgICAgICAgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyBjYWxsYmFja3NfYWNjdW11bGF0b3IgcCdcbiAgICAgICAgICB8IFByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcyAtPlxuICAgICAgICAgICAgTGlzdC5mb2xkX2xlZnQgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyBjYWxsYmFja3NfYWNjdW11bGF0b3IgcHNcbiAgICAgIGluXG4gICAgICBjYW5jZWxfYW5kX2NvbGxlY3RfY2FsbGJhY2tzIFtdIHBcbiAgICBpblxuXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgY2FsbGJhY2tzID0gcHJvcGFnYXRlX2NhbmNlbCBwIGluXG5cbiAgICBjYWxsYmFja3MgfD4gTGlzdC5pdGVyIChmdW4gKFBhY2tlZCBjYWxsYmFja3MpIC0+XG4gICAgICBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgICAgfmFsbG93X2RlZmVycmluZzpmYWxzZSBjYWxsYmFja3MgY2FuY2VsZWRfcmVzdWx0KVxuZW5kXG5pbmNsdWRlIFJlc29sdmluZ1xuXG5cblxubW9kdWxlIFRyaXZpYWxfcHJvbWlzZXMgOlxuc2lnXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG4gIHZhbCBmYWlsIDogZXhuIC0+IF8gdFxuICB2YWwgb2ZfcmVzdWx0IDogKCdhLCBleG4pIHJlc3VsdCAtPiAnYSB0XG5cbiAgdmFsIHJldHVybl91bml0IDogdW5pdCB0XG4gIHZhbCByZXR1cm5fdHJ1ZSA6IGJvb2wgdFxuICB2YWwgcmV0dXJuX2ZhbHNlIDogYm9vbCB0XG4gIHZhbCByZXR1cm5fbm9uZSA6IF8gb3B0aW9uIHRcbiAgdmFsIHJldHVybl9zb21lIDogJ2EgLT4gJ2Egb3B0aW9uIHRcbiAgdmFsIHJldHVybl9vayA6ICdhIC0+ICgnYSwgXykgcmVzdWx0IHRcbiAgdmFsIHJldHVybl9lcnJvciA6ICdlIC0+IChfLCAnZSkgcmVzdWx0IHRcbiAgdmFsIHJldHVybl9uaWwgOiBfIGxpc3QgdFxuXG4gIHZhbCBmYWlsX3dpdGggOiBzdHJpbmcgLT4gXyB0XG4gIHZhbCBmYWlsX2ludmFsaWRfYXJnIDogc3RyaW5nIC0+IF8gdFxuZW5kID1cbnN0cnVjdFxuICBsZXQgcmV0dXJuIHYgPVxuICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IEZ1bGZpbGxlZCB2fVxuXG4gIGxldCBvZl9yZXN1bHQgcmVzdWx0ID1cbiAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBzdGF0ZV9vZl9yZXN1bHQgcmVzdWx0fVxuXG4gIGxldCBmYWlsIGV4biA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgZXhufVxuXG4gIGxldCByZXR1cm5fdW5pdCA9IHJldHVybiAoKVxuICBsZXQgcmV0dXJuX25vbmUgPSByZXR1cm4gTm9uZVxuICBsZXQgcmV0dXJuX3NvbWUgeCA9IHJldHVybiAoU29tZSB4KVxuICBsZXQgcmV0dXJuX25pbCA9IHJldHVybiBbXVxuICBsZXQgcmV0dXJuX3RydWUgPSByZXR1cm4gdHJ1ZVxuICBsZXQgcmV0dXJuX2ZhbHNlID0gcmV0dXJuIGZhbHNlXG4gIGxldCByZXR1cm5fb2sgeCA9IHJldHVybiAoT2sgeClcbiAgbGV0IHJldHVybl9lcnJvciB4ID0gcmV0dXJuIChFcnJvciB4KVxuXG4gIGxldCBmYWlsX3dpdGggbXNnID1cbiAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBSZWplY3RlZCAoRmFpbHVyZSBtc2cpfVxuXG4gIGxldCBmYWlsX2ludmFsaWRfYXJnIG1zZyA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgKEludmFsaWRfYXJndW1lbnQgbXNnKX1cbmVuZFxuaW5jbHVkZSBUcml2aWFsX3Byb21pc2VzXG5cblxuXG5tb2R1bGUgUGVuZGluZ19wcm9taXNlcyA6XG5zaWdcbiAgKCogSW50ZXJuYWwgKilcbiAgdmFsIG5ld19wZW5kaW5nIDpcbiAgICBob3dfdG9fY2FuY2VsOmhvd190b19jYW5jZWwgLT4gKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlXG4gIHZhbCBwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgOiBfIHQgbGlzdCAtPiBob3dfdG9fY2FuY2VsXG5cbiAgKCogSW5pdGlhbCBwZW5kaW5nIHByb21pc2VzIChwdWJsaWMpICopXG4gIHZhbCB3YWl0IDogdW5pdCAtPiAnYSB0ICogJ2EgdVxuICB2YWwgdGFzayA6IHVuaXQgLT4gJ2EgdCAqICdhIHVcblxuICB2YWwgYWRkX3Rhc2tfciA6ICdhIHUgTHd0X3NlcXVlbmNlLnQgLT4gJ2EgdFxuICB2YWwgYWRkX3Rhc2tfbCA6ICdhIHUgTHd0X3NlcXVlbmNlLnQgLT4gJ2EgdFxuXG4gIHZhbCBwcm90ZWN0ZWQgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIG5vX2NhbmNlbCA6ICdhIHQgLT4gJ2EgdFxuZW5kID1cbnN0cnVjdFxuICBsZXQgbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWwgPVxuICAgIGxldCBzdGF0ZSA9XG4gICAgICBQZW5kaW5nIHtcbiAgICAgICAgcmVndWxhcl9jYWxsYmFja3MgPSBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHk7XG4gICAgICAgIGNhbmNlbF9jYWxsYmFja3MgPSBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eTtcbiAgICAgICAgaG93X3RvX2NhbmNlbDtcbiAgICAgICAgY2xlYW51cHNfZGVmZXJyZWQgPSAwO1xuICAgICAgfVxuICAgIGluXG4gICAge3N0YXRlfVxuXG4gIGxldCBwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMgPVxuICAgICgqIFVzaW5nIGEgZGlydHkgY2FzdCBoZXJlIHRvIGF2b2lkIHJlYnVpbGRpbmcgdGhlIGxpc3QgOiggTm90IGJvdGhlcmluZ1xuICAgICAgIHdpdGggdGhlIGludmFyaWFudHMsIGJlY2F1c2UgW1Byb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbF0gcGFja3MgdGhlbSxcbiAgICAgICBhbmQgY29kZSB0aGF0IG1hdGNoZXMgb24gW1Byb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbF0gZG9lc24ndCBjYXJlIGFib3V0XG4gICAgICAgdGhlbSBhbnl3YXkuICopXG4gICAgbGV0IGNhc3RfcHJvbWlzZV9saXN0IDogJ2EgdCBsaXN0IC0+ICgnYSwgXywgXykgcHJvbWlzZSBsaXN0ID0gT2JqLm1hZ2ljIGluXG4gICAgUHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIChjYXN0X3Byb21pc2VfbGlzdCBwcylcblxuXG5cbiAgbGV0IHdhaXQgKCkgPVxuICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Tm90X2NhbmNlbGFibGUgaW5cbiAgICB0b19wdWJsaWNfcHJvbWlzZSBwLCB0b19wdWJsaWNfcmVzb2x2ZXIgcFxuXG4gIGxldCB0YXNrICgpID1cbiAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOkNhbmNlbF90aGlzX3Byb21pc2UgaW5cbiAgICB0b19wdWJsaWNfcHJvbWlzZSBwLCB0b19wdWJsaWNfcmVzb2x2ZXIgcFxuXG5cblxuXG4gIGxldCBjYXN0X3NlcXVlbmNlX25vZGVcbiAgICAgIChub2RlIDogJ2EgdSBMd3Rfc2VxdWVuY2Uubm9kZSlcbiAgICAgIChfYWN0dWFsX2NvbnRlbnQ6KCdhLCAndSwgJ2MpIHByb21pc2UpXG4gICAgICAgIDogKCdhLCAndSwgJ2MpIHByb21pc2UgTHd0X3NlcXVlbmNlLm5vZGUgPVxuICAgIE9iai5tYWdpYyBub2RlXG5cbiAgbGV0IGFkZF90YXNrX3Igc2VxdWVuY2UgPVxuICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Q2FuY2VsX3RoaXNfcHJvbWlzZSBpblxuICAgIGxldCBub2RlID0gTHd0X3NlcXVlbmNlLmFkZF9yICh0b19wdWJsaWNfcmVzb2x2ZXIgcCkgc2VxdWVuY2UgaW5cbiAgICBsZXQgbm9kZSA9IGNhc3Rfc2VxdWVuY2Vfbm9kZSBub2RlIHAgaW5cblxuICAgIGxldCBQZW5kaW5nIGNhbGxiYWNrcyA9IHAuc3RhdGUgaW5cbiAgICBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcyA8LVxuICAgICAgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfcmVtb3ZlX3NlcXVlbmNlX25vZGUgbm9kZTtcblxuICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICBsZXQgYWRkX3Rhc2tfbCBzZXF1ZW5jZSA9XG4gICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpDYW5jZWxfdGhpc19wcm9taXNlIGluXG4gICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX2wgKHRvX3B1YmxpY19yZXNvbHZlciBwKSBzZXF1ZW5jZSBpblxuICAgIGxldCBub2RlID0gY2FzdF9zZXF1ZW5jZV9ub2RlIG5vZGUgcCBpblxuXG4gICAgbGV0IFBlbmRpbmcgY2FsbGJhY2tzID0gcC5zdGF0ZSBpblxuICAgIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzIDwtXG4gICAgICBDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSBub2RlO1xuXG4gICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG5cblxuICBsZXQgcHJvdGVjdGVkIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwX2ludGVybmFsID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcF9pbnRlcm5hbCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT4gcFxuICAgIHwgUmVqZWN0ZWQgXyAtPiBwXG5cbiAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgbGV0IHAnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Q2FuY2VsX3RoaXNfcHJvbWlzZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnID0gbWF5X25vd19iZV9wcm94eSBwJyBpblxuICAgICAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHAnIGluXG4gICAgICAgICgqIEluIHRoaXMgY2FsbGJhY2ssIFtwJ10gd2lsbCBlaXRoZXIgc3RpbGwgaXRzZWxmIGJlIHBlbmRpbmcsIG9yIGl0XG4gICAgICAgICAgIHdpbGwgaGF2ZSBiZWNvbWUgYSBwcm94eSBmb3IgYSBwZW5kaW5nIHByb21pc2UuIFRoZSByZWFzb25pbmcgZm9yXG4gICAgICAgICAgIHRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIGluIHRoZSBjb21tZW50IGF0IFttYXlfbm93X2JlX3Byb3h5XS4gVGhlXG4gICAgICAgICAgIGRpZmZlcmVuY2VzIGFyZTpcblxuICAgICAgICAgICAtIFtwJ10gKmlzKiBhbiBpbml0aWFsIHByb21pc2UsIHNvIGl0ICpjYW4qIGdldCBjYW5jZWxlZC4gSG93ZXZlciwgaWZcbiAgICAgICAgICAgICBpdCBkb2VzLCB0aGUgW29uX2NhbmNlbF0gaGFuZGxlciBpbnN0YWxsZWQgYmVsb3cgd2lsbCByZW1vdmUgdGhpc1xuICAgICAgICAgICAgIGNhbGxiYWNrLlxuICAgICAgICAgICAtIFtwJ10gbmV2ZXIgZ2V0cyBwYXNzZWQgdG8gW21ha2VfaW50b19wcm94eV0sIHRoZSBvbmx5IGVmZmVjdCBvZlxuICAgICAgICAgICAgIHdoaWNoIGlzIHRoYXQgaXQgY2Fubm90IGJlIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgYW5vdGhlclxuICAgICAgICAgICAgIChwcm94eSkgcHJvbWlzZS4gU28sIFtwJ10gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSBoZWFkIG9mIGEgY2hhaW4gb2ZcbiAgICAgICAgICAgICBbUHJveHkgX10gbGlua3MsIGFuZCBpdCdzIG5vdCBuZWNlc3NhcnkgdG8gd29ycnkgYWJvdXQgd2hldGhlciB0aGVcbiAgICAgICAgICAgICBpbmR1Y3RpdmUgcmVhc29uaW5nIGF0IFttYXlfbm93X2JlX3Byb3h5XSBhcHBsaWVzLiAqKVxuXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcgcF9yZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHAnXG4gICAgICBpblxuXG4gICAgICBsZXQgcmVtb3ZlX3RoZV9jYWxsYmFjayA9XG4gICAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19hbmRfZ2l2ZV9yZW1vdmVfZnVuY3Rpb25cbiAgICAgICAgICBbcF0gY2FsbGJhY2tcbiAgICAgIGluXG5cbiAgICAgIGxldCBQZW5kaW5nIHAnX2NhbGxiYWNrcyA9IHAnLnN0YXRlIGluXG4gICAgICBhZGRfY2FuY2VsX2NhbGxiYWNrIHAnX2NhbGxiYWNrcyByZW1vdmVfdGhlX2NhbGxiYWNrO1xuXG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSBwJ1xuXG4gIGxldCBub19jYW5jZWwgcCA9XG4gICAgbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPiBwXG4gICAgfCBSZWplY3RlZCBfIC0+IHBcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IHAnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Tm90X2NhbmNlbGFibGUgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJyA9IG1heV9ub3dfYmVfcHJveHkgcCcgaW5cbiAgICAgICAgbGV0IHAnID0gdW5kZXJseWluZyBwJyBpblxuICAgICAgICAoKiBJbiB0aGlzIGNhbGxiYWNrLCBbcCddIHdpbGwgZWl0aGVyIHN0aWxsIGl0c2VsZiBiZSBwZW5kaW5nLCBvciBpdFxuICAgICAgICAgICB3aWxsIGhhdmUgYmVjb21lIGEgcHJveHkgZm9yIGEgcGVuZGluZyBwcm9taXNlLiBUaGUgcmVhc29uaW5nIGZvclxuICAgICAgICAgICB0aGlzIGlzIGFzIGluIFtwcm90ZWN0ZWRdIGFuZCBbbWF5X25vd19iZV9wcm94eV0sIGJ1dCBldmVuIHNpbXBsZXIsXG4gICAgICAgICAgIGJlY2F1c2UgW3AnXSBpcyBub3QgY2FuY2VsYWJsZS4gKilcblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJyA9XG4gICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnIHBfcmVzdWx0IGluXG4gICAgICAgIGlnbm9yZSBwJ1xuICAgICAgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHAnXG5lbmRcbmluY2x1ZGUgUGVuZGluZ19wcm9taXNlc1xuXG5cblxubW9kdWxlIFNlcXVlbnRpYWxfY29tcG9zaXRpb24gOlxuc2lnXG4gICgqIE1haW4gaW50ZXJmYWNlIChwdWJsaWMpICopXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICB2YWwgbWFwIDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuICB2YWwgY2F0Y2ggOiAodW5pdCAtPiAnYSB0KSAtPiAoZXhuIC0+ICdhIHQpIC0+ICdhIHRcbiAgdmFsIGZpbmFsaXplIDogKHVuaXQgLT4gJ2EgdCkgLT4gKHVuaXQgLT4gdW5pdCB0KSAtPiAnYSB0XG4gIHZhbCB0cnlfYmluZCA6ICh1bml0IC0+ICdhIHQpIC0+ICgnYSAtPiAnYiB0KSAtPiAoZXhuIC0+ICdiIHQpIC0+ICdiIHRcblxuICAoKiBDYW5jZWwgY2FsbGJhY2tzIChwdWJsaWMpLiAqKVxuICB2YWwgb25fY2FuY2VsIDogJ2EgdCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCogTm9uLXByb21pc2UgY2FsbGJhY2tzIChwdWJsaWMpICopXG4gIHZhbCBvbl9zdWNjZXNzIDogJ2EgdCAtPiAoJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgb25fZmFpbHVyZSA6IF8gdCAtPiAoZXhuIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG9uX3Rlcm1pbmF0aW9uIDogXyB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG9uX2FueSA6ICdhIHQgLT4gKCdhIC0+IHVuaXQpIC0+IChleG4gLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqIEJhY2t0cmFjZSBzdXBwb3J0IChpbnRlcm5hbDsgZm9yIHVzZSBieSB0aGUgUFBYKSAqKVxuICB2YWwgYmFja3RyYWNlX2JpbmQgOlxuICAgIChleG4gLT4gZXhuKSAtPiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG4gIHZhbCBiYWNrdHJhY2VfY2F0Y2ggOlxuICAgIChleG4gLT4gZXhuKSAtPiAodW5pdCAtPiAnYSB0KSAtPiAoZXhuIC0+ICdhIHQpIC0+ICdhIHRcbiAgdmFsIGJhY2t0cmFjZV9maW5hbGl6ZSA6XG4gICAgKGV4biAtPiBleG4pIC0+ICh1bml0IC0+ICdhIHQpIC0+ICh1bml0IC0+IHVuaXQgdCkgLT4gJ2EgdFxuICB2YWwgYmFja3RyYWNlX3RyeV9iaW5kIDpcbiAgICAoZXhuIC0+IGV4bikgLT4gKHVuaXQgLT4gJ2EgdCkgLT4gKCdhIC0+ICdiIHQpIC0+IChleG4gLT4gJ2IgdCkgLT4gJ2IgdFxuZW5kID1cbnN0cnVjdFxuICAoKiBUaGVyZSBhcmUgZml2ZSBwcmltYXJ5IHNlcXVlbnRpYWwgY29tcG9zaXRpb24gZnVuY3Rpb25zOiBbYmluZF0sIFttYXBdLFxuICAgICBbY2F0Y2hdLCBbZmluYWxpemVdLCBhbmQgW3RyeV9iaW5kXS4gT2YgdGhlc2UsIFt0cnlfYmluZF0gaXMgdGhlIG1vc3RcbiAgICAgZ2VuZXJhbCAtLSBhbGwgdGhlIG90aGVycyBjYW4gYmUgaW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgaXQuXG5cbiAgICAgTHd0IGNvbmZsYXRlcyBjb25jdXJyZW5jeSB3aXRoIGVycm9yIHByb3BhZ2F0aW9uLiBJZiBMd3QgZGlkIG5vdCBkbyB0aGlzLFxuICAgICB0aGVyZSB3b3VsZCBiZSBvbmx5IHR3byBwcmltYXJ5IGZ1bmN0aW9uczogW2JpbmRdIGFuZCBbbWFwXSwgYW5kLCBvZiB0aGVzZVxuICAgICB0d28sIFtiaW5kXSBpcyB0aGUgbW9zdCBnZW5lcmFsLiBTaW5jZSBbYmluZF0gaXMgdGhlIG1vc3QgcmVsZXZhbnRcbiAgICAgc3BlY2lmaWNhbGx5IHRvIGNvbmN1cnJlbmN5LCBhbmQgaXMgYWxzbyB0aGUgbW9zdCBmYW1pbGlhciBmdW5jdGlvbiBpbiBMd3QsXG4gICAgIGl0cyBpbXBsZW1lbnRhdGlvbiBzZXJ2ZXMgYXMgYSBraW5kIG9mIFwibW9kZWxcIiBmb3IgdGhlIHJlc3QuIEl0IGlzIHRoZSBtb3N0XG4gICAgIGNvbW1lbnRlZCwgYW5kIGFsbCB0aGUgb3RoZXIgZnVuY3Rpb25zIGZvbGxvdyBhIHNpbWlsYXIgcGF0dGVybiB0byBbYmluZF0uXG5cbiAgICAgRm91ciBvZiB0aGUgcHJpbWFyeSBmdW5jdGlvbnMgaGF2ZSBbYmFja3RyYWNlXypdIHZlcnNpb25zLCB3aGljaCBhcmUgbm90XG4gICAgIHRydWx5IHB1YmxpYywgYW5kIGV4aXN0IHRvIHN1cHBvcnQgdGhlIFBQWC4gW2JhY2t0cmFjZV9tYXBdIGRvZXMgbm90IGV4aXN0XG4gICAgIGJlY2F1c2UgdGhlIFBQWCBkb2VzIG5vdCBuZWVkIGl0LlxuXG4gICAgIFRoZSByZW1haW5pbmcgZm91ciBmdW5jdGlvbnMgaW4gdGhpcyBzZWN0aW9uIGF0dGFjaCBcImxvd2VyLWxldmVsLWlzaFwiXG4gICAgIG5vbi1wcm9taXNlLXByb2R1Y2luZyBjYWxsYmFja3MgdG8gcHJvbWlzZXM6IHRoZXNlIGFyZSB0aGUgW29uXypdXG4gICAgIGZ1bmN0aW9ucy4gT2YgdGhlc2UsIFtvbl9hbnldIGlzIHRoZSBtb3N0IGdlbmVyYWwuIElmIEx3dCBkaWQgbm90IGNvbmZsYXRlXG4gICAgIGNvbmN1cnJlbmN5IHdpdGggZXJyb3IgaGFuZGxpbmcsIHRoZXJlIHdvdWxkIG9ubHkgYmUgb25lOiBbb25fc3VjY2Vzc10uICopXG5cblxuXG4gICgqIE1ha2VzIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSBpbnRvIGEgcHJveHkgb2YgW35vdXRlcl9wcm9taXNlXS4gQWZ0ZXJcbiAgICAgW21ha2VfaW50b19wcm94eV0sIHRoZXNlIHR3byBwcm9taXNlIHJlZmVyZW5jZXMgXCJiZWhhdmUgaWRlbnRpY2FsbHkuXCJcblxuICAgICBOb3RlIHRoYXQgdGhpcyBpcyBub3Qgc3ltbWV0cmljOiBbdXNlcl9wcm92aWRlZF9wcm9taXNlXSBhbHdheXMgYmVjb21lcyB0aGVcbiAgICAgcHJveHkuIFttYWtlX2ludG9fcHJveHldIGlzIGNhbGxlZCBvbmx5IGJ5IFtiaW5kXSBhbmQgc2ltaWxhciBmdW5jdGlvbnMgaW5cbiAgICAgdGhpcyBtb2R1bGUuIFRoaXMgbWVhbnMgdGhhdDpcblxuICAgICAtIHRoZSBvbmx5IHdheSBmb3IgYSBwcm9taXNlIHRvIGJlY29tZSBhIHByb3h5IGlzIGJ5IGJlaW5nIHJldHVybmVkIGZyb21cbiAgICAgICB0aGUgY2FsbGJhY2sgZ2l2ZW4gYnkgdGhlIHVzZXIgdG8gW2JpbmRdLCBvciBhIHNpbWlsYXIgZnVuY3Rpb24sIGFuZFxuICAgICAtIHRoZSBvbmx5IHdheSBmb3IgYSBwcm9taXNlIHRvIGJlY29tZSB1bmRlcmx5aW5nIGZvciBhIHByb21pc2Ugb3RoZXIgdGhhblxuICAgICAgIGl0c2VsZiBpcyB0byBiZSB0aGUgb3V0ZXIgcHJvbWlzZSBvcmlnaW5hbGx5IHJldHVybmVkIHRvIHRoZSB1c2VyIGZyb21cbiAgICAgICBbYmluZF0sIG9yIGEgc2ltaWxhciBmdW5jdGlvbi5cblxuICAgICBUaGVzZSB0d28gZmFjdHMgYXJlIGltcG9ydGFudCBmb3IgcmVhc29uaW5nIGFib3V0IGhvdyBhbmQgd2hpY2ggcHJvbWlzZXNcbiAgICAgY2FuIGJlY29tZSBwcm94aWVzLCB1bmRlcmx5aW5nLCBldGMuOyBpbiBwYXJ0aWN1bGFyLCBpdCBpcyB1c2VkIGluIHRoZVxuICAgICBhcmd1bWVudCBpbiBbbWF5X25vd19iZV9wcm94eV0gZm9yIGNvcnJlY3QgcHJlZGljdGlvbnMgYWJvdXQgc3RhdGUgY2hhbmdlcy5cblxuICAgICBbfm91dGVyX3Byb21pc2VdIGlzIGFsd2F5cyBhIHBlbmRpbmcgcHJvbWlzZSB3aGVuIFttYWtlX2ludG9fcHJveHldIGlzXG4gICAgIGNhbGxlZDsgZm9yIHRoZSBleHBsYW5hdGlvbiwgc2VlIFttYXlfbm93X2JlX3Byb3h5XSAodGhvdWdoIHRoZSBjYWxsZXIgb2ZcbiAgICAgW21ha2VfaW50b19wcm94eV0gYWx3YXlzIGNhbGxzIFt1bmRlcmx5aW5nXSBmaXJzdCB0byBwYXNzIHRoZSB1bmRlcmx5aW5nXG4gICAgIHBlbmRpbmcgcHJvbWlzZSB0byBbbWFrZV9pbnRvX3Byb3h5XSkuXG5cbiAgICAgVGhlIHJlYXNvbnMgcHJveHlpbmcgaXMgdXNlZCwgaW5zdGVhZCBvZiBhZGRpbmcgYSBjYWxsYmFjayB0b1xuICAgICBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gdG8gcmVzb2x2ZSBbfm91dGVyX3Byb21pc2VdIHdoZW4gdGhlIGZvcm1lclxuICAgICBiZWNvbWVzIHJlc29sdmVkIHByb2JhYmx5IGFyZTpcblxuICAgICAtIFByb21pc2VzIGhhdmUgbW9yZSBiZWhhdmlvcnMgdGhhbiByZXNvbHV0aW9uLiBPbmUgd291bGQgaGF2ZSB0byBhZGQgYVxuICAgICAgIGNhbmNlbGxhdGlvbiBoYW5kbGVyIHRvIFt+b3V0ZXJfcHJvbWlzZV0gdG8gcHJvcGFnYXRlIHRoZSBjYW5jZWxsYXRpb25cbiAgICAgICBiYWNrIHRvIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSwgZm9yIGV4YW1wbGUuIEl0IG1heSBiZSBlYXNpZXIgdG8ganVzdFxuICAgICAgIHRoaW5rIG9mIHRoZW0gYXMgdGhlIHNhbWUgcHJvbWlzZS5cbiAgICAgLSBJZiB1c2luZyBjYWxsYmFja3MsIHJlc29sdmluZyBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gd291bGQgbm90XG4gICAgICAgaW1tZWRpYXRlbHkgcmVzb2x2ZSBbfm91dGVyX3Byb21pc2VdLiBBbm90aGVyIGNhbGxiYWNrIGFkZGVkIHRvXG4gICAgICAgW351c2VyX3Byb3ZpZGVkX3Byb21pc2VdIG1pZ2h0IHNlZSBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gcmVzb2x2ZWQsXG4gICAgICAgYnV0IFt+b3V0ZXJfcHJvbWlzZV0gc3RpbGwgcGVuZGluZywgZGVwZW5kaW5nIG9uIHRoZSBvcmRlciBpbiB3aGljaFxuICAgICAgIGNhbGxiYWNrcyBhcmUgcnVuLiAqKVxuICBsZXQgbWFrZV9pbnRvX3Byb3h5XG4gICAgICAodHlwZSBjKVxuICAgICAgfihvdXRlcl9wcm9taXNlIDogKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlKVxuICAgICAgfih1c2VyX3Byb3ZpZGVkX3Byb21pc2UgOiAoJ2EsIF8sIGMpIHByb21pc2UpXG4gICAgICAgIDogKCdhLCB1bmRlcmx5aW5nLCBjKSBzdGF0ZV9jaGFuZ2VkID1cblxuICAgICgqIFVzaW5nIFtwJ10gYXMgaXQncyB0aGUgbmFtZSB1c2VkIGluc2lkZSBbYmluZF0sIGV0Yy4sIGZvciBwcm9taXNlcyB3aXRoXG4gICAgICAgdGhpcyByb2xlIC0tIFtwJ10gaXMgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIHVzZXIncyBmdW5jdGlvbi4gKilcbiAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHVzZXJfcHJvdmlkZWRfcHJvbWlzZSBpblxuXG4gICAgaWYgaWRlbnRpY2FsIHAnIG91dGVyX3Byb21pc2UgdGhlblxuICAgICAgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJ1xuICAgICAgKCogV2UgcmVhbGx5IHdhbnQgdG8gcmV0dXJuIFtTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIG91dGVyX3Byb21pc2VdLCBidXRcbiAgICAgICAgIHRoZSByZWZlcmVuY2UgdGhyb3VnaCBbcCddIGhhcyB0aGUgcmlnaHQgdHlwZS4gKilcblxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHAnLnN0YXRlIHdpdGhcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIG91dGVyX3Byb21pc2UgcCcuc3RhdGVcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2Ugb3V0ZXJfcHJvbWlzZSBwJy5zdGF0ZVxuXG4gICAgICB8IFBlbmRpbmcgcCdfY2FsbGJhY2tzIC0+XG4gICAgICAgIGxldCBQZW5kaW5nIG91dGVyX2NhbGxiYWNrcyA9IG91dGVyX3Byb21pc2Uuc3RhdGUgaW5cblxuICAgICAgICBtZXJnZV9jYWxsYmFja3MgfmZyb206cCdfY2FsbGJhY2tzIH5pbnRvOm91dGVyX2NhbGxiYWNrcztcbiAgICAgICAgb3V0ZXJfY2FsbGJhY2tzLmhvd190b19jYW5jZWwgPC0gcCdfY2FsbGJhY2tzLmhvd190b19jYW5jZWw7XG5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcgPVxuICAgICAgICAgIHNldF9wcm9taXNlX3N0YXRlIHAnIChQcm94eSBvdXRlcl9wcm9taXNlKSBpblxuICAgICAgICBpZ25vcmUgcCc7XG5cbiAgICAgICAgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBvdXRlcl9wcm9taXNlXG4gICAgICAgICgqIFRoZSBzdGF0ZSBoYXNuJ3QgYWN0dWFsbHkgY2hhbmdlZCwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gd3JhcFxuICAgICAgICAgICBbb3V0ZXJfcHJvbWlzZV0gZm9yIHR5cGUgY2hlY2tpbmcuICopXG5cbiAgICAgICAgKCogVGhlIHN0YXRlIG9mIFtwJ10gbWF5IGluc3RlYWQgaGF2ZSBjaGFuZ2VkIC0tIGl0IG1heSBoYXZlIGJlY29tZSBhXG4gICAgICAgICAgIHByb3h5LiBIb3dldmVyLCBjYWxsZXJzIG9mIFttYWtlX2ludG9fcHJveHldIGRvbid0IGtub3cgaWZcbiAgICAgICAgICAgW3VzZXJfcHJvdmlkZWRfcHJvbWlzZV0gd2FzIGEgcHJveHkgb3Igbm90ICh0aGF0J3Mgd2h5IHdlIGNhbGxcbiAgICAgICAgICAgdW5kZXJseWluZyBvbiBpdCBhdCB0aGUgdG9wIG9mIHRoaXMgZnVuY3Rpb24sIHRvIGdldCBbcCddKS4gV2UgY2FuXG4gICAgICAgICAgIHRoZXJlZm9yZSB0YWtlIGEgZGFuZ2Vyb3VzIHNob3J0Y3V0IGFuZCBub3QgYm90aGVyIHJldHVybmluZyBhIG5ld1xuICAgICAgICAgICByZWZlcmVuY2UgdG8gW3VzZXJfcHJvdmlkZWRfcHJvbWlzZV0gZm9yIHNoYWRvd2luZy4gKilcblxuXG5cbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IGEgbG90IG9mIHRoZSBjb2RlIGJlbG93IGNhbiBwcm9iYWJseSBiZSBkZWR1cGxpY2F0ZWQgaW5cbiAgICAgc29tZSB3YXksIGVzcGVjaWFsbHkgaWYgYXNzdW1pbmcgRmxhbWJkYS4gKilcblxuICBsZXQgYmluZCBwIGYgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgICgqIEluIGNhc2UgW0x3dC5iaW5kXSBuZWVkcyB0byBkZWZlciB0aGUgY2FsbCB0byBbZl0sIHRoaXMgZnVuY3Rpb24gd2lsbCBiZVxuICAgICAgIGNhbGxlZCB0byBjcmVhdGU6XG5cbiAgICAgICAxLiBUaGUgcHJvbWlzZSwgW3AnJ10sIHRoYXQgbXVzdCBiZSByZXR1cm5lZCB0byB0aGUgY2FsbGVyIGltbWVkaWF0ZWx5LlxuICAgICAgIDIuIFRoZSBjYWxsYmFjayB0aGF0IHJlc29sdmVzIFtwJyddLlxuXG4gICAgICAgW0x3dC5iaW5kXSBkZWZlcnMgdGhlIGNhbGwgdG8gW2ZdIGluIHR3byBjaXJjdW1zdGFuY2VzOlxuXG4gICAgICAgMS4gVGhlIHByb21pc2UgW3BdIGlzIHBlbmRpbmcuXG4gICAgICAgMi4gVGhlIHByb21pc2UgW3BdIGlzIGZ1bGZpbGxlZCwgYnV0IHRoZSBjdXJyZW50IGNhbGxiYWNrIGNhbGwgbmVzdGluZ1xuICAgICAgICAgIGRlcHRoIGlzIHN1Y2ggdGhhdCB0aGUgY2FsbCB0byBbZl0gbXVzdCBnbyBpbnRvIHRoZSBjYWxsYmFjayBxdWV1ZSwgaW5cbiAgICAgICAgICBvcmRlciB0byBhdm9pZCBzdGFjayBvdmVyZmxvdy5cblxuICAgICAgTWVjaGFuaXNtICgyKSBpcyBjdXJyZW50bHkgZGlzYWJsZWQuIEl0IG1heSBiZSB1c2VkIGluIGFuIGFsdGVybmF0aXZlIEx3dFxuICAgICAgQVBJLlxuXG4gICAgICBGdW5jdGlvbnMgb3RoZXIgdGhhbiBbTHd0LmJpbmRdIGhhdmUgYW5hbG9nb3VzIGRlZmVycmFsIGJlaGF2aW9yLiAqKVxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cbiAgICAgICgqIFRoZSByZXN1bHQgcHJvbWlzZSBpcyBhIGZyZXNoIHBlbmRpbmcgcHJvbWlzZS5cblxuICAgICAgICAgSW5pdGlhbGx5LCB0cnlpbmcgdG8gY2FuY2VsIHRoaXMgZnJlc2ggcGVuZGluZyBwcm9taXNlIFtwJyddIHdpbGxcbiAgICAgICAgIHByb3BhZ2F0ZSB0aGUgY2FuY2VsbGF0aW9uIGF0dGVtcHQgdG8gW3BdIChiYWNrd2FyZHMgdGhyb3VnaCB0aGVcbiAgICAgICAgIHByb21pc2UgZGVwZW5kZW5jeSBncmFwaCkuIElmL3doZW4gW3BdIGlzIGZ1bGZpbGxlZCwgTHd0IHdpbGwgY2FsbCB0aGVcbiAgICAgICAgIHVzZXIncyBjYWxsYmFjayBbZl0gYmVsb3csIHdoaWNoIHdpbGwgcHJvdmlkZSBhIG5ldyBwcm9taXNlIFtwJ10sIGFuZFxuICAgICAgICAgW3AnXSB3aWxsIGJlY29tZSBhIHByb3h5IG9mIFtwJyddLiBBdCB0aGF0IHBvaW50LCB0cnlpbmcgdG8gY2FuY2VsXG4gICAgICAgICBbcCcnXSB3aWxsIGJlIGVxdWl2YWxlbnQgdG8gdHJ5aW5nIHRvIGNhbmNlbCBbcCddLCBzbyB0aGUgYmVoYXZpb3Igd2lsbFxuICAgICAgICAgZGVwZW5kIG9uIGhvdyB0aGUgdXNlciBvYnRhaW5lZCBbcCddLiAqKVxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGYgdiB3aXRoIGV4blxuICAgICAgICAgICAgd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cbiAgICAgICAgICAoKiBSdW4gdGhlIHVzZXIncyBmdW5jdGlvbiBbZl0uICopXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG4gICAgICAgICAgKCogW3AnJ10gd2FzIGFuIHVuZGVybHlpbmcgcHJvbWlzZSB3aGVuIGl0IHdhcyBjcmVhdGVkIGFib3ZlLCBidXQgaXRcbiAgICAgICAgICAgICBtYXkgaGF2ZSBiZWNvbWUgYSBwcm94eSBieSB0aGUgdGltZSB0aGlzIGNvZGUgaXMgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICAgICAgICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgZWl0aGVyIGFuIHVuZGVybHlpbmcgcGVuZGluZyBwcm9taXNlLCBvciBhXG4gICAgICAgICAgICAgcHJveHkgZm9yIGEgcGVuZGluZyBwcm9taXNlLiBUaGVyZWZvcmUsIFttYXlfbm93X2JlX3Byb3h5XSBwcm9kdWNlc1xuICAgICAgICAgICAgIGEgcmVmZXJlbmNlIHdpdGggdGhlIHJpZ2h0IHR5cGUgdmFyaWFibGVzLiBXZSBpbW1lZGlhdGVseSBnZXRcbiAgICAgICAgICAgICBbcCcnXSdzIGN1cnJlbnQgdW5kZXJseWluZyBwcm9taXNlLiAqKVxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgICAgICAoKiBNYWtlIHRoZSBvdXRlciBwcm9taXNlIFtwJyddIGJlaGF2aW9yYWxseSBpZGVudGljYWwgdG8gdGhlIHByb21pc2VcbiAgICAgICAgICAgICBbcCddIHJldHVybmVkIGJ5IFtmXSBieSBtYWtpbmcgW3AnXSBpbnRvIGEgcHJveHkgb2YgW3AnJ10uICopXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHBfcmVzdWx0IC0+XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcF9yZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBmIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgKHAnJywgY2FsbGJhY2spID0gY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgIHAnJ1xuXG4gIGxldCBiYWNrdHJhY2VfYmluZCBhZGRfbG9jIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGYgdlxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT5cbiAgICAgICAgICAgICAgZmFpbCAoYWRkX2xvYyBleG4pIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIChSZWplY3RlZCAoYWRkX2xvYyBleG4pKSBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYgdilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgKGFkZF9sb2MgZXhuKX1cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgbWFwIGYgcCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcnX3Jlc3VsdCA9XG4gICAgICAgICAgICB0cnkgRnVsZmlsbGVkIChmIHYpIHdpdGggZXhuXG4gICAgICAgICAgICB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBSZWplY3RlZCBleG5cbiAgICAgICAgICBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcCcnX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcF9yZXN1bHQgLT5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyBwX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2VcbiAgICAgICAgICAgIHtzdGF0ZSA9XG4gICAgICAgICAgICAgIHRyeSBGdWxmaWxsZWQgKGYgdilcbiAgICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gUmVqZWN0ZWQgZXhufSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPSBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgcCcnXG5cbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuXG4gIGxldCBjYXRjaCBmIGggPVxuICAgIGxldCBwID1cbiAgICAgIHRyeSBmICgpXG4gICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIGFzIHBfcmVzdWx0IC0+XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcF9yZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgaCBleG5cbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgaW5cblxuICAgICAgKHRvX3B1YmxpY19wcm9taXNlIHAnJywgY2FsbGJhY2spXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGggZXhuKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgYmFja3RyYWNlX2NhdGNoIGFkZF9sb2MgZiBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyBhcyBwX3Jlc3VsdCAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIHBfcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGggZXhuXG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgICAgICAgICBmYWlsIChhZGRfbG9jIGV4bilcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCAoYWRkX2xvYyBleG4pKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgdHJ5X2JpbmQgZiBmJyBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBmJyB2XG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBoIGV4blxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBmJyB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGggZXhuKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgYmFja3RyYWNlX3RyeV9iaW5kIGFkZF9sb2MgZiBmJyBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBmJyB2XG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgICAgICAgICBmYWlsIChhZGRfbG9jIGV4bilcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgaCBleG5cbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICAgICAgICAgIGZhaWwgKGFkZF9sb2MgZXhuKVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYnIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCAoYWRkX2xvYyBleG4pKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgZmluYWxpemUgZiBmJyA9XG4gICAgdHJ5X2JpbmQgZlxuICAgICAgKGZ1biB4IC0+IGJpbmQgKGYnICgpKSAoZnVuICgpIC0+IHJldHVybiB4KSlcbiAgICAgIChmdW4gZSAtPiBiaW5kIChmJyAoKSkgKGZ1biAoKSAtPiBmYWlsIGUpKVxuXG4gIGxldCBiYWNrdHJhY2VfZmluYWxpemUgYWRkX2xvYyBmIGYnID1cbiAgICBiYWNrdHJhY2VfdHJ5X2JpbmQgYWRkX2xvYyBmXG4gICAgICAoZnVuIHggLT4gYmluZCAoZicgKCkpIChmdW4gKCkgLT4gcmV0dXJuIHgpKVxuICAgICAgKGZ1biBlIC0+IGJpbmQgKGYnICgpKSAoZnVuICgpIC0+IGZhaWwgKGFkZF9sb2MgZSkpKVxuXG5cblxuICBsZXQgb25fY2FuY2VsIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBSZWplY3RlZCBDYW5jZWxlZCAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgICgoKSwgKGZ1biBfIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgKCkpLCBGdWxmaWxsZWQgKCkpKVxuXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAoKVxuXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcblxuICAgIHwgUGVuZGluZyBjYWxsYmFja3MgLT5cbiAgICAgIGFkZF9jYW5jZWxfY2FsbGJhY2sgY2FsbGJhY2tzIGZcblxuXG5cbiAgbGV0IG9uX3N1Y2Nlc3MgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biByZXN1bHQgLT5cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgdlxuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICgpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IG9uX2ZhaWx1cmUgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biByZXN1bHQgLT5cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIGV4blxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAoKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiBleG4pXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAoKCksIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuICBsZXQgb25fdGVybWluYXRpb24gcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biBfcmVzdWx0IC0+XG4gICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IG9uX2FueSBwIGYgZyA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBmdW4gcmVzdWx0IC0+XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIHZcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGcgZXhuXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBnIGV4bilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuZW5kXG5pbmNsdWRlIFNlcXVlbnRpYWxfY29tcG9zaXRpb25cblxuXG4oKiBUaGlzIGJlbG9uZ3Mgd2l0aCB0aGUgW3Byb3RlY3RlZF0gYW5kIHN1Y2gsIGJ1dCBpdCBkZXBlbmRzIG9uIHByaW1pdGl2ZXMgZnJvbVxuICAgW1NlcXVlbnRpYWxfY29tcG9zaXRpb25dLiAqKVxubGV0IHdyYXBfaW5fY2FuY2VsYWJsZSBwID1cbiBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuIGxldCBwX3VuZGVybHlpbmcgPSB1bmRlcmx5aW5nIHBfaW50ZXJuYWwgaW5cbiBtYXRjaCBwX3VuZGVybHlpbmcuc3RhdGUgd2l0aFxuIHwgRnVsZmlsbGVkIF8gLT4gcFxuIHwgUmVqZWN0ZWQgXyAtPiBwXG4gfCBQZW5kaW5nIF8gLT5cbiAgIGxldCBwJywgciA9IHRhc2sgKCkgaW5cbiAgIG9uX2NhbmNlbCBwJyAoZnVuICgpIC0+IGNhbmNlbCBwKTtcbiAgIG9uX2FueSBwICh3YWtldXAgcikgKHdha2V1cF9leG4gcik7XG4gICBwJ1xuXG5cbm1vZHVsZSBDb25jdXJyZW50X2NvbXBvc2l0aW9uIDpcbnNpZ1xuICB2YWwgZG9udF93YWl0IDogKHVuaXQgLT4gXyB0KSAtPiAoZXhuIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGFzeW5jIDogKHVuaXQgLT4gXyB0KSAtPiB1bml0XG4gIHZhbCBpZ25vcmVfcmVzdWx0IDogXyB0IC0+IHVuaXRcblxuICB2YWwgYm90aCA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuICB2YWwgam9pbiA6IHVuaXQgdCBsaXN0IC0+IHVuaXQgdFxuICB2YWwgYWxsIDogKCdhIHQpIGxpc3QgLT4gKCdhIGxpc3QpIHRcblxuICB2YWwgY2hvb3NlIDogJ2EgdCBsaXN0IC0+ICdhIHRcbiAgdmFsIHBpY2sgOiAnYSB0IGxpc3QgLT4gJ2EgdFxuXG4gIHZhbCBuY2hvb3NlIDogJ2EgdCBsaXN0IC0+ICdhIGxpc3QgdFxuICB2YWwgbnBpY2sgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG5cbiAgdmFsIG5jaG9vc2Vfc3BsaXQgOiAnYSB0IGxpc3QgLT4gKCdhIGxpc3QgKiAnYSB0IGxpc3QpIHRcbmVuZCA9XG5zdHJ1Y3RcbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuXG4gIGxldCBkb250X3dhaXQgZiBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgaCBleG5cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgICAoKVxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGggZXhuXG4gICAgICBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuXG4gIGxldCBhc3luYyBmID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuICAgICAgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuICBsZXQgaWdub3JlX3Jlc3VsdCBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICgpXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJlcmFpc2UgZXhuXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayByZXN1bHQgPVxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAgICAgKClcbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICAhYXN5bmNfZXhjZXB0aW9uX2hvb2sgZXhuXG4gICAgICBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuXG5cblxuICBsZXQgam9pbiBwcyA9XG4gICAgbGV0IHAnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgIGxldCBudW1iZXJfcGVuZGluZ19pbl9wcyA9IHJlZiAwIGluXG4gICAgbGV0IGpvaW5fcmVzdWx0ID0gcmVmIChGdWxmaWxsZWQgKCkpIGluXG5cbiAgICAoKiBDYWxsYmFjayBhdHRhY2hlZCB0byBlYWNoIHByb21pc2UgaW4gW3BzXSB0aGF0IGlzIHN0aWxsIHBlbmRpbmcgYXQgdGhlXG4gICAgICAgdGltZSBbam9pbl0gaXMgY2FsbGVkLiAqKVxuICAgIGxldCBjYWxsYmFjayBuZXdfcmVzdWx0ID1cbiAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcgPSBtYXlfbm93X2JlX3Byb3h5IHAnIGluXG5cbiAgICAgIGJlZ2luIG1hdGNoIG5ld19yZXN1bHQgd2l0aFxuICAgICAgfCBGdWxmaWxsZWQgKCkgLT4gKClcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgKCogRm9yIHRoZSBmaXJzdCBwcm9taXNlIGluIFtwc10gdG8gYmUgcmVqZWN0ZWQsIHNldCB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAgICAgW2pvaW5dIHRvIHJlamVjdGVkIHdpdGggdGhlIHNhbWUgZXhjZXB0aW9uLi4gKilcbiAgICAgICAgbWF0Y2ggIWpvaW5fcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgKCkgLT4gam9pbl9yZXN1bHQgOj0gbmV3X3Jlc3VsdFxuICAgICAgICB8IFJlamVjdGVkIF8gLT4gKClcbiAgICAgIGVuZDtcblxuICAgICAgKCogSW4gYWxsIGNhc2VzLCBkZWNyZW1lbnQgdGhlIG51bWJlciBvZiBwcm9taXNlcyBzdGlsbCBwZW5kaW5nLCBhbmRcbiAgICAgICAgIHJlc29sdmUgdGhlIFtqb2luXSBvbmNlIGFsbCBwcm9taXNlcyByZXNvbHZlLiAqKVxuICAgICAgbnVtYmVyX3BlbmRpbmdfaW5fcHMgOj0gIW51bWJlcl9wZW5kaW5nX2luX3BzIC0gMTtcbiAgICAgIGlmICFudW1iZXJfcGVuZGluZ19pbl9wcyA9IDAgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHAnIGluXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgKHVuZGVybHlpbmcgcCcpICFqb2luX3Jlc3VsdCBpblxuICAgICAgICBpZ25vcmUgcCdcbiAgICAgIGVuZFxuICAgIGluXG5cbiAgICAoKiBBdHRhY2ggdGhlIGFib3ZlIGNhbGxiYWNrLiBTaW11bHRhbmVvdXNseSBjb3VudCBob3cgbWFueSBwZW5kaW5nIHByb21pc2VzXG4gICAgICAgdGhlcmUgYXJlIGluIFtwc10gKGluaXRpYWxseSkuIElmIHRoYXQgbnVtYmVyIGlzIHplcm8sIHRoZSBbam9pbl0gbXVzdFxuICAgICAgIHJlc29sdmUgaW1tZWRpYXRlbHkuICopXG4gICAgbGV0IHJlYyBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwcyA9XG4gICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGlmICFudW1iZXJfcGVuZGluZ19pbl9wcyA9IDAgdGhlblxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9ICFqb2luX3Jlc3VsdH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHAnXG5cbiAgICAgIHwgcDo6cHMgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgICAgIG51bWJlcl9wZW5kaW5nX2luX3BzIDo9ICFudW1iZXJfcGVuZGluZ19pbl9wcyArIDE7XG4gICAgICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgICAgICBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyBwX3Jlc3VsdCAtPlxuICAgICAgICAgICgqIEFzIGluIHRoZSBjYWxsYmFjayBhYm92ZSwgYnV0IGZvciBhbHJlYWR5LXJlc29sdmVkIHByb21pc2VzIGluXG4gICAgICAgICAgICAgW3BzXTogcmVqZWN0IHRoZSBbam9pbl0gd2l0aCB0aGUgc2FtZSBleGNlcHRpb24gYXMgaW4gdGhlIGZpcnN0XG4gICAgICAgICAgICAgcmVqZWN0ZWQgcHJvbWlzZSBmb3VuZC4gW2pvaW5dIHN0aWxsIHdhaXRzIGZvciBhbnkgcGVuZGluZyBwcm9taXNlc1xuICAgICAgICAgICAgIGJlZm9yZSBhY3R1YWxseSByZXNvbHZpbmcsIHRob3VnaC4gKilcbiAgICAgICAgICBiZWdpbiBtYXRjaCAham9pbl9yZXN1bHQgd2l0aFxuICAgICAgICAgIHwgRnVsZmlsbGVkICgpIC0+IGpvaW5fcmVzdWx0IDo9IHBfcmVzdWx0O1xuICAgICAgICAgIHwgUmVqZWN0ZWQgXyAtPiAoKVxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwc1xuXG4gICAgICAgIHwgRnVsZmlsbGVkICgpIC0+XG4gICAgICAgICAgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHNcbiAgICBpblxuXG4gICAgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHNcblxuICAoKiB0aGlzIGlzIDMgd29yZHMsIHNtYWxsZXIgdGhhbiB0aGUgMiB0aW1lcyAyIHdvcmRzIGEgcGFpciBvZiByZWZlcmVuY2VzXG4gICAgIHdvdWxkIHRha2UuICopXG4gIHR5cGUgKCdhLCdiKSBwYWlyID0ge1xuICAgIG11dGFibGUgeDE6ICdhIG9wdGlvbjtcbiAgICBtdXRhYmxlIHgyOiAnYiBvcHRpb247XG4gIH1cblxuICBsZXQgYm90aCBwMSBwMiA9XG4gICAgbGV0IHBhaXIgPSB7eDEgPSBOb25lOyB4MiA9IE5vbmV9IGluXG4gICAgbGV0IHAxJyA9IGJpbmQgcDEgKGZ1biB2IC0+IHBhaXIueDEgPC0gU29tZSB2OyByZXR1cm5fdW5pdCkgaW5cbiAgICBsZXQgcDInID0gYmluZCBwMiAoZnVuIHYgLT4gcGFpci54MiA8LSBTb21lIHY7IHJldHVybl91bml0KSBpblxuICAgIGpvaW4gW3AxJzsgcDInXSB8PiBtYXAgKGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggcGFpci54MSwgcGFpci54MiB3aXRoXG4gICAgICB8IFNvbWUgdjEsIFNvbWUgdjIgLT4gdjEsIHYyXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuXG4gIGxldCBhbGwgcHMgPVxuICAgIG1hdGNoIHBzIHdpdGhcbiAgICB8IFtdIC0+IHJldHVybl9uaWxcbiAgICB8IFt4XSAtPiBtYXAgKGZ1biB5IC0+IFt5XSkgeFxuICAgIHwgW3g7IHldIC0+IG1hcCAoZnVuICh4LCB5KSAtPiBbeDsgeV0pIChib3RoIHggeSlcbiAgICB8IF8gLT5cbiAgICAgIGxldCB2cyA9IEFycmF5Lm1ha2UgKExpc3QubGVuZ3RoIHBzKSBOb25lIGluXG4gICAgICBwc1xuICAgICAgfD4gTGlzdC5tYXBpIChmdW4gaW5kZXggcCAtPlxuICAgICAgICBiaW5kIHAgKGZ1biB2IC0+IHZzLihpbmRleCkgPC0gU29tZSB2OyByZXR1cm5fdW5pdCkpXG4gICAgICB8PiBqb2luXG4gICAgICB8PiBtYXAgKGZ1biAoKSAtPlxuICAgICAgICAgIGxldCByZWMgdG9fbGlzdF91bm9wdCBpIGFjYyA9XG4gICAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICAgIGFjY1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBBcnJheS51bnNhZmVfZ2V0IHZzIGkgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICAgIHwgU29tZSB4IC0+IHRvX2xpc3RfdW5vcHQgKGkgLSAxKSAoeDo6YWNjKVxuICAgICAgICAgIGluXG4gICAgICAgICAgdG9fbGlzdF91bm9wdCAoQXJyYXkubGVuZ3RoIHZzIC0gMSkgW10pXG5cbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IHRoZSBuZXh0IGZldyBmdW5jdGlvbnMgYXJlIGhlbHBlcnMgZm9yIFtjaG9vc2VdIGFuZFxuICAgICBbcGlja10uIFBlcmhhcHMgdGhleSBzaG91bGQgYmUgZmFjdG9yZWQgaW50byBzb21lIGtpbmQgb2YgZ2VuZXJpY1xuICAgICBbY2hvb3NlXS9bcGlja10gaW1wbGVtZW50YXRpb24sIHdoaWNoIG1heSBhY3R1YWxseSBiZSBvcHRpbWFsIGFueXdheSB3aXRoXG4gICAgIEZsYW1iZGEuICopXG5cbiAgbGV0IGNvdW50X3Jlc29sdmVkX3Byb21pc2VzX2luIChwcyA6ICdhIHQgbGlzdCkgPVxuICAgIGxldCByZWMgY291bnRfYW5kX2dhdGhlcl9yZWplY3RlZCB0b3RhbCByZWplY3RlZCBwcyA9XG4gICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgIHwgW10gLT4gRXJyb3IgKHRvdGFsLCByZWplY3RlZClcbiAgICAgICB8IHAgOjogcHMgLT5cbiAgICAgICAgICAgIGxldCBJbnRlcm5hbCBxID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgICAgICBtYXRjaCAodW5kZXJseWluZyBxKS5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+IGNvdW50X2FuZF9nYXRoZXJfcmVqZWN0ZWQgdG90YWwgcmVqZWN0ZWQgcHNcbiAgICAgICAgICAgIHwgUmVqZWN0ZWQgXyAtPiBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkICh0b3RhbCArIDEpIChwIDo6IHJlamVjdGVkKSBwc1xuICAgICAgICAgICAgfCBQZW5kaW5nIF8gLT4gY291bnRfYW5kX2dhdGhlcl9yZWplY3RlZCB0b3RhbCByZWplY3RlZCBwc1xuICAgIGluXG4gICAgbGV0IHJlYyBjb3VudF9mdWxmaWxsZWQgdG90YWwgcHMgPVxuICAgICAgIG1hdGNoIHBzIHdpdGhcbiAgICAgICB8IFtdIC0+IE9rIHRvdGFsXG4gICAgICAgfCBwIDo6IHBzIC0+XG4gICAgICAgICAgICBsZXQgSW50ZXJuYWwgcSA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcSkuc3RhdGUgd2l0aFxuICAgICAgICAgICAgfCBGdWxmaWxsZWQgXyAtPiBjb3VudF9mdWxmaWxsZWQgKHRvdGFsICsgMSkgcHNcbiAgICAgICAgICAgIHwgUmVqZWN0ZWQgXyAtPiBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkIDEgW3BdIHBzXG4gICAgICAgICAgICB8IFBlbmRpbmcgXyAtPiBjb3VudF9mdWxmaWxsZWQgdG90YWwgcHNcbiAgICBpblxuICAgIGNvdW50X2Z1bGZpbGxlZCAwIHBzXG5cbiAgKCogRXZhbHVhdGVzIHRvIHRoZSBbbl10aCBwcm9taXNlIGluIFtwc10sIGFtb25nIG9ubHkgdGhvc2UgcHJvbWlzZXMgaW4gW3BzXVxuICAgICB0aGF0IGFyZSByZXNvbHZlZC4gVGhlIGNhbGxlciBpcyBleHBlY3RlZCB0byBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgYXRcbiAgICAgbGVhc3QgW25dIHJlc29sdmVkIHByb21pc2VzIGluIFtwc10uICopXG4gIGxldCByZWMgbnRoX3Jlc29sdmVkIChwcyA6ICdhIHQgbGlzdCkgKG4gOiBpbnQpIDogJ2EgdCA9XG4gICAgbWF0Y2ggcHMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG4gICAgfCBwOjpwcyAtPlxuICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICBtYXRjaCAodW5kZXJseWluZyBwJykuc3RhdGUgd2l0aFxuICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgbnRoX3Jlc29sdmVkIHBzIG5cblxuICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiBwXG4gICAgICAgIGVsc2UgbnRoX3Jlc29sdmVkIHBzIChuIC0gMSlcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiBwXG4gICAgICAgIGVsc2UgbnRoX3Jlc29sdmVkIHBzIChuIC0gMSlcblxuICAoKiBMaWtlIFtudGhfcmVzb2x2ZWRdLCBidXQgY2FuY2VscyBhbGwgcGVuZGluZyBwcm9taXNlcyBmb3VuZCB3aGlsZVxuICAgICB0cmF2ZXJzaW5nIFtwc10uICopXG4gIGxldCByZWMgbnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluZyAocHMgOiAnYSB0IGxpc3QpIChuIDogaW50KSA6ICdhIHQgPVxuICAgIG1hdGNoIHBzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuICAgIHwgcDo6cHMgLT5cbiAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCcpLnN0YXRlIHdpdGhcbiAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgIGNhbmNlbCBwO1xuICAgICAgICBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIG5cblxuICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiAoTGlzdC5pdGVyIGNhbmNlbCBwczsgcClcbiAgICAgICAgZWxzZSBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIChuIC0gMSlcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiAoTGlzdC5pdGVyIGNhbmNlbCBwczsgcClcbiAgICAgICAgZWxzZSBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIChuIC0gMSlcblxuICAoKiBUaGUgUFJORyBzdGF0ZSBpcyBpbml0aWFsaXplZCB3aXRoIGEgY29uc3RhbnQgdG8gbWFrZSBub24tSU8tYmFzZWQgcHJvZ3JhbXNcbiAgICAgZGV0ZXJtaW5pc3RpYy4gKilcbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IGlzIHRoaXMgbmVjZXNzYXJ5PyAqKVxuICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlIFt8fF0pXG5cbiAgbGV0IGNob29zZSBwcyA9XG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ1xuICAgICAgICBcIkx3dC5jaG9vc2UgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIG1hdGNoIGNvdW50X3Jlc29sdmVkX3Byb21pc2VzX2luIHBzIHdpdGhcbiAgICB8IE9rIDAgLT5cbiAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHBcbiAgICAgIGluXG4gICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBPayAxIC0+XG4gICAgICBudGhfcmVzb2x2ZWQgcHMgMFxuXG4gICAgfCBPayBuIC0+XG4gICAgICBudGhfcmVzb2x2ZWQgcHMgKFJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgcHJuZykgbilcblxuICAgIHwgRXJyb3IgKG4sIHBzKSAtPlxuICAgICAgbnRoX3Jlc29sdmVkIHBzIChSYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHBybmcpIG4pXG5cbiAgbGV0IHBpY2sgcHMgPVxuICAgIGlmIHBzID0gW10gdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJMd3QucGljayBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbWF0Y2ggY291bnRfcmVzb2x2ZWRfcHJvbWlzZXNfaW4gcHMgd2l0aFxuICAgIHwgT2sgMCAtPlxuICAgICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDoocHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzKSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPVxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwIHJlc3VsdCBpblxuICAgICAgICBpZ25vcmUgcFxuICAgICAgaW5cbiAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGNhbGxiYWNrO1xuXG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICB8IE9rIDEgLT5cbiAgICAgIG50aF9yZXNvbHZlZF9hbmRfY2FuY2VsX3BlbmRpbmcgcHMgMFxuXG4gICAgfCBPayBuIC0+XG4gICAgICBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzXG4gICAgICAgIChSYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHBybmcpIG4pXG5cbiAgICB8IEVycm9yIChuLCBxcykgLT5cbiAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICBudGhfcmVzb2x2ZWQgcXMgKFJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgcHJuZykgbilcblxuXG5cbiAgKCogSWYgW25jaG9vc2UgcHNdIG9yIFtucGljayBwc10gZm91bmQgYWxsIHByb21pc2VzIGluIFtwc10gcGVuZGluZywgdGhlXG4gICAgIGNhbGxiYWNrIGFkZGVkIHRvIGVhY2ggcHJvbWlzZSBpbiBbcHNdIGV2ZW50dWFsbHkgY2FsbHMgdGhpcyBmdW5jdGlvbi4gVGhlXG4gICAgIGZ1bmN0aW9uIGNvbGxlY3RzIHByb21pc2VzIGluIFtwc10gdGhhdCBoYXZlIGJlY29tZSBmdWxmaWxsZWQsIG9yIGZpbmRzIG9uZVxuICAgICBwcm9taXNlIGluIFtwc10gdGhhdCBoYXMgYmVlbiByZWplY3RlZC4gSXQgdGhlbiByZXR1cm5zIHRoZSBkZXNpcmVkIHN0YXRlXG4gICAgIG9mIHRoZSBmaW5hbCBwcm9taXNlOiBlaXRoZXIgdGhlIGxpc3Qgb2YgcmVzdWx0cyBjb2xsZWN0ZWQsIG9yIHRoZVxuICAgICBleGNlcHRpb24gZm91bmQuICopXG4gIGxldCByZWMgY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZ1xuICAgICAgKHJlc3VsdHMgOiAnYSBsaXN0KVxuICAgICAgKHBzIDogJ2EgdCBsaXN0KSA6XG4gICAgICAgICgnYSBsaXN0IHJlc29sdmVkX3N0YXRlKSA9XG5cbiAgICBtYXRjaCBwcyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgRnVsZmlsbGVkIChMaXN0LnJldiByZXN1bHRzKVxuXG4gICAgfCBwOjpwcyAtPlxuICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICBjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnRlcl9wZW5kaW5nICh2OjpyZXN1bHRzKSBwc1xuXG4gICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgIHJlc3VsdFxuXG4gICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICBjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnRlcl9wZW5kaW5nIHJlc3VsdHMgcHNcblxuICBsZXQgbmNob29zZSBwcyA9XG4gICAgKCogSWYgYXQgbGVhc3Qgb25lIHByb21pc2UgaW4gW3BzXSBpcyBmb3VuZCBmdWxmaWxsZWQsIHRoaXMgZnVuY3Rpb24gaXNcbiAgICAgICBjYWxsZWQgdG8gZmluZCBhbGwgc3VjaCBwcm9taXNlcy4gKilcbiAgICBpZiBwcyA9IFtdIHRoZW5cbiAgICAgIGludmFsaWRfYXJnXG4gICAgICAgIFwiTHd0Lm5jaG9vc2UgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIGxldCByZWMgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIGFjYyBwcyA9XG4gICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIHJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG4gICAgICB8IHA6OnBzIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCAodjo6YWNjKSBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgYWNjIHBzXG4gICAgaW5cblxuICAgICgqIExvb2tzIGZvciBhbHJlYWR5LXJlc29sdmVkIHByb21pc2VzIGluIFtwc10uIElmIG5vbmUgYXJlIGZ1bGZpbGxlZCBvclxuICAgICAgIHJlamVjdGVkLCBhZGRzIGEgY2FsbGJhY2sgdG8gYWxsIHByb21pc2VzIGluIFtwc10gKGFsbCBvZiB3aGljaCBhcmVcbiAgICAgICBwZW5kaW5nKS4gKilcbiAgICBsZXQgcmVjIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzJyA9XG4gICAgICBtYXRjaCBwcycgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICAgICAgbGV0IGNhbGxiYWNrIF9yZXN1bHQgPVxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdGVyX3BlbmRpbmcgW10gcHMgaW5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwIHJlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwXG4gICAgICAgIGluXG4gICAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGNhbGxiYWNrO1xuXG4gICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgW3ZdIHBzXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzXG4gICAgaW5cblxuICAgIGxldCBwID0gY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMgaW5cbiAgICBwXG5cbiAgKCogU2VlIFtuY2hvb3NlXS4gVGhpcyBmdW5jdGlvbiBkaWZmZXJzIG9ubHkgaW4gaGF2aW5nIGFkZGl0aW9uYWwgY2FsbHMgdG9cbiAgICAgW2NhbmNlbF0uICopXG4gIGxldCBucGljayBwcyA9XG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkx3dC5ucGljayBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbGV0IHJlYyBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgYWNjIHBzJyA9XG4gICAgICBtYXRjaCBwcycgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICByZXR1cm4gKExpc3QucmV2IGFjYylcblxuICAgICAgfCBwOjpwcycgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkICh2OjphY2MpIHBzJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBhY2MgcHMnXG4gICAgaW5cblxuICAgIGxldCByZWMgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMnID1cbiAgICAgIG1hdGNoIHBzJyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgICBsZXQgY2FsbGJhY2sgX3Jlc3VsdCA9XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgICBsZXQgcmVzdWx0ID0gY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZyBbXSBwcyBpblxuICAgICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcFxuICAgICAgICBpblxuICAgICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICAgIHwgcDo6cHMnIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBbdl0gcHMnXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMnXG4gICAgaW5cblxuICAgIGxldCBwID0gY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMgaW5cbiAgICBwXG5cblxuXG4gICgqIFNhbWUgZ2VuZXJhbCBwYXR0ZXJuIGFzIFtucGlja10gYW5kIFtuY2hvb3NlXS4gKilcbiAgbGV0IG5jaG9vc2Vfc3BsaXQgcHMgPVxuICAgIGlmIHBzID0gW10gdGhlblxuICAgICAgaW52YWxpZF9hcmdcbiAgICAgICAgXCJMd3QubmNob29zZV9zcGxpdCBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbGV0IHJlYyBmaW5pc2hcbiAgICAgICAgKHRvX3Jlc29sdmUgOiAoJ2EgbGlzdCAqICdhIHQgbGlzdCwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZSlcbiAgICAgICAgKGZ1bGZpbGxlZCA6ICdhIGxpc3QpXG4gICAgICAgIChwZW5kaW5nIDogJ2EgdCBsaXN0KVxuICAgICAgICAocHMgOiAnYSB0IGxpc3QpXG4gICAgICAgICAgOiAoJ2EgbGlzdCAqICdhIHQgbGlzdCwgdW5kZXJseWluZywgcmVzb2x2ZWQpIHN0YXRlX2NoYW5nZWQgPVxuXG4gICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSB0b19yZXNvbHZlXG4gICAgICAgICAgKEZ1bGZpbGxlZCAoTGlzdC5yZXYgZnVsZmlsbGVkLCBMaXN0LnJldiBwZW5kaW5nKSlcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBmaW5pc2ggdG9fcmVzb2x2ZSAodjo6ZnVsZmlsbGVkKSBwZW5kaW5nIHBzXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSB0b19yZXNvbHZlIHJlc3VsdFxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgZmluaXNoIHRvX3Jlc29sdmUgZnVsZmlsbGVkIChwOjpwZW5kaW5nKSBwc1xuICAgIGluXG5cbiAgICBsZXQgcmVjIGNvbGxlY3RfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyByZXN1bHRzIHBlbmRpbmcgcHMgPVxuICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICAoKiBNYWludGFpbmVyJ3Mgbm90ZTogc2hvdWxkIHRoZSBwZW5kaW5nIHByb21pc2UgbGlzdCBhbHNvIGJlXG4gICAgICAgICAgIHJldmVyc2VkPyBJdCBpcyByZXZlcnNlZCBpbiBmaW5pc2guICopXG4gICAgICAgIHJldHVybiAoTGlzdC5yZXYgcmVzdWx0cywgcGVuZGluZylcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgKHY6OnJlc3VsdHMpIHBlbmRpbmcgcHNcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHJlc3VsdHMgKHA6OnBlbmRpbmcpIHBzXG4gICAgaW5cblxuICAgIGxldCByZWMgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcGVuZGluZ19hY2MgcHMnID1cbiAgICAgIG1hdGNoIHBzJyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgICBsZXQgY2FsbGJhY2sgX3Jlc3VsdCA9XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID0gZmluaXNoIHAgW10gW10gcHMgaW5cbiAgICAgICAgICBpZ25vcmUgcFxuICAgICAgICBpblxuICAgICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICAgIHwgcDo6cHMnIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwX2ludGVybmFsID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHBfaW50ZXJuYWwpLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBbdl0gcGVuZGluZ19hY2MgcHMnXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIChwOjpwZW5kaW5nX2FjYykgcHMnXG4gICAgaW5cblxuICAgIGxldCBwID0gY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgW10gcHMgaW5cbiAgICBwXG5lbmRcbmluY2x1ZGUgQ29uY3VycmVudF9jb21wb3NpdGlvblxuXG5cblxubW9kdWxlIE1pc2NlbGxhbmVvdXMgOlxuc2lnXG4gICgqIFByb21pc2Ugc3RhdGUgcXVlcnkgKilcbiAgdHlwZSAnYSBzdGF0ZSA9XG4gICAgfCBSZXR1cm4gb2YgJ2FcbiAgICB8IEZhaWwgb2YgZXhuXG4gICAgfCBTbGVlcFxuXG4gIHZhbCBzdGF0ZSA6ICdhIHQgLT4gJ2Egc3RhdGVcbiAgdmFsIGlzX3NsZWVwaW5nIDogJ2EgdCAtPiBib29sXG4gIHZhbCBkZWJ1Z19zdGF0ZV9pcyA6ICdhIHN0YXRlIC0+ICdhIHQgLT4gYm9vbCB0XG5cbiAgKCogRnVuY3Rpb24gbGlmdGVycyAqKVxuICB2YWwgYXBwbHkgOiAoJ2EgLT4gJ2IgdCkgLT4gJ2EgLT4gJ2IgdFxuXG4gIHZhbCB3cmFwIDpcbiAgICAodW5pdCAtPiAnYikgLT5cbiAgICAnYiB0XG4gIHZhbCB3cmFwMSA6XG4gICAgKCdhMSAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdiIHQpXG4gIHZhbCB3cmFwMiA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2IgdClcbiAgdmFsIHdyYXAzIDpcbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdiIHQpXG4gIHZhbCB3cmFwNCA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdiIHQpXG4gIHZhbCB3cmFwNSA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2IgdClcbiAgdmFsIHdyYXA2IDpcbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdiIHQpXG4gIHZhbCB3cmFwNyA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdhNyAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2E3IC0+ICdiIHQpXG5cbiAgKCogUGF1c2VkIHByb21pc2VzICopXG4gIHZhbCBwYXVzZSA6IHVuaXQgLT4gdW5pdCB0XG4gIHZhbCB3YWtldXBfcGF1c2VkIDogdW5pdCAtPiB1bml0XG4gIHZhbCBwYXVzZWRfY291bnQgOiB1bml0IC0+IGludFxuICB2YWwgcmVnaXN0ZXJfcGF1c2Vfbm90aWZpZXIgOiAoaW50IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGFiYW5kb25fcGF1c2VkIDogdW5pdCAtPiB1bml0XG5cbiAgKCogSW50ZXJuYWwgaW50ZXJmYWNlIGZvciBvdGhlciBtb2R1bGVzIGluIEx3dCAqKVxuICB2YWwgcG9sbCA6ICdhIHQgLT4gJ2Egb3B0aW9uXG5lbmQgPVxuc3RydWN0XG4gIHR5cGUgJ2Egc3RhdGUgPVxuICAgIHwgUmV0dXJuIG9mICdhXG4gICAgfCBGYWlsIG9mIGV4blxuICAgIHwgU2xlZXBcblxuICBleHRlcm5hbCByZXJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmVyYWlzZVwiXG5cbiAgbGV0IHN0YXRlIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT4gUmV0dXJuIHZcbiAgICB8IFJlamVjdGVkIGV4biAtPiBGYWlsIGV4blxuICAgIHwgUGVuZGluZyBfIC0+IFNsZWVwXG5cbiAgbGV0IGRlYnVnX3N0YXRlX2lzIGV4cGVjdGVkX3N0YXRlIHAgPVxuICAgIHJldHVybiAoc3RhdGUgcCA9IGV4cGVjdGVkX3N0YXRlKVxuXG4gIGxldCBpc19zbGVlcGluZyBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+IGZhbHNlXG4gICAgfCBSZWplY3RlZCBfIC0+IGZhbHNlXG4gICAgfCBQZW5kaW5nIF8gLT4gdHJ1ZVxuXG4gIGxldCBwb2xsIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgUmVqZWN0ZWQgZSAtPiByZXJhaXNlIGVcbiAgICB8IEZ1bGZpbGxlZCB2IC0+IFNvbWUgdlxuICAgIHwgUGVuZGluZyBfIC0+IE5vbmVcblxuXG5cbiAgbGV0IGFwcGx5IGYgeCA9XG4gICAgdHJ5IGYgeCB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwIGYgPVxuICAgIHRyeSByZXR1cm4gKGYgKCkpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDEgZiB4MSA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSlcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwMiBmIHgxIHgyID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyKVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXAzIGYgeDEgeDIgeDMgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDQgZiB4MSB4MiB4MyB4NCA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MiB4MyB4NClcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwNSBmIHgxIHgyIHgzIHg0IHg1ID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyIHgzIHg0IHg1KVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXA2IGYgeDEgeDIgeDMgeDQgeDUgeDYgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMgeDQgeDUgeDYpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDcgZiB4MSB4MiB4MyB4NCB4NSB4NiB4NyA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MiB4MyB4NCB4NSB4NiB4NylcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG5cblxuICBsZXQgcGF1c2VfaG9vayA9IHJlZiBpZ25vcmVcblxuICBsZXQgcGF1c2VkID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKVxuICBsZXQgcGF1c2VkX2NvdW50ID0gcmVmIDBcblxuICBsZXQgcGF1c2UgKCkgPVxuICAgIGxldCBwID0gYWRkX3Rhc2tfciBwYXVzZWQgaW5cbiAgICBpbmNyIHBhdXNlZF9jb3VudDtcbiAgICAhcGF1c2VfaG9vayAhcGF1c2VkX2NvdW50O1xuICAgIHBcblxuICBsZXQgd2FrZXVwX3BhdXNlZCAoKSA9XG4gICAgaWYgTHd0X3NlcXVlbmNlLmlzX2VtcHR5IHBhdXNlZCB0aGVuXG4gICAgICBwYXVzZWRfY291bnQgOj0gMFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCB0bXAgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIGluXG4gICAgICBMd3Rfc2VxdWVuY2UudHJhbnNmZXJfciBwYXVzZWQgdG1wO1xuICAgICAgcGF1c2VkX2NvdW50IDo9IDA7XG4gICAgICBMd3Rfc2VxdWVuY2UuaXRlcl9sIChmdW4gciAtPiB3YWtldXAgciAoKSkgdG1wXG4gICAgZW5kXG5cbiAgbGV0IHJlZ2lzdGVyX3BhdXNlX25vdGlmaWVyIGYgPSBwYXVzZV9ob29rIDo9IGZcblxuICBsZXQgYWJhbmRvbl9wYXVzZWQgKCkgPVxuICAgIEx3dF9zZXF1ZW5jZS5jbGVhciBwYXVzZWQ7XG4gICAgcGF1c2VkX2NvdW50IDo9IDBcblxuICBsZXQgcGF1c2VkX2NvdW50ICgpID0gIXBhdXNlZF9jb3VudFxuZW5kXG5pbmNsdWRlIE1pc2NlbGxhbmVvdXNcblxubW9kdWxlIExldF9zeW50YXggPVxuc3RydWN0XG4gIG1vZHVsZSBMZXRfc3ludGF4ID1cbiAgc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgdCB+ZiA9IG1hcCBmIHRcbiAgICBsZXQgYmluZCB0IH5mID0gYmluZCB0IGZcbiAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgIG1vZHVsZSBPcGVuX29uX3JocyA9XG4gICAgc3RydWN0XG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBJbmZpeCA9XG5zdHJ1Y3RcbiAgbGV0ICg+Pj0pID0gYmluZFxuICBsZXQgKD08PCkgZiBwID0gYmluZCBwIGZcbiAgbGV0ICg+fD0pIHAgZiA9IG1hcCBmIHBcbiAgbGV0ICg9fDwpID0gbWFwXG4gIGxldCAoPCY+KSBwIHAnID0gam9pbiBbcDsgcCddXG4gIGxldCAoPD8+KSBwIHAnID0gY2hvb3NlIFtwOyBwJ11cblxuICBpbmNsdWRlIExldF9zeW50YXhcbmVuZFxuaW5jbHVkZSAoIEluZml4IDogbW9kdWxlIHR5cGUgb2YgSW5maXggd2l0aCBtb2R1bGUgTGV0X3N5bnRheCA6PSBMZXRfc3ludGF4LkxldF9zeW50YXggKVxuXG5tb2R1bGUgU3ludGF4ID1cbnN0cnVjdFxuICBsZXQgKGxldCopID0gYmluZFxuICBsZXQgKGFuZCopID0gYm90aFxuXG4gIGxldCAobGV0KykgeCBmID0gbWFwIGYgeFxuICBsZXQgKGFuZCspID0gYm90aFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjM3NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkx3dCIsIlN0ZGxpYl9MaXN0IiwiT2ZmIiwiY3JlYXRlIiwicGFyYW0iLCJpc19vbiIsInN3aXRjaCIsImNoZWNrIiwiYWRkX2hvb2siLCJob29rIiwibWF0Y2giLCJvcyIsImFkZF9ob29rX29yX2V4ZWMiLCJ0dXJuX29mZiIsImhvb2tzIiwid2l0aF9zd2l0Y2giLCJmbiIsIkx3dF9zd2l0Y2giXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2RvZ2FkaW5tLy5vcGFtL2VsaW9tL2xpYi9sd3QvbHd0X3N3aXRjaC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsWUFBQUMsT0FBQUMsT0NpQmdCLHdCQUFnQztBQUFBLFlBQUFDLE1BQUFDLFVBRzlDLDBCQUVpQjtBQUFBLFlBQUFDLE1BQUFIO0FBQUFBLElBRVAsMkJBQ2tCO0FBQUEsSUFDTztBQUFBLEdBQUU7QUFBQSxZQUFBSSxTQUFBRixVQUFBRztBQUFBQSxJQUdyQyxlQU1FO0FBQUEsUUFBQUMsUUFORjtBQUFBLGdCQUlFO0FBQUEsUUFBQUMsS0FKRjtBQUFBLElBRUU7QUFBQTtBQUFBLEdBSUU7QUFBQSxZQUFBQyxpQkFBQU4sVUFBQUc7QUFBQUEsSUFHSixlQU9FO0FBQUEsUUFBQUMsUUFQRjtBQUFBLGdCQUtFLDBCQUVlO0FBQUEsUUFBQUMsS0FQakI7QUFBQSxJQUVFO0FBQUEsSUFDQTtBQUFBLEdBSWU7QUFBQSxZQUFBRSxTQUFBUDtBQUFBQSxRQUFBLE1BR2pCO0FBQUEsY0FLRTtBQUFBLFFBQUFRLFFBTEY7QUFBQSxJQUVFO0FBQUE7QUFBQTtBQUFBLE9BQ1M7QUFBQTtBQUFBLGtCQUFBTCxNQUF1QixtQ0FBaUI7QUFBQTtBQUFBLElBQVEsK0JBRTFDO0FBQUE7QUFBQSxZQUFBTSxZQUFBQztBQUFBQSxRQUFBVixXQUdKO0FBQUEsSUFDYjtBQUFBO0FBQUEsc0JBQUFGLE9BQ2EsK0JBQVM7QUFBQSxzQkFBQUEsT0FDVCx5QkFBZSxHQUFDO0FBQUE7QUFBQTtBQUFBLElBQUFhO0FBQUFBLE1EM0QvQiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5leGNlcHRpb24gT2ZmXG5cbnR5cGUgb25fc3dpdGNoID0ge1xuICBtdXRhYmxlIGhvb2tzIDogKHVuaXQgLT4gdW5pdCBMd3QudCkgbGlzdDtcbn1cblxudHlwZSBzdGF0ZSA9XG4gIHwgU3Rfb24gb2Ygb25fc3dpdGNoXG4gIHwgU3Rfb2ZmXG5cbnR5cGUgdCA9IHsgbXV0YWJsZSBzdGF0ZSA6IHN0YXRlIH1cblxubGV0IGNyZWF0ZSAoKSA9IHsgc3RhdGUgPSBTdF9vbiB7IGhvb2tzID0gW10gfSB9XG5cbmxldCBpc19vbiBzd2l0Y2ggPVxuICBtYXRjaCBzd2l0Y2guc3RhdGUgd2l0aFxuICB8IFN0X29uIF8gLT4gdHJ1ZVxuICB8IFN0X29mZiAtPiBmYWxzZVxuXG5sZXQgY2hlY2sgPSBmdW5jdGlvblxuICB8IFNvbWV7IHN0YXRlID0gU3Rfb2ZmIH0gLT4gcmFpc2UgT2ZmXG4gIHwgU29tZSB7c3RhdGUgPSBTdF9vbiBffSB8IE5vbmUgLT4gKClcblxubGV0IGFkZF9ob29rIHN3aXRjaCBob29rID1cbiAgbWF0Y2ggc3dpdGNoIHdpdGhcbiAgfCBTb21lIHsgc3RhdGUgPSBTdF9vbiBvcyB9IC0+XG4gICAgb3MuaG9va3MgPC0gaG9vayA6OiBvcy5ob29rc1xuICB8IFNvbWUgeyBzdGF0ZSA9IFN0X29mZiB9IC0+XG4gICAgcmFpc2UgT2ZmXG4gIHwgTm9uZSAtPlxuICAgICgpXG5cbmxldCBhZGRfaG9va19vcl9leGVjIHN3aXRjaCBob29rID1cbiAgbWF0Y2ggc3dpdGNoIHdpdGhcbiAgfCBTb21lIHsgc3RhdGUgPSBTdF9vbiBvcyB9IC0+XG4gICAgb3MuaG9va3MgPC0gaG9vayA6OiBvcy5ob29rcztcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgfCBTb21lIHsgc3RhdGUgPSBTdF9vZmYgfSAtPlxuICAgIGhvb2sgKClcbiAgfCBOb25lIC0+XG4gICAgTHd0LnJldHVybl91bml0XG5cbmxldCB0dXJuX29mZiBzd2l0Y2ggPVxuICBtYXRjaCBzd2l0Y2guc3RhdGUgd2l0aFxuICB8IFN0X29uIHsgaG9va3MgPSBob29rcyB9IC0+XG4gICAgc3dpdGNoLnN0YXRlIDwtIFN0X29mZjtcbiAgICBMd3Quam9pbiAoTGlzdC5tYXAgKGZ1biBob29rIC0+IEx3dC5hcHBseSBob29rICgpKSBob29rcylcbiAgfCBTdF9vZmYgLT5cbiAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IHdpdGhfc3dpdGNoIGZuID1cbiAgbGV0IHN3aXRjaCA9IGNyZWF0ZSAoKSBpblxuICBMd3QuZmluYWxpemVcbiAgICAoZnVuICgpIC0+IGZuIHN3aXRjaClcbiAgICAoZnVuICgpIC0+IHR1cm5fb2ZmIHN3aXRjaClcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNDU4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imx3dC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkx3dCIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX1ByaW50ZiIsIlN0ZGxpYiIsInJldHVybl9uaWwiLCJlbXB0eSIsInBhcmFtIiwicmV0dXJuIiwieCIsInJldHVybl9sd3QiLCJjb25zIiwidCIsImNvbnNfbHd0Iiwic2VxMSIsInNlcTIiLCJuZXh0IiwiYXBwZW5kIiwic2VxIiwibWFwIiwibWFwX3MiLCJ5IiwiZmlsdGVyX21hcCIsImZpbHRlcl9tYXBfcyIsIm9rIiwiZmlsdGVyIiwiZmlsdGVyX3MiLCJmbGF0X21hcF9hcHAiLCJ0YWlsIiwiZmxhdF9tYXAiLCJmb2xkX2xlZnQiLCJhY2MiLCJhdXgiLCJmb2xkX2xlZnRfcyIsIml0ZXIiLCJpdGVyX3MiLCJpdGVyX3AiLCJwIiwiaXRlcl9uIiwib3B0Iiwic3RoIiwibWF4X2NvbmN1cnJlbmN5IiwibWVzc2FnZSIsImxvb3AiLCJydW5uaW5nIiwiYXZhaWxhYmxlIiwiZWx0IiwiY29tcGxldGUiLCJ1bmZvbGQiLCJ1IiwidmFsIiwiZXhjIiwibWF0Y2giLCJ1bmZvbGRfbHd0Iiwib2ZfbGlzdCIsImwiLCJoIiwidG9fbGlzdCIsIm9mX3NlcSIsImV4biIsIm9mX3NlcV9sd3QiLCJMd3Rfc2VxIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9kb2dhZGlubS8ub3BhbS9lbGlvbS9saWIvbHd0L2x3dF9zZXEubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQ1lpQjtBQUFBO0FBQUEsTUFBYztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsTUFBQUMsT0FFRixrQkFBVTtBQUFBLFlBQUFDLFNBQUFDLEdBQUFGLE9BRUEsd0NBQTRCO0FBQUEsWUFBQUcsV0FBQUQsR0FBQUY7QUFBQUEsSUFHaEUsMENBQUFFLEdBQ0EscUJBQWU7QUFBQTtBQUFBLFlBQUFFLEtBQUFGLEdBQUFHLEdB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RztBQUFBO0FBQUE7QUFBQSxzQkFBQUE7QUFBQUEsdUJBQUFPLE9BQUEsS0FDVztBQUFBLGNBQ1g7QUFBQSxhQUFjLEVBQ21EO0FBQUE7QUFBQTtBQUFBLElBQUE2QztBQUFBQSxNQWpUekM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRFovQiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5vcGVuIEx3dC5TeW50YXhcbm9wZW4gTHd0LkluZml4XG5cbnR5cGUgKydhIG5vZGUgPSBOaWwgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZSBMd3QudFxuXG5sZXQgcmV0dXJuX25pbCA9IEx3dC5yZXR1cm4gTmlsXG5cbmxldCBlbXB0eSA6ICdhIHQgPSBmdW4gKCkgLT4gcmV0dXJuX25pbFxuXG5sZXQgcmV0dXJuICh4IDogJ2EpIDogJ2EgdCA9IGZ1biAoKSAtPiBMd3QucmV0dXJuIChDb25zICh4LCBlbXB0eSkpXG5cbmxldCByZXR1cm5fbHd0ICh4IDogJ2EgTHd0LnQpIDogJ2EgdCA9IGZ1biAoKSAtPlxuICAgbGV0KyB4ID0geCBpblxuICAgQ29ucyAoeCwgZW1wdHkpXG5cbmxldCBjb25zIHggdCAoKSA9IEx3dC5yZXR1cm4gKENvbnMgKHgsIHQpKVxuXG5sZXQgY29uc19sd3QgeCB0ICgpID1cbiAgIGxldCsgeCA9IHggaW5cbiAgIENvbnMgKHgsIHQpXG5cbigqIEEgbm90ZSBvbiByZWN1cnNpbmcgdGhyb3VnaCB0aGUgc2VxczpcbiAgIFdoZW4gdHJhdmVyc2luZyBhIHNlcSwgdGhlIGZpcnN0IHRpbWUgd2UgZXZhbHVhdGUgYSBzdXNwZW5kZWQgbm9kZSB3ZSBhcmVcbiAgIG9uIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBiaW5kICg+Pj0pLiBJbiB0aGF0IGNhc2UsIHdlIHVzZSBhcHBseSB0byBjYXB0dXJlXG4gICBleGNlcHRpb25zIGludG8gcHJvbWlzZSByZWplY3Rpb24uXG5cbiAgIFRoaXMgaXMgb25seSBuZWVkZWQgb24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBiZWNhdXNlIHdlIGFyZSB3aXRoaW4gYSBjYWxsYmFja1xuICAgcGFzc2VkIHRvIEx3dCBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIGEgYmluZCBhZnRlciB0aGF0LlxuXG4gICBUaHJvdWdob3V0IHRoaXMgZmlsZSB3ZSB1c2UgdGhlIHNhbWUgY29kZSBwYXR0ZXJuIHRvIGFjaGlldmUgdGhpczogd2VcbiAgIHNoYWRvdyB0aGUgcmVjdXJzaXZlIHRyYXZlcnNhbCBmdW5jdGlvbiB3aXRoIGFuIGlkZW50aWNhbC1idXQtZm9yLXRoZS1hcHBseVxuICAgbm9uLXJlY3Vyc2l2ZSBjb3B5LiAqKVxuXG5sZXQgcmVjIGFwcGVuZCBzZXExIHNlcTIgKCkgPVxuICBzZXExICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiBzZXEyICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMikpXG5sZXQgYXBwZW5kIHNlcTEgc2VxMiAoKSA9XG4gIEx3dC5hcHBseSBzZXExICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiBzZXEyICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMikpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID58PSBmdW5jdGlvblxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIENvbnMgKHgsIG1hcCBmIG5leHQpXG5sZXQgbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+fD0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICBDb25zICh4LCBtYXAgZiBuZXh0KVxuXG5sZXQgcmVjIG1hcF9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCsgeCA9IGYgeCBpblxuICAgICAgQ29ucyAoeCwgbWFwX3MgZiBuZXh0KVxubGV0IG1hcF9zIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBsZXQrIHggPSBmIHggaW5cbiAgICAgIENvbnMgKHgsIG1hcF9zIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gKFxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICB8IFNvbWUgeSAtPiBMd3QucmV0dXJuIChDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dCkgKSlcbmxldCBmaWx0ZXJfbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IChcbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgfCBTb21lIHkgLT4gTHd0LnJldHVybiAoQ29ucyAoeSwgZmlsdGVyX21hcCBmIG5leHQpICkpXG5cbmxldCByZWMgZmlsdGVyX21hcF9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gKFxuICAgICAgbGV0KiB4ID0gZiB4IGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwX3MgZiBuZXh0ICgpXG4gICAgICB8IFNvbWUgeSAtPiBMd3QucmV0dXJuIChDb25zICh5LCBmaWx0ZXJfbWFwX3MgZiBuZXh0KSApKVxubGV0IGZpbHRlcl9tYXBfcyBmIHNlcSAoKSA9XG4gIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiAoXG4gICAgICBsZXQqIHggPSBmIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXBfcyBmIG5leHQgKClcbiAgICAgIHwgU29tZSB5IC0+IEx3dC5yZXR1cm4gKENvbnMgKHksIGZpbHRlcl9tYXBfcyBmIG5leHQpICkpXG5cbmxldCByZWMgZmlsdGVyIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCBvayA9IGYgeCBpblxuICAgICAgaWYgb2sgdGhlbiBMd3QucmV0dXJuIChDb25zICh4LCBmaWx0ZXIgZiBuZXh0KSkgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5sZXQgZmlsdGVyIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBsZXQgb2sgPSBmIHggaW5cbiAgICAgIGlmIG9rIHRoZW4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmlsdGVyIGYgbmV4dCkpIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZpbHRlcl9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCogb2sgPSBmIHggaW5cbiAgICAgIGlmIG9rIHRoZW4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmlsdGVyX3MgZiBuZXh0KSkgZWxzZSBmaWx0ZXJfcyBmIG5leHQgKClcbmxldCBmaWx0ZXJfcyBmIHNlcSAoKSA9XG4gIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0KiBvayA9IGYgeCBpblxuICAgICAgaWYgb2sgdGhlbiBMd3QucmV0dXJuIChDb25zICh4LCBmaWx0ZXJfcyBmIG5leHQpKSBlbHNlIGZpbHRlcl9zIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGZsYXRfbWFwX2FwcCBmIChmIHgpIG5leHQgKClcblxuKCogdGhpcyBpcyBbYXBwZW5kIHNlcSAoZmxhdF9tYXAgZiB0YWlsKV0gKilcbmFuZCBmbGF0X21hcF9hcHAgZiBzZXEgdGFpbCAoKSA9XG4gIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gZmxhdF9tYXAgZiB0YWlsICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmxhdF9tYXBfYXBwIGYgbmV4dCB0YWlsKSlcblxubGV0IGZsYXRfbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBmbGF0X21hcF9hcHAgZiAoZiB4KSBuZXh0ICgpXG5cbmxldCBmb2xkX2xlZnQgZiBhY2Mgc2VxID1cbiAgbGV0IHJlYyBhdXggZiBhY2Mgc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGxldCBhdXggZiBhY2Mgc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBhdXggZiBhY2MgbmV4dFxuICBpblxuICBhdXggZiBhY2Mgc2VxXG5cbmxldCBmb2xkX2xlZnRfcyBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPVxuICAgIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3QucmV0dXJuIGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0KiBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGxldCBhdXggZiBhY2Mgc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQqIGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgYXV4IGYgYWNjIHNlcVxuXG5sZXQgaXRlciBmIHNlcSA9XG4gIGxldCByZWMgYXV4IHNlcSA9XG4gICAgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBhdXggbmV4dFxuICBpblxuICBsZXQgYXV4IHNlcSA9XG4gICAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3QucmV0dXJuX3VuaXRcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgYXV4IHNlcVxuXG5sZXQgaXRlcl9zIGYgc2VxID1cbiAgbGV0IHJlYyBhdXggc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybl91bml0XG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQqICgpID0gZiB4IGluXG4gICAgICAgIGF1eCBuZXh0XG4gIGluXG4gIGxldCBhdXggc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0KiAoKSA9IGYgeCBpblxuICAgICAgICBhdXggbmV4dFxuICBpblxuICBhdXggc2VxXG5cbmxldCBpdGVyX3AgZiBzZXEgPVxuICBsZXQgcmVjIGF1eCBhY2Mgc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LmpvaW4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgcCA9IGYgeCBpblxuICAgICAgICBhdXggKHA6OmFjYykgbmV4dFxuICBpblxuICBsZXQgYXV4IGFjYyBzZXEgPVxuICAgIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LmpvaW4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgcCA9IGYgeCBpblxuICAgICAgICBhdXggKHA6OmFjYykgbmV4dFxuICBpblxuICBhdXggW10gc2VxXG5cbmxldCBpdGVyX24gPyhtYXhfY29uY3VycmVuY3kgPSAxKSBmIHNlcSA9XG4gIGJlZ2luXG4gICAgaWYgbWF4X2NvbmN1cnJlbmN5IDw9IDAgdGhlblxuICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICBQcmludGYuc3ByaW50ZlxuICAgICAgICAgIFwiTHd0X3NlcS5pdGVyX246IG1heF9jb25jdXJyZW5jeSBtdXN0IGJlID4gMCwgJWQgZ2l2ZW5cIlxuICAgICAgICAgIG1heF9jb25jdXJyZW5jeVxuICAgICAgaW5cbiAgICAgIGludmFsaWRfYXJnIG1lc3NhZ2VcbiAgZW5kO1xuICBsZXQgcmVjIGxvb3AgcnVubmluZyBhdmFpbGFibGUgc2VxID1cbiAgICBiZWdpblxuICAgICAgaWYgYXZhaWxhYmxlID4gMCB0aGVuIChcbiAgICAgICAgTHd0LnJldHVybiAocnVubmluZywgYXZhaWxhYmxlKVxuICAgICAgKVxuICAgICAgZWxzZSAoXG4gICAgICAgIEx3dC5uY2hvb3NlX3NwbGl0IHJ1bm5pbmcgPj49IGZ1biAoY29tcGxldGUsIHJ1bm5pbmcpIC0+XG4gICAgICAgIEx3dC5yZXR1cm4gKHJ1bm5pbmcsIGF2YWlsYWJsZSArIExpc3QubGVuZ3RoIGNvbXBsZXRlKVxuICAgICAgKVxuICAgIGVuZCA+Pj0gZnVuIChydW5uaW5nLCBhdmFpbGFibGUpIC0+XG4gICAgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+XG4gICAgICBMd3Quam9pbiBydW5uaW5nXG4gICAgfCBDb25zIChlbHQsIHNlcSkgLT5cbiAgICAgIGxvb3AgKGYgZWx0IDo6IHJ1bm5pbmcpIChwcmVkIGF2YWlsYWJsZSkgc2VxXG4gIGluXG4gICgqIGJlY2F1c2UgdGhlIHJlY3Vyc2lvbiBpcyBtb3JlIGNvbXBsaWNhdGVkIGhlcmUsIHdlIGFwcGx5IHRoZSBzZXEgZGlyZWN0bHkgYXRcbiAgICAgdGhlIGNhbGwtc2l0ZSBpbnN0ZWFkICopXG4gIGxvb3AgW10gbWF4X2NvbmN1cnJlbmN5IChmdW4gKCkgLT4gTHd0LmFwcGx5IHNlcSAoKSlcblxubGV0IHJlYyB1bmZvbGQgZiB1ICgpID1cbiAgbWF0Y2ggZiB1IHdpdGhcbiAgfCBOb25lIC0+IHJldHVybl9uaWxcbiAgfCBTb21lICh4LCB1JykgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgdW5mb2xkIGYgdScpKVxuICB8IGV4Y2VwdGlvbiBleGMgd2hlbiBMd3QuRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhjIC0+IEx3dC5yZXJhaXNlIGV4Y1xuXG5sZXQgcmVjIHVuZm9sZF9sd3QgZiB1ICgpID1cbiAgbGV0KiB4ID0gZiB1IGluXG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gcmV0dXJuX25pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBMd3QucmV0dXJuIChDb25zICh4LCB1bmZvbGRfbHd0IGYgdScpKVxubGV0IHVuZm9sZF9sd3QgZiB1ICgpID1cbiAgbGV0KiB4ID0gTHd0LmFwcGx5IGYgdSBpblxuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHJldHVybl9uaWxcbiAgfCBTb21lICh4LCB1JykgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgdW5mb2xkX2x3dCBmIHUnKSlcblxubGV0IHJlYyBvZl9saXN0IGwgKCkgPVxuICBMd3QucmV0dXJuIChtYXRjaCBsIHdpdGggW10gLT4gTmlsIHwgaCA6OiB0IC0+IENvbnMgKGgsIG9mX2xpc3QgdCkpXG5cbmxldCB0b19saXN0IChzZXEgOiAnYSB0KSA9XG4gIGxldCByZWMgYXV4IGYgc2VxID1cbiAgICBMd3QuYmluZCAoc2VxICgpKSAoZnVuY3Rpb25cbiAgICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gKGYgW10pXG4gICAgICB8IENvbnMgKGgsIHQpIC0+IGF1eCAoZnVuIHggLT4gZiAoaCA6OiB4KSkgdClcbiAgaW5cbiAgYXV4IChmdW4geCAtPiB4KSAoTHd0LmFwcGx5IHNlcSlcblxubGV0IHJlYyBvZl9zZXEgc2VxICgpID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+IHJldHVybl9uaWxcbiAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBMd3QucmV0dXJuIChDb25zICh4LCAob2Zfc2VxIG5leHQpKSlcbiAgfCBleGNlcHRpb24gZXhuIHdoZW4gTHd0LkV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBMd3QucmVyYWlzZSBleG5cblxubGV0IHJlYyBvZl9zZXFfbHd0IChzZXE6ICdhIEx3dC50IFNlcS50KTogJ2EgdCA9IGZ1biAoKSAtPlxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBTZXEuTmlsIC0+IHJldHVybl9uaWxcbiAgICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPlxuICAgICAgIGxldCsgeCA9IHggaW5cbiAgICAgICBsZXQgbmV4dCA9IG9mX3NlcV9sd3QgbmV4dCBpblxuICAgICAgIENvbnMgKHgsIG5leHQpXG5sZXQgb2Zfc2VxX2x3dCAoc2VxOiAnYSBMd3QudCBTZXEudCk6ICdhIHQgPSBmdW4gKCkgLT5cbiAgICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgU2VxLk5pbCAtPiByZXR1cm5fbmlsXG4gICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICBsZXQrIHggPSB4IGluXG4gICAgICAgbGV0IG5leHQgPSBvZl9zZXFfbHd0IG5leHQgaW5cbiAgICAgICBDb25zICh4LCBuZXh0KVxuICAgIHwgZXhjZXB0aW9uIGV4YyB3aGVuIEx3dC5FeGNlcHRpb25fZmlsdGVyLnJ1biBleGMgLT4gTHd0LnJlcmFpc2UgZXhjXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzA1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9ibG9ja2VkIiwiY3N0X2Nsb3NlIiwiY3N0X2Nsb3NlZCIsImNzdF9jb3VudCIsImNzdF9wdXNoIiwiY3N0X3Jlc2l6ZSIsImNzdF9zZXRfcmVmZXJlbmNlIiwiY3N0X3NpemUiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsInNoYXJlZCIsIkx3dCIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX0J1ZmZlciIsIlN0ZGxpYl9QcmludGYiLCJTdGRsaWIiLCJDYW1saW50ZXJuYWxPTyIsIlN0ZGxpYl9TdHJpbmciLCJTdGRsaWJfQXJyYXkiLCJDbG9zZWQiLCJGdWxsIiwiRW1wdHkiLCJjc3RfTHd0X3N0cmVhbV9jbG9uZSIsImNzdF9Md3Rfc3RyZWFtX2JvdW5kZWRfcHVzaF9yZSIsIm5ld19ub2RlIiwicGFyYW0iLCJub2RlIiwiY2xvbmUiLCJzIiwiZnJvbV9zb3VyY2UiLCJzb3VyY2UiLCJtYXRjaCIsImNsb3NlIiwiY2xvc2VkIiwiZnJvbSIsImZyb21fZGlyZWN0IiwiaXNfY2xvc2VkIiwiZW5xdWV1ZSIsImUiLCJsYXN0IiwibmV3X2xhc3QiLCJjcmVhdGVfd2l0aF9yZWZlcmVuY2UiLCJwdXNoX3NpZ25hbF9yZXNvbHZlciIsInB1c2hfc2lnbmFsIiwidCIsInB1c2giLCJ4Iiwib2xkX3B1c2hfc2lnbmFsX3Jlc29sdmVyIiwibmV3X3B1c2hfc2lnbmFsX3Jlc29sdmVyIiwibmV3X3dhaXRlciIsInJldHVybiIsImEiLCJzdHJlYW0iLCJyZXR1cm5fbHd0IiwiZXhjIiwib2Zfc2VxIiwiZ2V0IiwiZWx0Iiwib2ZfbHd0X3NlcSIsImNyZWF0ZSIsIm9mX2l0ZXIiLCJpdGVyIiwiaSIsIm9mX2xpc3QiLCJsIiwib2ZfYXJyYXkiLCJvZl9zdHJpbmciLCJub3RpZnlfcHVzaGVyIiwiaW5mbyIsIm9sZF93YWtlbmVyIiwid2FrZW5lciIsIndhaXRlciIsImJvdW5kZWRfcHVzaF9pbXBsIiwic2VsZl8xIiwic2l6ZSIsImV4biIsIm5ld193YWtlbmVyIiwiY3N0X0x3dF9zdHJlYW1fY3JlYXRlX2JvdW5kZWQiLCJjc3RfTHd0X3N0cmVhbV9wYXJzZSIsImNyZWF0ZV9ib3VuZGVkIiwicHVzaF93YWtlbmVyIiwicHVzaF93YWl0ZXIiLCJ3YWtlbmVyX2NlbGwiLCJmZWVkIiwidGhyZWFkIiwiY29uc3VtZSIsInBlZWtfcmVjIiwicGVlayIsIm5wZWVrX3JlYyIsImFjYyIsIm4iLCJucGVlayIsImdldF9yZWMiLCJnZXRfZXhuX3JlYyIsInZhbHVlIiwid3JhcF9leG4iLCJuZ2V0X3JlYyIsIm5nZXQiLCJnZXRfd2hpbGVfcmVjIiwidGVzdCIsImdldF93aGlsZSIsImdldF93aGlsZV9zX3JlYyIsImdldF93aGlsZV9zIiwibmV4dF9yZWMiLCJuZXh0IiwibGFzdF9uZXdfcmVjIiwibGFzdF9uZXciLCJ0b19saXN0X3JlYyIsInRvX2xpc3QiLCJ0b19zdHJpbmdfcmVjIiwiYnVmIiwidG9fc3RyaW5nIiwianVuayIsIm5qdW5rX3JlYyIsIm5qdW5rIiwianVua193aGlsZV9yZWMiLCJqdW5rX3doaWxlIiwianVua193aGlsZV9zX3JlYyIsImp1bmtfd2hpbGVfcyIsImp1bmtfYXZhaWxhYmxlIiwianVua19vbGQiLCJnZXRfYXZhaWxhYmxlIiwiZ2V0X2F2YWlsYWJsZV91cF90byIsImlzX2VtcHR5IiwibWFwIiwibWFwX3MiLCJmaWx0ZXIiLCJmaWx0ZXJfcyIsImZpbHRlcl9tYXAiLCJmaWx0ZXJfbWFwX3MiLCJtYXBfbGlzdCIsInBlbmRpbmdzIiwibWFwX2xpc3RfcyIsImZsYXR0ZW4iLCJmb2xkX3JlYyIsImZvbGQiLCJmb2xkX3NfcmVjIiwiZm9sZF9zIiwiaXRlcl9yZWMiLCJpdGVyX3NfcmVjIiwiaXRlcl9zIiwiaXRlcl9wX3JlYyIsInJlcyIsInJlc3QiLCJpdGVyX3AiLCJpdGVyX24iLCJvcHQiLCJzdGgiLCJtYXhfY29uY3VycmVuY3kiLCJtZXNzYWdlIiwibG9vcCIsInJ1bm5pbmciLCJhdmFpbGFibGUiLCJjb21wbGV0ZSIsImZpbmRfcmVjIiwiZmluZCIsImZpbmRfc19yZWMiLCJmaW5kX3MiLCJmaW5kX21hcF9yZWMiLCJmaW5kX21hcCIsImZpbmRfbWFwX3NfcmVjIiwiZmluZF9tYXBfcyIsImNvbWJpbmUiLCJzMSIsInMyIiwidDEiLCJ0MiIsIm4xIiwibjIiLCJ4MiIsIngxIiwiYXBwZW5kIiwiY3VycmVudF9zIiwiY29uY2F0Iiwic190b3AiLCJjaG9vc2UiLCJzdHJlYW1zIiwicGFyc2UiLCJoZXhkdW1wIiwibnVtIiwicG9zIiwiY2giLCJMd3Rfc3RyZWFtIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9kb2dhZGlubS8ub3BhbS9lbGlvbS9saWIvbHd0L2x3dF9zdHJlYW0ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7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O0FBQUE7QUFBQSxzQkFBQUQsT0FDYSx1QkFBRztBQUFBLHNCQUFBa0Q7QUFBQUEsY0FFWDtBQUFBLGNBQ0E7QUFBQSxhQUFlLEVBQUM7QUFBQTtBQUFBLFlBQUF1RyxRQUFBOUg7QUFBQUEsUUFBQTBELE1BR1gsa0NBQUFxRSxNQUFnQjtBQUFBLElBQzFCO0FBQUEsc0JBQUExSjtBQUFBQSxrQkFBQSxNQUNFO0FBQUEsY0FBYztBQUFBO0FBQUE7QUFBQSxnQ0FBQXVDO0FBQUFBLHdCQUFLLFFBRWpCO0FBQUEsd0JBRUE7QUFBQSx3QkFDQTtBQUFBLHdCQUFpQztBQUFBLDRCQUFBb0gsTUFrQmpDLEdBQUEzSixRQUFBO0FBQUE7QUFBQSx5QkFoQmM7QUFBQSw2QkFBQXVDLE1BQUEsVUFBQWxCLElBQUE7QUFBQSx5QkFJVixjQUFnQjtBQUFBLHlCQUNoQjtBQUFBLDZCQUFBc0ksUUFBd0M7QUFBQTtBQUFBO0FBQUE7QUFBQSw0QkFBQUEsUUFIeEM7QUFBQTtBQUFBLHlCQU1GO0FBQUEseUJBQWlCO0FBQUEsMEJBRWI7QUFBQTtBQUFBLDBCQUVBO0FBQUEsNkJBQUFBLFFBQ0Y7QUFBQTtBQUFBO0FBQUEsd0JBSUo7QUFBQSx3QkFDQTtBQUFBO0FBQUEsbUNBQUFDO0FBQUFBO0FBQUFBO0FBQUFBLDRCQUFxQixvQ0FBMEQ7QUFBQSxzQ0FBUTtBQUFBO0FBQUEsMkJBQWxFLDhDQUFzRTtBQUFBO0FBQUE7QUFBQSx3QkFDM0Y7QUFBQSxrQ0FDZ0I7QUFBQSx3QkFBcUIsOEJBQUM7QUFBQTtBQUFBLGVBQ3ZDO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1ENWxDTCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cbm9wZW4gTHd0LkluZml4XG5cbmV4Y2VwdGlvbiBDbG9zZWRcbmV4Y2VwdGlvbiBGdWxsXG5leGNlcHRpb24gRW1wdHlcblxuKCogQSBub2RlIGluIGEgcXVldWUgb2YgcGVuZGluZyBkYXRhLiAqKVxudHlwZSAnYSBub2RlID0ge1xuICBtdXRhYmxlIG5leHQgOiAnYSBub2RlO1xuICAoKiBOZXh0IG5vZGUgaW4gdGhlIHF1ZXVlLiBGb3IgdGhlIGxhc3Qgbm9kZSBpdCBwb2ludHMgdG8gaXRzZWxmLiAqKVxuICBtdXRhYmxlIGRhdGEgOiAnYSBvcHRpb247XG4gICgqIERhdGEgb2YgdGhpcyBub2RlLiBGb3IgdGhlIGxhc3Qgbm9kZSBpdCBpcyBhbHdheXMgW05vbmVdLiAqKVxufVxuXG4oKiBOb3RlOiBhIHF1ZXVlIGZvciBhbiBleGhhdXN0ZWQgc3RyZWFtIGlzIHJlcHJlc2VudGVkIGJ5IGEgbm9kZVxuICAgY29udGFpbmluZyBbTm9uZV0gZm9sbG93ZWQgYnkgYSBub2RlIHdpdGggaXRzZWxmIGFzIG5leHQgYW5kIFtOb25lXVxuICAgYXMgZGF0YS4gKilcblxubGV0IG5ld19ub2RlICgpID1cbiAgbGV0IHJlYyBub2RlID0geyBuZXh0ID0gbm9kZTsgZGF0YSA9IE5vbmUgfSBpblxuICBub2RlXG5cbigqIFR5cGUgb2YgYSBzdHJlYW0gc291cmNlIHVzaW5nIGEgZnVuY3Rpb24gdG8gY3JlYXRlIG5ldyBlbGVtZW50cy4gKilcbnR5cGUgJ2EgZnJvbSA9IHtcbiAgZnJvbV9jcmVhdGUgOiB1bml0IC0+ICdhIG9wdGlvbiBMd3QudDtcbiAgKCogRnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgbmV3IGVsZW1lbnRzLiAqKVxuICBtdXRhYmxlIGZyb21fdGhyZWFkIDogdW5pdCBMd3QudDtcbiAgKCogVGhyZWFkIHdoaWNoOlxuXG4gICAgIC0gd2FpdCBmb3IgdGhlIHRocmVhZCByZXR1cm5lZCBieSB0aGUgbGFzdCBjYWxsIHRvIFtmcm9tX25leHRdLFxuICAgICAtIGFkZCB0aGUgbmV4dCBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlLlxuXG4gICAgIElmIGl0IGlzIGEgc2xlZXBpbmcgdGhyZWFkLCB0aGVuIGl0IG11c3QgYmUgdXNlZCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGFcbiAgICAgbmV3IG9uZSB3aXRoIFtmcm9tX2NyZWF0ZV0uICopXG59XG5cbigqIFR5cGUgb2YgYSBzdHJlYW0gc291cmNlIGZvciBwdXNoIHN0cmVhbXMuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi02OVwiXVxudHlwZSBwdXNoID0ge1xuICBtdXRhYmxlIHB1c2hfc2lnbmFsIDogdW5pdCBMd3QudDtcbiAgKCogVGhyZWFkIHNpZ25hbGVkIHdoZW4gYSBuZXcgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgc3RyZWFtLiAqKVxuICBtdXRhYmxlIHB1c2hfd2FpdGluZyA6IGJvb2w7XG4gICgqIElzIGEgdGhyZWFkIHdhaXRpbmcgb24gW3B1c2hfc2lnbmFsXSA/ICopXG4gIG11dGFibGUgcHVzaF9leHRlcm5hbCA6IE9iai50IFtAb2NhbWwud2FybmluZyBcIi02OVwiXTtcbiAgKCogUmVmZXJlbmNlIHRvIGFuIGV4dGVybmFsIHNvdXJjZS4gKilcbn1cblxuKCogVHlwZSBvZiBhIHN0cmVhbSBzb3VyY2UgZm9yIGJvdW5kZWQtcHVzaCBzdHJlYW1zLiAqKVxudHlwZSAnYSBwdXNoX2JvdW5kZWQgPSB7XG4gIG11dGFibGUgcHVzaGJfc2lnbmFsIDogdW5pdCBMd3QudDtcbiAgKCogVGhyZWFkIHNpZ25hbGVkIHdoZW4gYSBuZXcgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgc3RyZWFtLiAqKVxuICBtdXRhYmxlIHB1c2hiX3dhaXRpbmcgOiBib29sO1xuICAoKiBJcyBhIHRocmVhZCB3YWl0aW5nIG9uIFtwdXNoYl9zaWduYWxdID8gKilcbiAgbXV0YWJsZSBwdXNoYl9zaXplIDogaW50O1xuICAoKiBTaXplIG9mIHRoZSBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwdXNoYl9jb3VudCA6IGludDtcbiAgKCogQ3VycmVudCBsZW5ndGggb2YgdGhlIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHB1c2hiX3BlbmRpbmcgOiAnYSBvcHRpb247XG4gICgqIFRoZSBuZXh0IGVsZW1lbnQgdG8gcHVzaCBpZiBhIHRocmVhZCBibG9ja2VkIG9uIHB1c2guIFdlIHN0b3JlIGl0XG4gICAgIGhlcmUgdG8gYmUgc3VyZSBpdCB3aWxsIGJlIHRoZSBmaXJzdCBlbGVtZW50IHRvIGJlIGFkZGVkIHdoZW5cbiAgICAgc3BhY2UgYmVjb21lcyBhdmFpbGFibGUuICopXG4gIG11dGFibGUgcHVzaGJfcHVzaF93YWl0ZXIgOiB1bml0IEx3dC50O1xuICBtdXRhYmxlIHB1c2hiX3B1c2hfd2FrZW5lciA6IHVuaXQgTHd0LnU7XG4gICgqIFRocmVhZCBibG9ja2VkIG9uIHB1c2guICopXG4gIG11dGFibGUgcHVzaGJfZXh0ZXJuYWwgOiBPYmoudCBbQG9jYW1sLndhcm5pbmcgXCItNjlcIl07XG4gICgqIFJlZmVyZW5jZSB0byBhbiBleHRlcm5hbCBzb3VyY2UuICopXG59XG5bQEBAb2NhbWwud2FybmluZyBcIis2OVwiXVxuXG4oKiBTb3VyY2Ugb2YgYSBzdHJlYW0uICopXG50eXBlICdhIHNvdXJjZSA9XG4gIHwgRnJvbSBvZiAnYSBmcm9tXG4gIHwgRnJvbV9kaXJlY3Qgb2YgKHVuaXQgLT4gJ2Egb3B0aW9uKVxuICB8IFB1c2ggb2YgcHVzaFxuICB8IFB1c2hfYm91bmRlZCBvZiAnYSBwdXNoX2JvdW5kZWRcblxudHlwZSAnYSB0ID0ge1xuICBzb3VyY2UgOiAnYSBzb3VyY2U7XG4gICgqIFRoZSBzb3VyY2Ugb2YgdGhlIHN0cmVhbS4gKilcbiAgY2xvc2UgOiB1bml0IEx3dC51O1xuICAoKiBBIHdha2VuZXIgZm9yIGEgdGhyZWFkIHRoYXQgc2xlZXBzIHVudGlsIHRoZSBzdHJlYW0gaXMgY2xvc2VkLiAqKVxuICBjbG9zZWQgOiB1bml0IEx3dC50O1xuICAoKiBBIHdhaXRlciBmb3IgYSB0aHJlYWQgdGhhdCBzbGVlcHMgdW50aWwgdGhlIHN0cmVhbSBpcyBjbG9zZWQuICopXG4gIG11dGFibGUgbm9kZSA6ICdhIG5vZGU7XG4gICgqIFBvaW50ZXIgdG8gZmlyc3QgcGVuZGluZyBlbGVtZW50LCBvciB0byBbbGFzdF0gaWYgdGhlcmUgaXMgbm9cbiAgICAgcGVuZGluZyBlbGVtZW50LiAqKVxuICBsYXN0IDogJ2Egbm9kZSByZWY7XG4gICgqIE5vZGUgbWFya2luZyB0aGUgZW5kIG9mIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIGVsZW1lbnRzLiAqKVxufVxuXG5jbGFzcyB0eXBlIFsnYV0gYm91bmRlZF9wdXNoID0gb2JqZWN0XG4gIG1ldGhvZCBzaXplIDogaW50XG4gIG1ldGhvZCByZXNpemUgOiBpbnQgLT4gdW5pdFxuICBtZXRob2QgcHVzaCA6ICdhIC0+IHVuaXQgTHd0LnRcbiAgbWV0aG9kIGNsb3NlIDogdW5pdFxuICBtZXRob2QgY291bnQgOiBpbnRcbiAgbWV0aG9kIGJsb2NrZWQgOiBib29sXG4gIG1ldGhvZCBjbG9zZWQgOiBib29sXG4gIG1ldGhvZCBzZXRfcmVmZXJlbmNlIDogJ2EuICdhIC0+IHVuaXRcbmVuZFxuXG4oKiBUaGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGNsb25lcyBpcyB0aGUgcG9pbnRlciB0byB0aGUgZmlyc3RcbiAgIHBlbmRpbmcgZWxlbWVudC4gKilcbmxldCBjbG9uZSBzID1cbiAgKG1hdGNoIHMuc291cmNlIHdpdGhcbiAgIHwgUHVzaF9ib3VuZGVkIF8gLT4gaW52YWxpZF9hcmcgXCJMd3Rfc3RyZWFtLmNsb25lXCJcbiAgIHwgRnJvbSBfIHwgRnJvbV9kaXJlY3QgXyB8IFB1c2ggXyAtPiAoKSk7XG4gIHtcbiAgICBzb3VyY2UgPSBzLnNvdXJjZTtcbiAgICBjbG9zZSA9IHMuY2xvc2U7XG4gICAgY2xvc2VkID0gcy5jbG9zZWQ7XG4gICAgbm9kZSA9IHMubm9kZTtcbiAgICBsYXN0ID0gcy5sYXN0O1xuICB9XG5cbmxldCBmcm9tX3NvdXJjZSBzb3VyY2UgPVxuICBsZXQgbm9kZSA9IG5ld19ub2RlICgpIGluXG4gIGxldCBjbG9zZWQsIGNsb3NlID0gTHd0LndhaXQgKCkgaW5cbiAgeyBzb3VyY2UgOyBjbG9zZSA7IGNsb3NlZCA7IG5vZGUgOyBsYXN0ID0gcmVmIG5vZGUgfVxuXG5sZXQgZnJvbSBmID1cbiAgZnJvbV9zb3VyY2UgKEZyb20geyBmcm9tX2NyZWF0ZSA9IGY7IGZyb21fdGhyZWFkID0gTHd0LnJldHVybl91bml0IH0pXG5cbmxldCBmcm9tX2RpcmVjdCBmID1cbiAgZnJvbV9zb3VyY2UgKEZyb21fZGlyZWN0IGYpXG5cbmxldCBjbG9zZWQgcyA9IHMuY2xvc2VkXG5cbmxldCBpc19jbG9zZWQgcyA9XG4gIG5vdCAoTHd0LmlzX3NsZWVwaW5nIChjbG9zZWQgcykpXG5cbmxldCBlbnF1ZXVlJyBlIGxhc3QgPVxuICBsZXQgbm9kZSA9ICFsYXN0XG4gIGFuZCBuZXdfbGFzdCA9IG5ld19ub2RlICgpIGluXG4gIG5vZGUuZGF0YSA8LSBlO1xuICBub2RlLm5leHQgPC0gbmV3X2xhc3Q7XG4gIGxhc3QgOj0gbmV3X2xhc3RcblxubGV0IGVucXVldWUgZSBzID1cbiAgZW5xdWV1ZScgZSBzLmxhc3RcblxubGV0IGNyZWF0ZV93aXRoX3JlZmVyZW5jZSAoKSA9XG4gICgqIENyZWF0ZSB0aGUgc291cmNlIGZvciBub3RpZmljYXRpb25zIG9mIG5ldyBlbGVtZW50cy4gKilcbiAgbGV0IHNvdXJjZSwgcHVzaF9zaWduYWxfcmVzb2x2ZXIgPVxuICAgIGxldCBwdXNoX3NpZ25hbCwgcHVzaF9zaWduYWxfcmVzb2x2ZXIgPSBMd3Qud2FpdCAoKSBpblxuICAgICh7IHB1c2hfc2lnbmFsO1xuICAgICAgIHB1c2hfd2FpdGluZyA9IGZhbHNlO1xuICAgICAgIHB1c2hfZXh0ZXJuYWwgPSBPYmoucmVwciAoKSB9LFxuICAgICByZWYgcHVzaF9zaWduYWxfcmVzb2x2ZXIpXG4gIGluXG4gIGxldCB0ID0gZnJvbV9zb3VyY2UgKFB1c2ggc291cmNlKSBpblxuICAoKiBbcHVzaF0gc2hvdWxkIG5vdCBjbG9zZSBvdmVyIFt0XSBzbyB0aGF0IGl0IGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZCBldmVuXG4gICAqIHRoZXJlIGFyZSBzdGlsbCByZWZlcmVuY2VzIHRvIFtwdXNoXS4gVW5wYWNrIGFsbCB0aGUgY29tcG9uZW50cyBvZiBbdF1cbiAgICogdGhhdCBbcHVzaF0gbmVlZHMgYW5kIHJlZmVyZW5jZSB0aG9zZSBpZGVudGlmaWVycyBpbnN0ZWFkLiAqKVxuICBsZXQgY2xvc2UgPSB0LmNsb3NlIGFuZCBjbG9zZWQgPSB0LmNsb3NlZCBhbmQgbGFzdCA9IHQubGFzdCBpblxuICAoKiBUaGUgcHVzaCBmdW5jdGlvbi4gSXQgZG9lcyBub3Qga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3RyZWFtLiAqKVxuICBsZXQgcHVzaCB4ID1cbiAgICBpZiBub3QgKEx3dC5pc19zbGVlcGluZyBjbG9zZWQpIHRoZW4gcmFpc2UgQ2xvc2VkO1xuICAgICgqIFB1c2ggdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgcXVldWUuICopXG4gICAgZW5xdWV1ZScgeCBsYXN0O1xuICAgICgqIFNlbmQgYSBzaWduYWwgaWYgYXQgbGVhc3Qgb25lIHRocmVhZCBpcyB3YWl0aW5nIGZvciBhIG5ld1xuICAgICAgIGVsZW1lbnQuICopXG4gICAgaWYgc291cmNlLnB1c2hfd2FpdGluZyB0aGVuIGJlZ2luXG4gICAgICBzb3VyY2UucHVzaF93YWl0aW5nIDwtIGZhbHNlO1xuICAgICAgKCogVXBkYXRlIHRocmVhZHMuICopXG4gICAgICBsZXQgb2xkX3B1c2hfc2lnbmFsX3Jlc29sdmVyID0gIXB1c2hfc2lnbmFsX3Jlc29sdmVyIGluXG4gICAgICBsZXQgbmV3X3dhaXRlciwgbmV3X3B1c2hfc2lnbmFsX3Jlc29sdmVyID0gTHd0LndhaXQgKCkgaW5cbiAgICAgIHNvdXJjZS5wdXNoX3NpZ25hbCA8LSBuZXdfd2FpdGVyO1xuICAgICAgcHVzaF9zaWduYWxfcmVzb2x2ZXIgOj0gbmV3X3B1c2hfc2lnbmFsX3Jlc29sdmVyO1xuICAgICAgKCogU2lnbmFsIHRoYXQgYSBuZXcgdmFsdWUgaGFzIGJlZW4gcmVjZWl2ZWQuICopXG4gICAgICBMd3Qud2FrZXVwX2xhdGVyIG9sZF9wdXNoX3NpZ25hbF9yZXNvbHZlciAoKVxuICAgIGVuZDtcbiAgICAoKiBEbyB0aGlzIGF0IHRoZSBlbmQgaW4gY2FzZSBvbmUgb2YgdGhlIGZ1bmN0aW9uIHJhaXNlIGFuXG4gICAgICAgZXhjZXB0aW9uLiAqKVxuICAgIGlmIHggPSBOb25lIHRoZW4gTHd0Lndha2V1cCBjbG9zZSAoKVxuICBpblxuICAodCwgcHVzaCwgZnVuIHggLT4gc291cmNlLnB1c2hfZXh0ZXJuYWwgPC0gT2JqLnJlcHIgeClcblxubGV0IHJldHVybiBhID1cbiAgbGV0IHN0cmVhbSwgcHVzaCwgXyA9IGNyZWF0ZV93aXRoX3JlZmVyZW5jZSAoKSBpblxuICBwdXNoIChTb21lIGEpO1xuICBwdXNoIE5vbmU7XG4gIHN0cmVhbVxuXG5sZXQgcmV0dXJuX2x3dCBhID1cbiAgbGV0IHNvdXJjZSwgcHVzaCwgXyA9IGNyZWF0ZV93aXRoX3JlZmVyZW5jZSAoKSBpblxuICBMd3QuZG9udF93YWl0XG4gICAgKGZ1biAoKSAtPlxuICAgICAgTHd0LmJpbmQgYSAoZnVuIHggLT5cbiAgICAgICAgcHVzaCAoU29tZSB4KTtcbiAgICAgICAgcHVzaCBOb25lO1xuICAgICAgICBMd3QucmV0dXJuX3VuaXQpKVxuICAgIChmdW4gX2V4YyAtPiBwdXNoIE5vbmUpO1xuICBzb3VyY2VcblxubGV0IG9mX3NlcSBzID1cbiAgbGV0IHMgPSByZWYgcyBpblxuICBsZXQgZ2V0ICgpID1cbiAgICBtYXRjaCAhcyAoKSB3aXRoXG4gICAgfCBTZXEuTmlsIC0+IE5vbmVcbiAgICB8IFNlcS5Db25zIChlbHQsIHMnKSAtPiBzIDo9IHMnOyBTb21lIGVsdFxuICBpblxuICBmcm9tX2RpcmVjdCBnZXRcblxubGV0IG9mX2x3dF9zZXEgcyA9XG4gIGxldCBzID0gcmVmIHMgaW5cbiAgbGV0IGdldCAoKSA9XG4gICAgIXMgKCkgPnw9IGZ1bmN0aW9uXG4gICAgfCBMd3Rfc2VxLk5pbCAtPiBOb25lXG4gICAgfCBMd3Rfc2VxLkNvbnMgKGVsdCwgcycpIC0+IHMgOj0gcyc7IFNvbWUgZWx0XG4gIGluXG4gIGZyb20gZ2V0XG5cblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCBzb3VyY2UsIHB1c2gsIF8gPSBjcmVhdGVfd2l0aF9yZWZlcmVuY2UgKCkgaW5cbiAgKHNvdXJjZSwgcHVzaClcblxubGV0IG9mX2l0ZXIgaXRlciBpID1cbiAgbGV0IHN0cmVhbSwgcHVzaCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIChmdW4geCAtPiBwdXNoIChTb21lIHgpKSBpO1xuICBwdXNoIE5vbmU7XG4gIHN0cmVhbVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgb2ZfaXRlciBMaXN0Lml0ZXIgbFxuXG5sZXQgb2ZfYXJyYXkgYSA9XG4gIG9mX2l0ZXIgQXJyYXkuaXRlciBhXG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gIG9mX2l0ZXIgU3RyaW5nLml0ZXIgc1xuXG4oKiBBZGQgdGhlIHBlbmRpbmcgZWxlbWVudCB0byB0aGUgcXVldWUgYW5kIG5vdGlmeSB0aGUgYmxvY2tlZCBwdXNoZWQuXG5cbiAgIFByZWNvbmRpdGlvbjogaW5mby5wdXNoYl9wZW5kaW5nID0gU29tZSBfXG5cbiAgIFRoaXMgZG9lcyBub3QgbW9kaWZ5IGluZm8ucHVzaGJfY291bnQuICopXG5sZXQgbm90aWZ5X3B1c2hlciBpbmZvIGxhc3QgPVxuICAoKiBQdXNoIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIHF1ZXVlLiAqKVxuICBlbnF1ZXVlJyBpbmZvLnB1c2hiX3BlbmRpbmcgbGFzdDtcbiAgKCogQ2xlYXIgcGVuZGluZyBlbGVtZW50LiAqKVxuICBpbmZvLnB1c2hiX3BlbmRpbmcgPC0gTm9uZTtcbiAgKCogV2FrZXVwIHRoZSBwdXNoZXIuICopXG4gIGxldCBvbGRfd2FrZW5lciA9IGluZm8ucHVzaGJfcHVzaF93YWtlbmVyIGluXG4gIGxldCB3YWl0ZXIsIHdha2VuZXIgPSBMd3QudGFzayAoKSBpblxuICBpbmZvLnB1c2hiX3B1c2hfd2FpdGVyIDwtIHdhaXRlcjtcbiAgaW5mby5wdXNoYl9wdXNoX3dha2VuZXIgPC0gd2FrZW5lcjtcbiAgTHd0Lndha2V1cF9sYXRlciBvbGRfd2FrZW5lciAoKVxuXG5jbGFzcyBbJ2FdIGJvdW5kZWRfcHVzaF9pbXBsIChpbmZvIDogJ2EgcHVzaF9ib3VuZGVkKSB3YWtlbmVyX2NlbGwgbGFzdCBjbG9zZSA9IG9iamVjdFxuICB2YWwgbXV0YWJsZSBjbG9zZWQgPSBmYWxzZVxuXG4gIG1ldGhvZCBzaXplID1cbiAgICBpbmZvLnB1c2hiX3NpemVcblxuICBtZXRob2QgcmVzaXplIHNpemUgPVxuICAgIGlmIHNpemUgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMd3Rfc3RyZWFtLmJvdW5kZWRfcHVzaCNyZXNpemVcIjtcbiAgICBpbmZvLnB1c2hiX3NpemUgPC0gc2l6ZTtcbiAgICBpZiBpbmZvLnB1c2hiX2NvdW50IDwgaW5mby5wdXNoYl9zaXplICYmIGluZm8ucHVzaGJfcGVuZGluZyA8PiBOb25lIHRoZW4gYmVnaW5cbiAgICAgIGluZm8ucHVzaGJfY291bnQgPC0gaW5mby5wdXNoYl9jb3VudCArIDE7XG4gICAgICBub3RpZnlfcHVzaGVyIGluZm8gbGFzdFxuICAgIGVuZFxuXG4gIG1ldGhvZCBwdXNoIHggPVxuICAgIGlmIGNsb3NlZCB0aGVuXG4gICAgICBMd3QuZmFpbCBDbG9zZWRcbiAgICBlbHNlIGlmIGluZm8ucHVzaGJfcGVuZGluZyA8PiBOb25lIHRoZW5cbiAgICAgIEx3dC5mYWlsIEZ1bGxcbiAgICBlbHNlIGlmIGluZm8ucHVzaGJfY291bnQgPj0gaW5mby5wdXNoYl9zaXplIHRoZW4gYmVnaW5cbiAgICAgIGluZm8ucHVzaGJfcGVuZGluZyA8LSBTb21lIHg7XG4gICAgICBMd3QuY2F0Y2hcbiAgICAgICAgKGZ1biAoKSAtPiBpbmZvLnB1c2hiX3B1c2hfd2FpdGVyKVxuICAgICAgICAoZnVuIGV4biAtPlxuICAgICAgICAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgICAgICB8IEx3dC5DYW5jZWxlZCAtPlxuICAgICAgICAgICAgIGluZm8ucHVzaGJfcGVuZGluZyA8LSBOb25lO1xuICAgICAgICAgICAgIGxldCB3YWl0ZXIsIHdha2VuZXIgPSBMd3QudGFzayAoKSBpblxuICAgICAgICAgICAgIGluZm8ucHVzaGJfcHVzaF93YWl0ZXIgPC0gd2FpdGVyO1xuICAgICAgICAgICAgIGluZm8ucHVzaGJfcHVzaF93YWtlbmVyIDwtIHdha2VuZXI7XG4gICAgICAgICAgICAgTHd0LnJlcmFpc2UgZXhuXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgIEx3dC5yZXJhaXNlIGV4bilcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgKCogUHVzaCB0aGUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gKilcbiAgICAgIGVucXVldWUnIChTb21lIHgpIGxhc3Q7XG4gICAgICBpbmZvLnB1c2hiX2NvdW50IDwtIGluZm8ucHVzaGJfY291bnQgKyAxO1xuICAgICAgKCogU2VuZCBhIHNpZ25hbCBpZiBhdCBsZWFzdCBvbmUgdGhyZWFkIGlzIHdhaXRpbmcgZm9yIGEgbmV3XG4gICAgICAgICBlbGVtZW50LiAqKVxuICAgICAgaWYgaW5mby5wdXNoYl93YWl0aW5nIHRoZW4gYmVnaW5cbiAgICAgICAgaW5mby5wdXNoYl93YWl0aW5nIDwtIGZhbHNlO1xuICAgICAgICAoKiBVcGRhdGUgdGhyZWFkcy4gKilcbiAgICAgICAgbGV0IG9sZF93YWtlbmVyID0gIXdha2VuZXJfY2VsbCBpblxuICAgICAgICBsZXQgbmV3X3dhaXRlciwgbmV3X3dha2VuZXIgPSBMd3Qud2FpdCAoKSBpblxuICAgICAgICBpbmZvLnB1c2hiX3NpZ25hbCA8LSBuZXdfd2FpdGVyO1xuICAgICAgICB3YWtlbmVyX2NlbGwgOj0gbmV3X3dha2VuZXI7XG4gICAgICAgICgqIFNpZ25hbCB0aGF0IGEgbmV3IHZhbHVlIGhhcyBiZWVuIHJlY2VpdmVkLiAqKVxuICAgICAgICBMd3Qud2FrZXVwX2xhdGVyIG9sZF93YWtlbmVyICgpXG4gICAgICBlbmQ7XG4gICAgICBMd3QucmV0dXJuX3VuaXRcbiAgICBlbmRcblxuICBtZXRob2QgY2xvc2UgPVxuICAgIGlmIG5vdCBjbG9zZWQgdGhlbiBiZWdpblxuICAgICAgY2xvc2VkIDwtIHRydWU7XG4gICAgICBsZXQgbm9kZSA9ICFsYXN0IGFuZCBuZXdfbGFzdCA9IG5ld19ub2RlICgpIGluXG4gICAgICBub2RlLmRhdGEgPC0gTm9uZTtcbiAgICAgIG5vZGUubmV4dCA8LSBuZXdfbGFzdDtcbiAgICAgIGxhc3QgOj0gbmV3X2xhc3Q7XG4gICAgICBpZiBpbmZvLnB1c2hiX3BlbmRpbmcgPD4gTm9uZSB0aGVuIGJlZ2luXG4gICAgICAgIGluZm8ucHVzaGJfcGVuZGluZyA8LSBOb25lO1xuICAgICAgICBMd3Qud2FrZXVwX2xhdGVyX2V4biBpbmZvLnB1c2hiX3B1c2hfd2FrZW5lciBDbG9zZWRcbiAgICAgIGVuZDtcbiAgICAgICgqIFNlbmQgYSBzaWduYWwgaWYgYXQgbGVhc3Qgb25lIHRocmVhZCBpcyB3YWl0aW5nIGZvciBhIG5ld1xuICAgICAgICAgZWxlbWVudC4gKilcbiAgICAgIGlmIGluZm8ucHVzaGJfd2FpdGluZyB0aGVuIGJlZ2luXG4gICAgICAgIGluZm8ucHVzaGJfd2FpdGluZyA8LSBmYWxzZTtcbiAgICAgICAgbGV0IG9sZF93YWtlbmVyID0gIXdha2VuZXJfY2VsbCBpblxuICAgICAgICAoKiBTaWduYWwgdGhhdCBhIG5ldyB2YWx1ZSBoYXMgYmVlbiByZWNlaXZlZC4gKilcbiAgICAgICAgTHd0Lndha2V1cF9sYXRlciBvbGRfd2FrZW5lciAoKVxuICAgICAgZW5kO1xuICAgICAgTHd0Lndha2V1cCBjbG9zZSAoKTtcbiAgICBlbmRcblxuICBtZXRob2QgY291bnQgPVxuICAgIGluZm8ucHVzaGJfY291bnRcblxuICBtZXRob2QgYmxvY2tlZCA9XG4gICAgaW5mby5wdXNoYl9wZW5kaW5nIDw+IE5vbmVcblxuICBtZXRob2QgY2xvc2VkID1cbiAgICBjbG9zZWRcblxuICBtZXRob2Qgc2V0X3JlZmVyZW5jZSA6ICdhLiAnYSAtPiB1bml0ID1cbiAgICBmdW4geCAtPiBpbmZvLnB1c2hiX2V4dGVybmFsIDwtIE9iai5yZXByIHhcbmVuZFxuXG5sZXQgY3JlYXRlX2JvdW5kZWQgc2l6ZSA9XG4gIGlmIHNpemUgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMd3Rfc3RyZWFtLmNyZWF0ZV9ib3VuZGVkXCI7XG4gICgqIENyZWF0ZSB0aGUgc291cmNlIGZvciBub3RpZmljYXRpb25zIG9mIG5ldyBlbGVtZW50cy4gKilcbiAgbGV0IGluZm8sIHdha2VuZXJfY2VsbCA9XG4gICAgbGV0IHdhaXRlciwgd2FrZW5lciA9IEx3dC53YWl0ICgpIGluXG4gICAgbGV0IHB1c2hfd2FpdGVyLCBwdXNoX3dha2VuZXIgPSBMd3QudGFzayAoKSBpblxuICAgICh7IHB1c2hiX3NpZ25hbCA9IHdhaXRlcjtcbiAgICAgICBwdXNoYl93YWl0aW5nID0gZmFsc2U7XG4gICAgICAgcHVzaGJfc2l6ZSA9IHNpemU7XG4gICAgICAgcHVzaGJfY291bnQgPSAwO1xuICAgICAgIHB1c2hiX3BlbmRpbmcgPSBOb25lO1xuICAgICAgIHB1c2hiX3B1c2hfd2FpdGVyID0gcHVzaF93YWl0ZXI7XG4gICAgICAgcHVzaGJfcHVzaF93YWtlbmVyID0gcHVzaF93YWtlbmVyO1xuICAgICAgIHB1c2hiX2V4dGVybmFsID0gT2JqLnJlcHIgKCkgfSxcbiAgICAgcmVmIHdha2VuZXIpXG4gIGluXG4gIGxldCB0ID0gZnJvbV9zb3VyY2UgKFB1c2hfYm91bmRlZCBpbmZvKSBpblxuICAodCwgbmV3IGJvdW5kZWRfcHVzaF9pbXBsIGluZm8gd2FrZW5lcl9jZWxsIHQubGFzdCB0LmNsb3NlKVxuXG4oKiBXYWl0IGZvciBhIG5ldyBlbGVtZW50IHRvIGJlIGFkZGVkIHRvIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIGVsZW1lbnRcbiAgIG9mIHRoZSBzdHJlYW0uICopXG5sZXQgZmVlZCBzID1cbiAgbWF0Y2ggcy5zb3VyY2Ugd2l0aFxuICB8IEZyb20gZnJvbSAtPlxuICAgICgqIFRoZXJlIGlzIGFscmVhZHkgYSB0aHJlYWQgc3RhcnRlZCB0byBjcmVhdGUgYSBuZXcgZWxlbWVudCxcbiAgICAgICB3YWl0IGZvciB0aGlzIG9uZSB0byB0ZXJtaW5hdGUuICopXG4gICAgaWYgTHd0LmlzX3NsZWVwaW5nIGZyb20uZnJvbV90aHJlYWQgdGhlblxuICAgICAgTHd0LnByb3RlY3RlZCBmcm9tLmZyb21fdGhyZWFkXG4gICAgZWxzZSBiZWdpblxuICAgICAgKCogT3RoZXJ3aXNlIHJlcXVlc3QgYSBuZXcgZWxlbWVudC4gKilcbiAgICAgIGxldCB0aHJlYWQgPVxuICAgICAgICAoKiBUaGUgZnVuY3Rpb24gW2Zyb21fY3JlYXRlXSBjYW4gcmFpc2UgYW4gZXhjZXB0aW9uICh3aXRoXG4gICAgICAgICAgIFtyYWlzZV0sIHJhdGhlciB0aGFuIHJldHVybmluZyBhIGZhaWxlZCBwcm9taXNlIHdpdGhcbiAgICAgICAgICAgW0x3dC5mYWlsXSkuIEluIHRoaXMgY2FzZSwgd2UgaGF2ZSB0byBjYXRjaCB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgIGFuZCB0dXJuIGl0IGludG8gYSBzYWZlIGZhaWxlZCBwcm9taXNlLiAqKVxuICAgICAgICBMd3QuY2F0Y2hcbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICBmcm9tLmZyb21fY3JlYXRlICgpID4+PSBmdW4geCAtPlxuICAgICAgICAgICAgKCogUHVzaCB0aGUgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gKilcbiAgICAgICAgICAgIGVucXVldWUgeCBzO1xuICAgICAgICAgICAgaWYgeCA9IE5vbmUgdGhlbiBMd3Qud2FrZXVwIHMuY2xvc2UgKCk7XG4gICAgICAgICAgICBMd3QucmV0dXJuX3VuaXQpXG4gICAgICAgICAgTHd0LnJlcmFpc2VcbiAgICAgIGluXG4gICAgICAoKiBBbGxvdyBvdGhlciB0aHJlYWRzIHRvIGFjY2VzcyB0aGlzIHRocmVhZC4gKilcbiAgICAgIGZyb20uZnJvbV90aHJlYWQgPC0gdGhyZWFkO1xuICAgICAgTHd0LnByb3RlY3RlZCB0aHJlYWRcbiAgICBlbmRcbiAgfCBGcm9tX2RpcmVjdCBmIC0+XG4gICAgbGV0IHggPSBmICgpIGluXG4gICAgKCogUHVzaCB0aGUgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gKilcbiAgICBlbnF1ZXVlIHggcztcbiAgICBpZiB4ID0gTm9uZSB0aGVuIEx3dC53YWtldXAgcy5jbG9zZSAoKTtcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgfCBQdXNoIHB1c2ggLT5cbiAgICBwdXNoLnB1c2hfd2FpdGluZyA8LSB0cnVlO1xuICAgIEx3dC5wcm90ZWN0ZWQgcHVzaC5wdXNoX3NpZ25hbFxuICB8IFB1c2hfYm91bmRlZCBwdXNoIC0+XG4gICAgcHVzaC5wdXNoYl93YWl0aW5nIDwtIHRydWU7XG4gICAgTHd0LnByb3RlY3RlZCBwdXNoLnB1c2hiX3NpZ25hbFxuXG4oKiBSZW1vdmUgW25vZGVdIGZyb20gdGhlIHRvcCBvZiB0aGUgcXVldWUsIG9yIGRvIG5vdGhpbmcgaWYgaXQgd2FzXG4gICBhbHJlYWR5IGNvbnN1bWVkLlxuXG4gICBQcmVjb25kaXRpb246IG5vZGUuZGF0YSA8PiBOb25lXG4qKVxubGV0IGNvbnN1bWUgcyBub2RlID1cbiAgaWYgbm9kZSA9PSBzLm5vZGUgdGhlbiBiZWdpblxuICAgIHMubm9kZSA8LSBub2RlLm5leHQ7XG4gICAgbWF0Y2ggcy5zb3VyY2Ugd2l0aFxuICAgIHwgUHVzaF9ib3VuZGVkIGluZm8gLT5cbiAgICAgIGlmIGluZm8ucHVzaGJfcGVuZGluZyA9IE5vbmUgdGhlblxuICAgICAgICBpbmZvLnB1c2hiX2NvdW50IDwtIGluZm8ucHVzaGJfY291bnQgLSAxXG4gICAgICBlbHNlXG4gICAgICAgIG5vdGlmeV9wdXNoZXIgaW5mbyBzLmxhc3RcbiAgICB8IEZyb20gXyB8IEZyb21fZGlyZWN0IF8gfCBQdXNoIF8gLT5cbiAgICAgICgpXG4gIGVuZFxuXG5sZXQgcmVjIHBlZWtfcmVjIHMgbm9kZSA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBwZWVrX3JlYyBzIG5vZGVcbiAgZWxzZVxuICAgIEx3dC5yZXR1cm4gbm9kZS5kYXRhXG5cbmxldCBwZWVrIHMgPSBwZWVrX3JlYyBzIHMubm9kZVxuXG5sZXQgcmVjIG5wZWVrX3JlYyBub2RlIGFjYyBuIHMgPVxuICBpZiBuIDw9IDAgdGhlblxuICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcbiAgZWxzZSBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gbnBlZWtfcmVjIG5vZGUgYWNjIG4gc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbnBlZWtfcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIChuIC0gMSkgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG5sZXQgbnBlZWsgbiBzID0gbnBlZWtfcmVjIHMubm9kZSBbXSBuIHNcblxubGV0IHJlYyBnZXRfcmVjIHMgbm9kZSA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBnZXRfcmVjIHMgbm9kZVxuICBlbHNlIGJlZ2luXG4gICAgaWYgbm9kZS5kYXRhIDw+IE5vbmUgdGhlbiBjb25zdW1lIHMgbm9kZTtcbiAgICBMd3QucmV0dXJuIG5vZGUuZGF0YVxuICBlbmRcblxubGV0IGdldCBzID0gZ2V0X3JlYyBzIHMubm9kZVxuXG5sZXQgcmVjIGdldF9leG5fcmVjIHMgbm9kZSA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBMd3QudHJ5X2JpbmRcbiAgICAgIChmdW4gKCkgLT4gZmVlZCBzKVxuICAgICAgKGZ1biAoKSAtPiBnZXRfZXhuX3JlYyBzIG5vZGUpXG4gICAgICAoZnVuIGV4biAtPiBMd3QucmV0dXJuIChTb21lIChSZXN1bHQuRXJyb3IgZXhuKSkpXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBMd3QucmV0dXJuIChTb21lIChSZXN1bHQuT2sgdmFsdWUpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG5cbmxldCB3cmFwX2V4biBzID0gZnJvbSAoZnVuICgpIC0+IGdldF9leG5fcmVjIHMgcy5ub2RlKVxuXG5sZXQgcmVjIG5nZXRfcmVjIG5vZGUgYWNjIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuXG4gICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuICBlbHNlIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBuZ2V0X3JlYyBub2RlIGFjYyBuIHNcbiAgZWxzZVxuICAgIG1hdGNoIHMubm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBuZ2V0X3JlYyBub2RlLm5leHQgKHggOjogYWNjKSAobiAtIDEpIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcblxubGV0IG5nZXQgbiBzID0gbmdldF9yZWMgcy5ub2RlIFtdIG4gc1xuXG5sZXQgcmVjIGdldF93aGlsZV9yZWMgbm9kZSBhY2MgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGdldF93aGlsZV9yZWMgbm9kZSBhY2MgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBsZXQgdGVzdCA9IGYgeCBpblxuICAgICAgaWYgdGVzdCB0aGVuIGJlZ2luXG4gICAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgICBnZXRfd2hpbGVfcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIGYgc1xuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG5sZXQgZ2V0X3doaWxlIGYgcyA9IGdldF93aGlsZV9yZWMgcy5ub2RlIFtdIGYgc1xuXG5sZXQgcmVjIGdldF93aGlsZV9zX3JlYyBub2RlIGFjYyBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZ2V0X3doaWxlX3NfcmVjIG5vZGUgYWNjIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPiBiZWdpblxuICAgICAgICBmIHggPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgICAgIGdldF93aGlsZV9zX3JlYyBub2RlLm5leHQgKHggOjogYWNjKSBmIHNcbiAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcbiAgICAgIGVuZFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG5sZXQgZ2V0X3doaWxlX3MgZiBzID0gZ2V0X3doaWxlX3NfcmVjIHMubm9kZSBbXSBmIHNcblxubGV0IHJlYyBuZXh0X3JlYyBzIG5vZGUgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gbmV4dF9yZWMgcyBub2RlXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIEx3dC5yZXR1cm4geFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LmZhaWwgRW1wdHlcblxubGV0IG5leHQgcyA9IG5leHRfcmVjIHMgcy5ub2RlXG5cbmxldCByZWMgbGFzdF9uZXdfcmVjIG5vZGUgeCBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGxldCB0aHJlYWQgPSBmZWVkIHMgaW5cbiAgICBtYXRjaCBMd3Quc3RhdGUgdGhyZWFkIHdpdGhcbiAgICB8IEx3dC5SZXR1cm4gXyAtPlxuICAgICAgbGFzdF9uZXdfcmVjIG5vZGUgeCBzXG4gICAgfCBMd3QuRmFpbCBleG4gLT5cbiAgICAgIEx3dC5mYWlsIGV4blxuICAgIHwgTHd0LlNsZWVwIC0+XG4gICAgICBMd3QucmV0dXJuIHhcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGFzdF9uZXdfcmVjIG5vZGUubmV4dCB4IHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4geFxuXG5sZXQgbGFzdF9uZXcgcyA9XG4gIGxldCBub2RlID0gcy5ub2RlIGluXG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBsZXQgdGhyZWFkID0gbmV4dCBzIGluXG4gICAgbWF0Y2ggTHd0LnN0YXRlIHRocmVhZCB3aXRoXG4gICAgfCBMd3QuUmV0dXJuIHggLT5cbiAgICAgIGxhc3RfbmV3X3JlYyBub2RlIHggc1xuICAgIHwgTHd0LkZhaWwgXyB8IEx3dC5TbGVlcCAtPlxuICAgICAgdGhyZWFkXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxhc3RfbmV3X3JlYyBub2RlLm5leHQgeCBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QuZmFpbCBFbXB0eVxuXG5sZXQgcmVjIHRvX2xpc3RfcmVjIG5vZGUgYWNjIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gdG9fbGlzdF9yZWMgbm9kZSBhY2Mgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICB0b19saXN0X3JlYyBub2RlLm5leHQgKHggOjogYWNjKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG5cbmxldCB0b19saXN0IHMgPSB0b19saXN0X3JlYyBzLm5vZGUgW10gc1xuXG5sZXQgcmVjIHRvX3N0cmluZ19yZWMgbm9kZSBidWYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiB0b19zdHJpbmdfcmVjIG5vZGUgYnVmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiB4O1xuICAgICAgdG9fc3RyaW5nX3JlYyBub2RlLm5leHQgYnVmIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKEJ1ZmZlci5jb250ZW50cyBidWYpXG5cbmxldCB0b19zdHJpbmcgcyA9IHRvX3N0cmluZ19yZWMgcy5ub2RlIChCdWZmZXIuY3JlYXRlIDEyOCkgc1xuXG5sZXQganVuayBzID1cbiAgbGV0IG5vZGUgPSBzLm5vZGUgaW5cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlbiBiZWdpblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+XG4gICAgaWYgbm9kZS5kYXRhIDw+IE5vbmUgdGhlbiBjb25zdW1lIHMgbm9kZTtcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICBpZiBub2RlLmRhdGEgPD4gTm9uZSB0aGVuIGNvbnN1bWUgcyBub2RlO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICBlbmRcblxubGV0IHJlYyBuanVua19yZWMgbm9kZSBuIHMgPVxuICBpZiBuIDw9IDAgdGhlblxuICAgIEx3dC5yZXR1cm5fdW5pdFxuICBlbHNlIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBuanVua19yZWMgbm9kZSBuIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIF8gLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbmp1bmtfcmVjIG5vZGUubmV4dCAobiAtIDEpIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgbmp1bmsgbiBzID0gbmp1bmtfcmVjIHMubm9kZSBuIHNcblxubGV0IHJlYyBqdW5rX3doaWxlX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBqdW5rX3doaWxlX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbGV0IHRlc3QgPSBmIHggaW5cbiAgICAgIGlmIHRlc3QgdGhlbiBiZWdpblxuICAgICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgICAganVua193aGlsZV9yZWMgbm9kZS5uZXh0IGYgc1xuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IGp1bmtfd2hpbGUgZiBzID0ganVua193aGlsZV9yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGp1bmtfd2hpbGVfc19yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4ganVua193aGlsZV9zX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPiBiZWdpblxuICAgICAgICBmIHggPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgICAgIGp1bmtfd2hpbGVfc19yZWMgbm9kZS5uZXh0IGYgc1xuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgICBlbmRcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQganVua193aGlsZV9zIGYgcyA9IGp1bmtfd2hpbGVfc19yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGp1bmtfYXZhaWxhYmxlX3JlYyBub2RlIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgbGV0IHRocmVhZCA9IGZlZWQgcyBpblxuICAgIG1hdGNoIEx3dC5zdGF0ZSB0aHJlYWQgd2l0aFxuICAgIHwgTHd0LlJldHVybiBfIC0+XG4gICAgICBqdW5rX2F2YWlsYWJsZV9yZWMgbm9kZSBzXG4gICAgfCBMd3QuRmFpbCBleG4gLT5cbiAgICAgIHJhaXNlIGV4blxuICAgIHwgTHd0LlNsZWVwIC0+XG4gICAgICAoKVxuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgXyAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBqdW5rX2F2YWlsYWJsZV9yZWMgbm9kZS5uZXh0IHNcbiAgICB8IE5vbmUgLT5cbiAgICAgICgpXG5cbmxldCBqdW5rX2F2YWlsYWJsZSBzID0ganVua19hdmFpbGFibGVfcmVjIHMubm9kZSBzXG5cbmxldCBqdW5rX29sZCBzID0gTHd0LnJldHVybiAoanVua19hdmFpbGFibGUgcylcblxubGV0IHJlYyBnZXRfYXZhaWxhYmxlX3JlYyBub2RlIGFjYyBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGxldCB0aHJlYWQgPSBmZWVkIHMgaW5cbiAgICBtYXRjaCBMd3Quc3RhdGUgdGhyZWFkIHdpdGhcbiAgICB8IEx3dC5SZXR1cm4gXyAtPlxuICAgICAgZ2V0X2F2YWlsYWJsZV9yZWMgbm9kZSBhY2Mgc1xuICAgIHwgTHd0LkZhaWwgZXhuIC0+XG4gICAgICByYWlzZSBleG5cbiAgICB8IEx3dC5TbGVlcCAtPlxuICAgICAgTGlzdC5yZXYgYWNjXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGdldF9hdmFpbGFibGVfcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIExpc3QucmV2IGFjY1xuXG5sZXQgZ2V0X2F2YWlsYWJsZSBzID0gZ2V0X2F2YWlsYWJsZV9yZWMgcy5ub2RlIFtdIHNcblxubGV0IHJlYyBnZXRfYXZhaWxhYmxlX3VwX3RvX3JlYyBub2RlIGFjYyBuIHMgPVxuICBpZiBuIDw9IDAgdGhlblxuICAgIExpc3QucmV2IGFjY1xuICBlbHNlIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBsZXQgdGhyZWFkID0gZmVlZCBzIGluXG4gICAgbWF0Y2ggTHd0LnN0YXRlIHRocmVhZCB3aXRoXG4gICAgfCBMd3QuUmV0dXJuIF8gLT5cbiAgICAgIGdldF9hdmFpbGFibGVfdXBfdG9fcmVjIG5vZGUgYWNjIG4gc1xuICAgIHwgTHd0LkZhaWwgZXhuIC0+XG4gICAgICByYWlzZSBleG5cbiAgICB8IEx3dC5TbGVlcCAtPlxuICAgICAgTGlzdC5yZXYgYWNjXG4gIGVsc2VcbiAgICBtYXRjaCBzLm5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgZ2V0X2F2YWlsYWJsZV91cF90b19yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgKG4gLSAxKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMaXN0LnJldiBhY2NcblxubGV0IGdldF9hdmFpbGFibGVfdXBfdG8gbiBzID0gZ2V0X2F2YWlsYWJsZV91cF90b19yZWMgcy5ub2RlIFtdIG4gc1xuXG5sZXQgcmVjIGlzX2VtcHR5IHMgPVxuICBpZiBzLm5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBpc19lbXB0eSBzXG4gIGVsc2VcbiAgICBMd3QucmV0dXJuIChzLm5vZGUuZGF0YSA9IE5vbmUpXG5cbmxldCBtYXAgZiBzID1cbiAgZnJvbSAoZnVuICgpIC0+IGdldCBzID58PSBmdW5jdGlvblxuICB8IFNvbWUgeCAtPlxuICAgIGxldCB4ID0gZiB4IGluXG4gICAgU29tZSB4XG4gIHwgTm9uZSAtPlxuICAgIE5vbmUpXG5cbmxldCBtYXBfcyBmIHMgPVxuICBmcm9tIChmdW4gKCkgLT4gZ2V0IHMgPj49IGZ1bmN0aW9uXG4gIHwgU29tZSB4IC0+XG4gICAgZiB4ID58PSAoZnVuIHggLT4gU29tZSB4KVxuICB8IE5vbmUgLT5cbiAgICBMd3QucmV0dXJuX25vbmUpXG5cbmxldCBmaWx0ZXIgZiBzID1cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBsZXQgdCA9IGdldCBzIGluXG4gICAgdCA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbGV0IHRlc3QgPSBmIHggaW5cbiAgICAgIGlmIHRlc3QgdGhlblxuICAgICAgICB0XG4gICAgICBlbHNlXG4gICAgICAgIG5leHQgKClcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGZpbHRlcl9zIGYgcyA9XG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbGV0IHQgPSBnZXQgcyBpblxuICAgIHQgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIHggLT4gYmVnaW5cbiAgICAgICAgZiB4ID4+PSBmdW5jdGlvblxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICB0XG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICBuZXh0ICgpXG4gICAgICBlbmRcbiAgICB8IE5vbmUgLT5cbiAgICAgIHRcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBmaWx0ZXJfbWFwIGYgcyA9XG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgZ2V0IHMgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICAobWF0Y2ggeCB3aXRoXG4gICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgIEx3dC5yZXR1cm4geFxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgbmV4dCAoKSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGZpbHRlcl9tYXBfcyBmIHMgPVxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGdldCBzID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSB4IC0+XG4gICAgICBsZXQgdCA9IGYgeCBpblxuICAgICAgKHQgPj49IGZ1bmN0aW9uXG4gICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgIHRcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIG5leHQgKCkpXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBtYXBfbGlzdCBmIHMgPVxuICBsZXQgcGVuZGluZ3MgPSByZWYgW10gaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCAhcGVuZGluZ3Mgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIChnZXQgcyA+Pj0gZnVuY3Rpb25cbiAgICAgICB8IFNvbWUgeCAtPlxuICAgICAgICAgbGV0IGwgPSBmIHggaW5cbiAgICAgICAgIHBlbmRpbmdzIDo9IGw7XG4gICAgICAgICBuZXh0ICgpXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBMd3QucmV0dXJuX25vbmUpXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgIHBlbmRpbmdzIDo9IGw7XG4gICAgICBMd3QucmV0dXJuIChTb21lIHgpXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgbWFwX2xpc3RfcyBmIHMgPVxuICBsZXQgcGVuZGluZ3MgPSByZWYgW10gaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCAhcGVuZGluZ3Mgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIChnZXQgcyA+Pj0gZnVuY3Rpb25cbiAgICAgICB8IFNvbWUgeCAtPlxuICAgICAgICAgZiB4ID4+PSBmdW4gbCAtPlxuICAgICAgICAgcGVuZGluZ3MgOj0gbDtcbiAgICAgICAgIG5leHQgKClcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIEx3dC5yZXR1cm5fbm9uZSlcbiAgICB8IHggOjogbCAtPlxuICAgICAgcGVuZGluZ3MgOj0gbDtcbiAgICAgIEx3dC5yZXR1cm4gKFNvbWUgeClcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBmbGF0dGVuIHMgPVxuICBtYXBfbGlzdCAoZnVuIGwgLT4gbCkgc1xuXG5sZXQgcmVjIGZvbGRfcmVjIG5vZGUgZiBzIGFjYyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmb2xkX3JlYyBub2RlIGYgcyBhY2NcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0IGFjYyA9IGYgeCBhY2MgaW5cbiAgICAgIGZvbGRfcmVjIG5vZGUubmV4dCBmIHMgYWNjXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIGFjY1xuXG5sZXQgZm9sZCBmIHMgYWNjID0gZm9sZF9yZWMgcy5ub2RlIGYgcyBhY2NcblxubGV0IHJlYyBmb2xkX3NfcmVjIG5vZGUgZiBzIGFjYyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmb2xkX3NfcmVjIG5vZGUgZiBzIGFjY1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBmIHggYWNjID4+PSBmdW4gYWNjIC0+XG4gICAgICBmb2xkX3NfcmVjIG5vZGUubmV4dCBmIHMgYWNjXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIGFjY1xuXG5sZXQgZm9sZF9zIGYgcyBhY2MgPSBmb2xkX3NfcmVjIHMubm9kZSBmIHMgYWNjXG5cbmxldCByZWMgaXRlcl9yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gaXRlcl9yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0ICgpID0gZiB4IGluXG4gICAgICBpdGVyX3JlYyBub2RlLm5leHQgZiBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IGl0ZXIgZiBzID0gaXRlcl9yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGl0ZXJfc19yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gaXRlcl9zX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBmIHggPj49IGZ1biAoKSAtPlxuICAgICAgaXRlcl9zX3JlYyBub2RlLm5leHQgZiBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IGl0ZXJfcyBmIHMgPSBpdGVyX3NfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBpdGVyX3BfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGl0ZXJfcF9yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0IHJlcyA9IGYgeCBpblxuICAgICAgbGV0IHJlc3QgPSBpdGVyX3BfcmVjIG5vZGUubmV4dCBmIHMgaW5cbiAgICAgIHJlcyA+Pj0gZnVuICgpIC0+IHJlc3RcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgaXRlcl9wIGYgcyA9IGl0ZXJfcF9yZWMgcy5ub2RlIGYgc1xuXG5sZXQgaXRlcl9uID8obWF4X2NvbmN1cnJlbmN5ID0gMSkgZiBzdHJlYW0gPVxuICBiZWdpblxuICAgIGlmIG1heF9jb25jdXJyZW5jeSA8PSAwIHRoZW5cbiAgICAgIGxldCBtZXNzYWdlID1cbiAgICAgICAgUHJpbnRmLnNwcmludGZcbiAgICAgICAgICBcIkx3dF9zdHJlYW0uaXRlcl9uOiBtYXhfY29uY3VycmVuY3kgbXVzdCBiZSA+IDAsICVkIGdpdmVuXCJcbiAgICAgICAgICBtYXhfY29uY3VycmVuY3lcbiAgICAgIGluXG4gICAgICBpbnZhbGlkX2FyZyBtZXNzYWdlXG4gIGVuZDtcbiAgbGV0IHJlYyBsb29wIHJ1bm5pbmcgYXZhaWxhYmxlID1cbiAgICBiZWdpblxuICAgICAgaWYgYXZhaWxhYmxlID4gMCB0aGVuIChcbiAgICAgICAgTHd0LnJldHVybiAocnVubmluZywgYXZhaWxhYmxlKVxuICAgICAgKVxuICAgICAgZWxzZSAoXG4gICAgICAgIEx3dC5uY2hvb3NlX3NwbGl0IHJ1bm5pbmcgPj49IGZ1biAoY29tcGxldGUsIHJ1bm5pbmcpIC0+XG4gICAgICAgIEx3dC5yZXR1cm4gKHJ1bm5pbmcsIGF2YWlsYWJsZSArIExpc3QubGVuZ3RoIGNvbXBsZXRlKVxuICAgICAgKVxuICAgIGVuZCA+Pj0gZnVuIChydW5uaW5nLCBhdmFpbGFibGUpIC0+XG4gICAgZ2V0IHN0cmVhbSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5qb2luIHJ1bm5pbmdcbiAgICB8IFNvbWUgZWx0IC0+XG4gICAgICBsb29wIChmIGVsdCA6OiBydW5uaW5nKSAocHJlZCBhdmFpbGFibGUpXG4gIGluXG4gIGxvb3AgW10gbWF4X2NvbmN1cnJlbmN5XG5cbmxldCByZWMgZmluZF9yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZmluZF9yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggYXMgb3B0IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxldCB0ZXN0ID0gZiB4IGluXG4gICAgICBpZiB0ZXN0IHRoZW5cbiAgICAgICAgTHd0LnJldHVybiBvcHRcbiAgICAgIGVsc2VcbiAgICAgICAgZmluZF9yZWMgbm9kZS5uZXh0IGYgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG5cbmxldCBmaW5kIGYgcyA9IGZpbmRfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBmaW5kX3NfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGZpbmRfc19yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggYXMgb3B0IC0+IGJlZ2luXG4gICAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgICBmIHggPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIEx3dC5yZXR1cm4gb3B0XG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICBmaW5kX3NfcmVjIG5vZGUubmV4dCBmIHNcbiAgICAgIGVuZFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG5cbmxldCBmaW5kX3MgZiBzID0gZmluZF9zX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMgZmluZF9tYXBfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGZpbmRfbWFwX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsZXQgeCA9IGYgeCBpblxuICAgICAgaWYgeCA9IE5vbmUgdGhlblxuICAgICAgICBmaW5kX21hcF9yZWMgbm9kZS5uZXh0IGYgc1xuICAgICAgZWxzZVxuICAgICAgICBMd3QucmV0dXJuIHhcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgZmluZF9tYXAgZiBzID0gZmluZF9tYXBfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBmaW5kX21hcF9zX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmaW5kX21hcF9zX3JlYyBub2RlIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsZXQgdCA9IGYgeCBpblxuICAgICAgKHQgPj49IGZ1bmN0aW9uXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBmaW5kX21hcF9zX3JlYyBub2RlLm5leHQgZiBzXG4gICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgIHQpXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcblxubGV0IGZpbmRfbWFwX3MgZiBzID0gZmluZF9tYXBfc19yZWMgcy5ub2RlIGYgc1xuXG5sZXQgY29tYmluZSBzMSBzMiA9XG4gIGxldCBuZXh0ICgpID1cbiAgICBsZXQgdDEgPSBnZXQgczEgYW5kIHQyID0gZ2V0IHMyIGluXG4gICAgdDEgPj49IGZ1biBuMSAtPlxuICAgIHQyID4+PSBmdW4gbjIgLT5cbiAgICBtYXRjaCBuMSwgbjIgd2l0aFxuICAgIHwgU29tZSB4MSwgU29tZSB4MiAtPlxuICAgICAgTHd0LnJldHVybiAoU29tZSh4MSwgeDIpKVxuICAgIHwgXyAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgYXBwZW5kIHMxIHMyID1cbiAgbGV0IGN1cnJlbnRfcyA9IHJlZiBzMSBpblxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGxldCB0ID0gZ2V0ICFjdXJyZW50X3MgaW5cbiAgICB0ID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSBfIC0+XG4gICAgICB0XG4gICAgfCBOb25lIC0+XG4gICAgICBpZiAhY3VycmVudF9zID09IHMyIHRoZW5cbiAgICAgICAgTHd0LnJldHVybl9ub25lXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGN1cnJlbnRfcyA6PSBzMjtcbiAgICAgICAgbmV4dCAoKVxuICAgICAgZW5kXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgY29uY2F0IHNfdG9wID1cbiAgbGV0IGN1cnJlbnRfcyA9IHJlZiAoZnJvbSAoZnVuICgpIC0+IEx3dC5yZXR1cm5fbm9uZSkpIGluXG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbGV0IHQgPSBnZXQgIWN1cnJlbnRfcyBpblxuICAgIHQgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIF8gLT5cbiAgICAgIHRcbiAgICB8IE5vbmUgLT5cbiAgICAgIGdldCBzX3RvcCA+Pj0gZnVuY3Rpb25cbiAgICAgIHwgU29tZSBzIC0+XG4gICAgICAgIGN1cnJlbnRfcyA6PSBzO1xuICAgICAgICBuZXh0ICgpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgTHd0LnJldHVybl9ub25lXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgY2hvb3NlIHN0cmVhbXMgPVxuICBsZXQgc291cmNlIHMgPSAocywgZ2V0IHMgPnw9IGZ1biB4IC0+IChzLCB4KSkgaW5cbiAgbGV0IHN0cmVhbXMgPSByZWYgKExpc3QubWFwIHNvdXJjZSBzdHJlYW1zKSBpblxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIG1hdGNoICFzdHJlYW1zIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgICB8IGwgLT5cbiAgICAgIEx3dC5jaG9vc2UgKExpc3QubWFwIHNuZCBsKSA+Pj0gZnVuIChzLCB4KSAtPlxuICAgICAgbGV0IGwgPSBMaXN0LnJlbW92ZV9hc3NxIHMgbCBpblxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IFNvbWUgXyAtPlxuICAgICAgICBzdHJlYW1zIDo9IHNvdXJjZSBzIDo6IGw7XG4gICAgICAgIEx3dC5yZXR1cm4geFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIHN0cmVhbXMgOj0gbDtcbiAgICAgICAgbmV4dCAoKVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IHBhcnNlIHMgZiA9XG4gIChtYXRjaCBzLnNvdXJjZSB3aXRoXG4gICB8IFB1c2hfYm91bmRlZCBfIC0+IGludmFsaWRfYXJnIFwiTHd0X3N0cmVhbS5wYXJzZVwiXG4gICB8IEZyb20gXyB8IEZyb21fZGlyZWN0IF8gfCBQdXNoIF8gLT4gKCkpO1xuICBsZXQgbm9kZSA9IHMubm9kZSBpblxuICBMd3QuY2F0Y2hcbiAgICAoZnVuICgpIC0+IGYgcylcbiAgICAoZnVuIGV4biAtPlxuICAgICAgIHMubm9kZSA8LSBub2RlO1xuICAgICAgIEx3dC5yZXJhaXNlIGV4bilcblxubGV0IGhleGR1bXAgc3RyZWFtID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgODAgYW5kIG51bSA9IHJlZiAwIGluXG4gIGZyb20gYmVnaW4gZnVuIF8gLT5cbiAgICBuZ2V0IDE2IHN0cmVhbSA+Pj0gZnVuY3Rpb25cbiAgICB8IFtdIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgICB8IGwgLT5cbiAgICAgIEJ1ZmZlci5jbGVhciBidWY7XG4gICAgICBQcmludGYuYnByaW50ZiBidWYgXCIlMDh4fCAgXCIgIW51bTtcbiAgICAgIG51bSA6PSAhbnVtICsgMTY7XG4gICAgICBsZXQgcmVjIGJ5dGVzIHBvcyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT5cbiAgICAgICAgICBibGFua3MgcG9zXG4gICAgICAgIHwgeCA6OiBsIC0+XG4gICAgICAgICAgaWYgcG9zID0gOCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBidWYgJyAnO1xuICAgICAgICAgIFByaW50Zi5icHJpbnRmIGJ1ZiBcIiUwMnggXCIgKENoYXIuY29kZSB4KTtcbiAgICAgICAgICBieXRlcyAocG9zICsgMSkgbFxuICAgICAgYW5kIGJsYW5rcyBwb3MgPVxuICAgICAgICBpZiBwb3MgPCAxNiB0aGVuIGJlZ2luXG4gICAgICAgICAgaWYgcG9zID0gOCB0aGVuXG4gICAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIgICAgXCJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIgICBcIjtcbiAgICAgICAgICBibGFua3MgKHBvcyArIDEpXG4gICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIGJ5dGVzIDAgbDtcbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIiB8XCI7XG4gICAgICBMaXN0Lml0ZXIgKGZ1biBjaCAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmIChpZiBjaCA+PSAnXFx4MjAnICYmIGNoIDw9ICdcXHg3ZScgdGhlbiBjaCBlbHNlICcuJykpIGw7XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICd8JztcbiAgICAgIEx3dC5yZXR1cm4gKFNvbWUoQnVmZmVyLmNvbnRlbnRzIGJ1ZikpXG4gIGVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ0MzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJMd3QiLCJBc3NlcnRfZmFpbHVyZSIsInJldHVybiIsIngiLCJmYWlsIiwiZSIsImxpZnQiLCJvayIsInkiLCJlcnJvciIsIm1hcCIsInBhcmFtIiwibWFwX2Vycm9yIiwibWFwX2VyciIsImNhdGNoIiwiZ2V0X2V4biIsInN5bWJvbF9iaW5kIiwiYmluZF9lcnJvciIsImJpbmRfbHd0IiwiYmluZF9yZXN1bHQiLCJiaW5kX2x3dF9lcnJvciIsImJpbmRfbHd0X2VyciIsImJvdGgiLCJhIiwiYiIsInMiLCJzZXRfb25jZSIsIm1hdGNoIiwiaXRlciIsInIiLCJpdGVyX2Vycm9yIiwic3ltYm9sIiwidCIsImJpbmQiLCJPcGVuX29uX3JocyIsIkxldF9zeW50YXgiLCJsZXQiLCJTeW50YXgiLCJMd3RfcmVzdWx0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9kb2dhZGlubS8ub3BhbS9lbGlvbS9saWIvbHd0L2x3dF9yZXN1bHQubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLFlBQUFDLFNBQUFDLEdDU2UsaUNBQWlCO0FBQUEsWUFBQUMsS0FBQUMsR0FDbkIsaUNBQW9CO0FBQUEsT0FBQUMsT0RWakM7QUFBQSxZQUFB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QkFFZTtBQUFBLGtCQUFBUixJQUZmO0FBQUEsY0FDWSx1QkFDbUI7QUFBQTtBQUFBO0FBQUEsWUFBQTJCLFdBQUFuQyxHQUFBa0M7QUFBQUEsSUFHakM7QUFBQTtBQUFBO0FBQUEsc0JBQUFsQjtBQUFBQSxjQUNFLG1CQUVZO0FBQUEsa0JBQUFOLElBRlo7QUFBQSxjQUNlLHVCQUNhO0FBQUE7QUFBQTtBQUFBLFlBQUEwQixPQUFBMUIsR0FBQVYsR0FJZCxnQkFBTztBQUFBLFlBQUFlLE1BQUFzQixHQUFBckMsR0FNTixnQkFBTztBQUFBLFlBQUFzQyxLQUFBRCxHQUFBckMsR0FDTix3QkFBUTtBQUFBO0FBQUEsSUFBQXVDLGNEbkg1QjtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQSxlQUFBO0FBQUEsWUFBQUMsTUFBQWpDLEdBQUFSLEdDOEhtQixnQkFBTztBQUFBO0FBQUEsSUFBQTBDLFNEOUgxQjtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG4oKiogTW9kdWxlIFtMd3RfcmVzdWx0XTogZXhwbGljaXQgZXJyb3IgaGFuZGxpbmcgKilcblxub3BlbiBSZXN1bHRcblxudHlwZSAoKydhLCArJ2IpIHQgPSAoJ2EsICdiKSBSZXN1bHQudCBMd3QudFxuXG5sZXQgcmV0dXJuIHggPSBMd3QucmV0dXJuIChPayB4KVxubGV0IGZhaWwgZSA9IEx3dC5yZXR1cm4gKEVycm9yIGUpXG5cbmxldCBsaWZ0ID0gTHd0LnJldHVyblxubGV0IG9rIHggPSBMd3QubWFwIChmdW4geSAtPiBPayB5KSB4XG5sZXQgZXJyb3IgeCA9IEx3dC5tYXAgKGZ1biB5IC0+IEVycm9yIHkpIHhcblxubGV0IG1hcCBmIGUgPVxuICBMd3QubWFwXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gRXJyb3IgZVxuICAgICAgfCBPayB4IC0+IE9rIChmIHgpKVxuICAgIGVcblxubGV0IG1hcF9lcnJvciBmIGUgPVxuICBMd3QubWFwXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gRXJyb3IgKGYgZSlcbiAgICAgIHwgT2sgeCAtPiBPayB4KVxuICAgIGVcbmxldCBtYXBfZXJyIGYgZSA9IG1hcF9lcnJvciBmIGVcblxubGV0IGNhdGNoIGUgPVxuICBMd3QuY2F0Y2hcbiAgICAoZnVuICgpIC0+IG9rIChlICgpKSlcbiAgICBmYWlsXG5cbmxldCBnZXRfZXhuIGUgPVxuICBMd3QuYmluZCBlXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IE9rIHggLT4gTHd0LnJldHVybiB4XG4gICAgICB8IEVycm9yIGUgLT4gTHd0LmZhaWwgZSlcblxubGV0IGJpbmQgZSBmID1cbiAgTHd0LmJpbmQgZVxuICAgIChmdW5jdGlvblxuICAgICAgfCBFcnJvciBlIC0+IEx3dC5yZXR1cm4gKEVycm9yIGUpXG4gICAgICB8IE9rIHggLT4gZiB4KVxuICAgICAgXG5sZXQgYmluZF9lcnJvciBlIGYgPVxuICBMd3QuYmluZCBlXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gZiBlXG4gICAgICB8IE9rIHggLT4gTHd0LnJldHVybiAoT2sgeCkpXG4gICAgICBcbmxldCBiaW5kX2x3dCBlIGYgPVxuICBMd3QuYmluZCBlXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IE9rIHggLT4gb2sgKGYgeClcbiAgICAgIHwgRXJyb3IgZSAtPiBmYWlsIGUpXG5cbmxldCBiaW5kX3Jlc3VsdCBlIGYgPVxuICBMd3QubWFwXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gRXJyb3IgZVxuICAgICAgfCBPayB4IC0+IGYgeClcbiAgICBlXG5cbmxldCBiaW5kX2x3dF9lcnJvciBlIGYgPVxuICBMd3QuYmluZCBlXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gTHd0LmJpbmQgKGYgZSkgZmFpbFxuICAgICAgfCBPayB4IC0+IHJldHVybiB4KVxubGV0IGJpbmRfbHd0X2VyciBlIGYgPSBiaW5kX2x3dF9lcnJvciBlIGZcblxubGV0IGJvdGggYSBiID1cbiAgbGV0IHMgPSByZWYgTm9uZSBpblxuICBsZXQgc2V0X29uY2UgZSA9XG4gICAgbWF0Y2ggIXMgd2l0aFxuICAgIHwgTm9uZSAtPiBzOj0gU29tZSBlXG4gICAgfCBTb21lIF8gLT4gKClcbiAgaW5cbiAgbGV0IChhLGIpID0gbWFwX2Vycm9yIHNldF9vbmNlIGEsbWFwX2Vycm9yIHNldF9vbmNlIGIgaW5cbiAgbGV0IHNvbWVfYXNzZXJ0ID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBTb21lIGUgLT4gRXJyb3IgZVxuICBpblxuICBMd3QubWFwXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IE9rIHgsIE9rIHkgLT4gT2sgKHgseSlcbiAgICAgIHwgRXJyb3IgXywgT2sgX1xuICAgICAgfCBPayBfLEVycm9yIF9cbiAgICAgIHwgRXJyb3IgXywgRXJyb3IgXyAtPiBzb21lX2Fzc2VydCAhcylcbiAgICAoTHd0LmJvdGggYSBiKVxuXG5sZXQgaXRlciBmIHIgPVxuICBMd3QuYmluZCByXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IE9rIHggLT4gZiB4XG4gICAgICB8IEVycm9yIF8gLT4gTHd0LnJldHVybl91bml0KVxuXG5sZXQgaXRlcl9lcnJvciBmIHIgPVxuICBMd3QuYmluZCByXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gZiBlXG4gICAgICB8IE9rIF8gLT4gTHd0LnJldHVybl91bml0KVxuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgbGV0ICg+Pj0pID0gYmluZFxuICBsZXQgKD58PSkgZSBmID0gbWFwIGYgZVxuZW5kXG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgdCB+ZiA9IG1hcCBmIHRcbiAgICBsZXQgYmluZCB0IH5mID0gYmluZCB0IGZcbiAgICBsZXQgYm90aCA9IGJvdGhcbiAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3RcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIFN5bnRheCA9IHN0cnVjdFxuICBsZXQgKGxldCopID0gYmluZFxuICBsZXQgKGFuZCopID0gYm90aFxuXG4gIGxldCAobGV0KykgeCBmID0gbWFwIGYgeFxuICBsZXQgKGFuZCspID0gYm90aFxuZW5kXG5cbmluY2x1ZGUgSW5maXhcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0NjQ0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imx3dC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfTGlzdCIsIk1ha2UiLCJPcmQiLCJsaW5rIiwidDEiLCJ0MiIsImMyIiwicjIiLCJ4MiIsImMxIiwicjEiLCJ4MSIsImMiLCJpbnMiLCJ0IiwidHMiLCJyIiwiaXNfZW1wdHkiLCJhZGQiLCJ4IiwidW5pb24iLCJ0czIiLCJ0czEiLCJmaW5kX21pbiIsInBhcmFtIiwibG9va3VwX21pbiIsInJlc3VsdCIsImdldF9taW4iLCJtYXRjaCIsInJlbW92ZV9taW4iLCJzaXplIiwibCIsInMiLCJ0bCIsIkx3dF9wcXVldWUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2RvZ2FkaW5tLy5vcGFt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QyxHQUFBbEI7QUFBQUEsbUJBQUFtQixLQURhO0FBQUEsZUFBc0IsaUNBQ007QUFBQTtBQUFBO0FBQUEsZ0JBQUs7QUFBQTtBQUFBLElEaEdsRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE9BQUFDLGFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuc2lnXG4gIHR5cGUgdFxuICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuc2lnXG4gIHR5cGUgZWx0XG4gIHR5cGUgdFxuICB2YWwgZW1wdHk6IHRcbiAgdmFsIGlzX2VtcHR5OiB0IC0+IGJvb2xcbiAgdmFsIGFkZDogZWx0IC0+IHQgLT4gdFxuICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gIHZhbCBmaW5kX21pbjogdCAtPiBlbHRcbiAgdmFsIGxvb2t1cF9taW46IHQgLT4gZWx0IG9wdGlvblxuICB2YWwgcmVtb3ZlX21pbjogdCAtPiB0XG4gIHZhbCBzaXplOiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpIDogKFMgd2l0aCB0eXBlIGVsdCA9IE9yZC50KSA9XG5zdHJ1Y3RcbiAgdHlwZSBlbHQgPSBPcmQudFxuXG4gIHR5cGUgdCA9IHRyZWUgbGlzdFxuICBhbmQgdHJlZSA9IE5vZGUgb2YgZWx0ICogaW50ICogdHJlZSBsaXN0XG5cbiAgbGV0IHJvb3QgKE5vZGUgKHgsIF8sIF8pKSA9IHhcbiAgbGV0IHJhbmsgKE5vZGUgKF8sIHIsIF8pKSA9IHJcbiAgbGV0IGxpbmsgKE5vZGUgKHgxLCByMSwgYzEpIGFzIHQxKSAoTm9kZSAoeDIsIHIyLCBjMikgYXMgdDIpID1cbiAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHgxIHgyIGluXG4gICAgaWYgYyA8PSAwIHRoZW4gTm9kZSAoeDEsIHIxICsgMSwgdDI6OmMxKSBlbHNlIE5vZGUoeDIsIHIyICsgMSwgdDE6OmMyKVxuICBsZXQgcmVjIGlucyB0ID1cbiAgICBmdW5jdGlvblxuICAgICAgW10gICAgIC0+XG4gICAgICBbdF1cbiAgICB8ICh0Jzo6XykgYXMgdHMgd2hlbiByYW5rIHQgPCByYW5rIHQnIC0+XG4gICAgICB0Ojp0c1xuICAgIHwgdCc6OnRzIC0+XG4gICAgICBpbnMgKGxpbmsgdCB0JykgdHNcblxuICBsZXQgZW1wdHkgPSBbXVxuICBsZXQgaXNfZW1wdHkgdHMgPSB0cyA9IFtdXG4gIGxldCBhZGQgeCB0cyA9IGlucyAoTm9kZSAoeCwgMCwgW10pKSB0c1xuICBsZXQgcmVjIHVuaW9uIHRzIHRzJyA9XG4gICAgbWF0Y2ggdHMsIHRzJyB3aXRoXG4gICAgICAoW10sIF8pIC0+IHRzJ1xuICAgIHwgKF8sIFtdKSAtPiB0c1xuICAgIHwgKHQxOjp0czEsIHQyOjp0czIpICAtPlxuICAgICAgaWYgcmFuayB0MSA8IHJhbmsgdDIgdGhlbiB0MSA6OiB1bmlvbiB0czEgKHQyOjp0czIpXG4gICAgICBlbHNlIGlmIHJhbmsgdDIgPCByYW5rIHQxIHRoZW4gdDIgOjogdW5pb24gKHQxOjp0czEpIHRzMlxuICAgICAgZWxzZSBpbnMgKGxpbmsgdDEgdDIpICh1bmlvbiB0czEgdHMyKVxuXG4gIGxldCByZWMgZmluZF9taW4gPVxuICAgIGZ1bmN0aW9uXG4gICAgICBbXSAgICAtPiByYWlzZSBOb3RfZm91bmRcbiAgICB8IFt0XSAgIC0+IHJvb3QgdFxuICAgIHwgdDo6dHMgLT5cbiAgICAgIGxldCB4ID0gZmluZF9taW4gdHMgaW5cbiAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgKHJvb3QgdCkgeCBpblxuICAgICAgaWYgYyA8IDAgdGhlbiByb290IHQgZWxzZSB4XG5cbiAgbGV0IHJlYyBsb29rdXBfbWluID1cbiAgICBmdW5jdGlvblxuICAgIHwgW10gICAgLT4gTm9uZVxuICAgIHwgW3RdICAgLT4gU29tZSAocm9vdCB0KVxuICAgIHwgdDo6dHMgLT5cbiAgICAgIG1hdGNoIGxvb2t1cF9taW4gdHMgd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgIHwgU29tZSB4IGFzIHJlc3VsdCAtPlxuICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIChyb290IHQpIHggaW5cbiAgICAgICAgaWYgYyA8IDAgdGhlbiBTb21lIChyb290IHQpIGVsc2UgcmVzdWx0XG5cbiAgbGV0IHJlYyBnZXRfbWluID1cbiAgICBmdW5jdGlvblxuICAgICAgW10gICAgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBbdF0gICAtPiAodCwgW10pXG4gICAgfCB0Ojp0cyAtPlxuICAgICAgbGV0ICh0JywgdHMnKSA9IGdldF9taW4gdHMgaW5cbiAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgKHJvb3QgdCkgKHJvb3QgdCcpIGluXG4gICAgICBpZiBjIDwgMCB0aGVuICh0LCB0cykgZWxzZSAodCcsIHQ6OnRzJylcblxuICBsZXQgcmVtb3ZlX21pbiA9XG4gICAgZnVuY3Rpb25cbiAgICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgIHwgdHMgLT5cbiAgICAgIGxldCAoTm9kZSAoXywgXywgYyksIHRzKSA9IGdldF9taW4gdHMgaW5cbiAgICAgIHVuaW9uIChMaXN0LnJldiBjKSB0c1xuXG4gIGxldCByZWMgc2l6ZSBsID1cbiAgICBsZXQgc2l6ZXRyZWUgKE5vZGUgKF8sXyx0bCkpID0gMSArIHNpemUgdGwgaW5cbiAgICBMaXN0LmZvbGRfbGVmdCAoZnVuIHMgdCAtPiBzICsgc2l6ZXRyZWUgdCkgMCBsXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0Nzg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imx3dC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiTHd0IiwiU3RkbGliIiwiU3RkbGliX0xpc3QiLCJ0YWlsX3JlY3Vyc2l2ZV9tYXAiLCJsIiwidGFpbF9yZWN1cnNpdmVfbWFwaV9yZXYiLCJhY2MiLCJpIiwicGFyYW0iLCJ0bCIsImhkIiwiaXRlcl9zIiwieCIsIml0ZXJfcCIsInRzIiwiaXRlcmlfcyIsIml0ZXJpX3AiLCJtYXBfcyIsImlubmVyIiwiciIsImNvbGxlY3RfcmV2IiwidCIsIm1hcF9wIiwiZmlsdGVyX21hcF9zIiwidiIsImZpbHRlcl9tYXBfcCIsImNvbGxlY3Rfb3B0aW9uYWxfcmV2IiwibWFwaV9zIiwibWFwaV9wIiwicmV2X21hcF9hcHBlbmRfcyIsInJldl9tYXBfcyIsInJldl9tYXBfcCIsImZvbGRfbGVmdF9zIiwiZm9sZF9yaWdodF9zIiwiYSIsImZvcl9hbGxfcyIsImZvcl9hbGxfcCIsImJsIiwiZXhpc3RzX3MiLCJleGlzdHNfcCIsImZpbmRfcyIsIm9wdGlvbmFsaXplIiwiYiIsImZpbHRlcl9zIiwiZmlsdGVyX3AiLCJwYXJ0aXRpb25fcyIsImFjYzEiLCJhY2MyIiwicGFydGl0aW9uX3AiLCJnIiwiZ3JvdXAxIiwiZ3JvdXAyIiwiTHd0X2xpc3QiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2RvZ2FkaW5tLy5vcGFtL2VsaW9tL2xpYi9sd3QvbHd0X2xpc3QubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFB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QWhELEdBQUFTO0FBQUFBLElBR3RDLGtDQUFoQixnQ0FBa0I7QUFBQTtBQUFBLFlBQUF3QyxTQUFBakQsR0FBQVM7QUFBQUEsSUFHRCxrQ0FBaEIsZ0NBQWtCO0FBQUE7QUFBQSxZQUFBeUMsWUFBQWxELEdBQUFTO0FBQUFBLGFBQUFjLE1BQUE0QixNQUFBQyxNQUFBdkM7QUFBQUEsS0FHbEI7QUFBQSxVQUFBQyxLQUFBLFVBQUFDLEtBQUEsZ0JBRUE7QUFBQSxNQUFjO0FBQUE7QUFBQTtBQUFBLHdCQUFBZ0M7QUFBQUEsZ0JBQ3RCO0FBQUEsMEJBQ0U7QUFBQSwwQkFFQSw4QkFBd0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUxTO0FBQUEsWUFBZjtBQUFBLEtBQWEsOEJBS1A7QUFBQTtBQUFBLElBRWhDLHFCQUFhO0FBQUE7QUFBQSxZQUFBTSxZQUFBckQsR0FBQVM7QUFBQUEsYUFBQTZDLEVBQUFyQztBQUFBQSxTQUFBLE1BR0g7QUFBQSxLQUFhO0FBQUE7QUFBQTtBQUFBLHVCQUFBOEIsR0FBYyxvQ0FBaUI7QUFBQTtBQUFBLGNBQ3REO0FBQUEsSUFBUztBQUFBO0FBQUE7QUFBQSxzQkFBQWpDO0FBQUFBO0FBQUFBLGVBQUF5QztBQUFBQSxpQkFDSTtBQUFBLGlDRDlNZjtBQUFBLG1CQzhNeUM7QUFBQSxvREQ5TXpDO0FBQUEsZUFBQUM7QUFBQUEsaUJDZ05JO0FBQUEsaUNEaE5KO0FBQUEsbUJDZ044QjtBQUFBLCtDQUFBdkMsR0FBc0IsZ0JBQVk7QUFBQSxjQUM5RCw4Q0FBMkI7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBd0M7QUFBQUEsTURqTjdCIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIEEgc3VydmV5IGFuZCBtZWFzdXJlbWVudHMgb2YgbW9yZSBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb25zIGNhbiBiZSBmb3VuZCBhdDpcblxuICAgIGh0dHBzOi8vanN0aG9tYXMuZ2l0aHViLmlvL21hcC1jb21wYXJpc29uLmh0bWxcblxuICAgU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L3B1bGwvMzQ3LiAqKVxubGV0IHRhaWxfcmVjdXJzaXZlX21hcCBmIGwgPVxuICBMaXN0LnJldiAoTGlzdC5yZXZfbWFwIGYgbClcblxubGV0IHRhaWxfcmVjdXJzaXZlX21hcGlfcmV2IGYgbCA9XG4gIGxldCByZWMgaW5uZXIgYWNjIGkgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBoZDo6dGwgLT4gKGlubmVyIFtAb2NhbWwudGFpbGNhbGxdKSAoKGYgaSBoZCk6OmFjYykgKGkgKyAxKSB0bFxuICBpblxuICBpbm5lciBbXSAwIGxcblxub3BlbiBMd3QuSW5maXhcblxubGV0IHJlYyBpdGVyX3MgZiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgZiB4ID4+PSBmdW4gKCkgLT5cbiAgICBpdGVyX3MgZiBsXG5cbmxldCBpdGVyX3AgZiBsID1cbiAgbGV0IHRzID0gTGlzdC5yZXZfbWFwIChMd3QuYXBwbHkgZikgbCBpblxuICBMd3Quam9pbiB0c1xuXG5sZXQgcmVjIGl0ZXJpX3MgaSBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIEx3dC5yZXR1cm5fdW5pdFxuICB8IHggOjogbCAtPlxuICAgIEx3dC5hcHBseSAoZiBpKSB4ID4+PSBmdW4gKCkgLT5cbiAgICBpdGVyaV9zIChpICsgMSkgZiBsXG5cbmxldCBpdGVyaV9zIGYgbCA9IGl0ZXJpX3MgMCBmIGxcblxubGV0IGl0ZXJpX3AgZiBsID1cbiAgbGV0IGYnIGkgPSBMd3QuYXBwbHkgKGYgaSkgaW5cbiAgbGV0IHRzID0gdGFpbF9yZWN1cnNpdmVfbWFwaV9yZXYgZicgbCBpblxuICBMd3Quam9pbiB0c1xuXG5sZXQgbWFwX3MgZiBsID1cbiAgbGV0IHJlYyBpbm5lciBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gTGlzdC5yZXYgYWNjIHw+IEx3dC5yZXR1cm5cbiAgICB8IGhkOjp0bCAtPlxuICAgICAgTHd0LmFwcGx5IGYgaGQgPj49IGZ1biByIC0+XG4gICAgICAoaW5uZXIgW0BvY2FtbC50YWlsY2FsbF0pIChyOjphY2MpIHRsXG4gIGluXG4gIGlubmVyIFtdIGxcblxubGV0IHJlYyBfY29sbGVjdF9yZXYgYWNjID0gZnVuY3Rpb25cbiAgfCBbXSAtPlxuICAgIEx3dC5yZXR1cm4gYWNjXG4gIHwgdDo6dHMgLT5cbiAgICB0ID4+PSBmdW4gaSAtPlxuICAgIChfY29sbGVjdF9yZXYgW0BvY2FtbC50YWlsY2FsbF0pIChpOjphY2MpIHRzXG5cbmxldCBtYXBfcCBmIGwgPVxuICBsZXQgdHMgPSBMaXN0LnJldl9tYXAgKEx3dC5hcHBseSBmKSBsIGluXG4gIF9jb2xsZWN0X3JldiBbXSB0c1xuXG5sZXQgZmlsdGVyX21hcF9zIGYgbCA9XG4gIGxldCByZWMgaW5uZXIgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdICAgICAtPiBMaXN0LnJldiBhY2MgfD4gTHd0LnJldHVyblxuICAgIHwgaGQ6OnRsIC0+XG4gICAgICBMd3QuYXBwbHkgZiBoZCA+Pj0gZnVuY3Rpb25cbiAgICAgIHwgU29tZSB2IC0+IChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgKHY6OmFjYykgdGxcbiAgICAgIHwgTm9uZSAtPiAoaW5uZXIgW0BvY2FtbC50YWlsY2FsbF0pIGFjYyB0bFxuICBpblxuICBpbm5lciBbXSBsXG5cbmxldCBmaWx0ZXJfbWFwX3AgZiBsID1cbiAgbGV0IHJlYyBfY29sbGVjdF9vcHRpb25hbF9yZXYgYWNjID0gZnVuY3Rpb25cbiAgfCBbXSAgICAtPiBMd3QucmV0dXJuIGFjY1xuICB8IHQ6OnRzIC0+XG4gICAgdCA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgdiAtPiAoX2NvbGxlY3Rfb3B0aW9uYWxfcmV2IFtAb2NhbWwudGFpbGNhbGxdKSAodjo6YWNjKSB0c1xuICAgIHwgTm9uZSAtPiAoX2NvbGxlY3Rfb3B0aW9uYWxfcmV2IFtAb2NhbWwudGFpbGNhbGxdKSBhY2MgdHNcbiAgaW5cbiAgbGV0IHRzID0gTGlzdC5yZXZfbWFwIChMd3QuYXBwbHkgZikgbCBpblxuICBfY29sbGVjdF9vcHRpb25hbF9yZXYgW10gdHNcblxubGV0IG1hcGlfcyBmIGwgPVxuICBsZXQgcmVjIGlubmVyIGFjYyBpID0gZnVuY3Rpb25cbiAgICB8IFtdICAgICAtPiBMaXN0LnJldiBhY2MgfD4gTHd0LnJldHVyblxuICAgIHwgaGQ6OnRsIC0+XG4gICAgICBMd3QuYXBwbHkgKGYgaSkgaGQgPj49IGZ1biB2IC0+XG4gICAgICAoaW5uZXIgW0BvY2FtbC50YWlsY2FsbF0pICh2OjphY2MpIChpKzEpIHRsXG4gIGluXG4gIGlubmVyIFtdIDAgbFxuXG5sZXQgbWFwaV9wIGYgbCA9XG4gIGxldCBmJyBpID0gTHd0LmFwcGx5IChmIGkpIGluXG4gIGxldCB0cyA9IHRhaWxfcmVjdXJzaXZlX21hcGlfcmV2IGYnIGwgaW5cbiAgX2NvbGxlY3RfcmV2IFtdIHRzXG5cbmxldCByZWMgcmV2X21hcF9hcHBlbmRfcyBhY2MgZiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuIGFjY1xuICB8IHggOjogbCAtPlxuICAgIEx3dC5hcHBseSBmIHggPj49IGZ1biB4IC0+XG4gICAgcmV2X21hcF9hcHBlbmRfcyAoeCA6OiBhY2MpIGYgbFxuXG5sZXQgcmV2X21hcF9zIGYgbCA9XG4gIHJldl9tYXBfYXBwZW5kX3MgW10gZiBsXG5cbmxldCByZWMgcmV2X21hcF9hcHBlbmRfcCBhY2MgZiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBhY2NcbiAgfCB4IDo6IGwgLT5cbiAgICByZXZfbWFwX2FwcGVuZF9wXG4gICAgICAoTHd0LmFwcGx5IGYgeCA+Pj0gZnVuIHggLT5cbiAgICAgICBhY2MgPnw9IGZ1biBsIC0+XG4gICAgICAgeCA6OiBsKSBmIGxcblxubGV0IHJldl9tYXBfcCBmIGwgPVxuICByZXZfbWFwX2FwcGVuZF9wIEx3dC5yZXR1cm5fbmlsIGYgbFxuXG5sZXQgcmVjIGZvbGRfbGVmdF9zIGYgYWNjIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIEx3dC5yZXR1cm4gYWNjXG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IChmIGFjYykgeCA+Pj0gZnVuIGFjYyAtPlxuICAgIChmb2xkX2xlZnRfcyBbQG9jYW1sLnRhaWxjYWxsXSkgZiBhY2MgbFxuXG5sZXQgZm9sZF9yaWdodF9zIGYgbCBhY2MgPVxuICBsZXQgcmVjIGlubmVyIGYgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAgICAgLT4gTHd0LnJldHVybiBhXG4gICAgfCBoZDo6dGwgLT4gKEx3dC5hcHBseSAoZiBoZCkgYSkgPj49IGZ1biBhJyAtPlxuICAgICAgKGlubmVyIFtAb2NhbWwudGFpbGNhbGxdKSBmIGEnIHRsXG4gIGluXG4gIGlubmVyIGYgYWNjIChMaXN0LnJldiBsKVxuXG5sZXQgcmVjIGZvcl9hbGxfcyBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIEx3dC5yZXR1cm5fdHJ1ZVxuICB8IHggOjogbCAtPlxuICAgIEx3dC5hcHBseSBmIHggPj49IGZ1bmN0aW9uXG4gICAgfCB0cnVlIC0+XG4gICAgICAoZm9yX2FsbF9zIFtAb2NhbWwudGFpbGNhbGxdKSBmIGxcbiAgICB8IGZhbHNlIC0+XG4gICAgICBMd3QucmV0dXJuX2ZhbHNlXG5cbmxldCBmb3JfYWxsX3AgZiBsID1cbiAgbWFwX3AgZiBsID4+PSBmdW4gYmwgLT4gTGlzdC5mb3JfYWxsIChmdW4geCAtPiB4KSBibCB8PiBMd3QucmV0dXJuXG5cbmxldCByZWMgZXhpc3RzX3MgZiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuX2ZhbHNlXG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IGYgeCA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgLT5cbiAgICAgIEx3dC5yZXR1cm5fdHJ1ZVxuICAgIHwgZmFsc2UgLT5cbiAgICAgIChleGlzdHNfcyBbQG9jYW1sLnRhaWxjYWxsXSkgZiBsXG5cbmxldCBleGlzdHNfcCBmIGwgPVxuICBtYXBfcCBmIGwgPj49IGZ1biBibCAtPiBMaXN0LmV4aXN0cyAoZnVuIHggLT4geCkgYmwgfD4gTHd0LnJldHVyblxuXG5sZXQgcmVjIGZpbmRfcyBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIEx3dC5mYWlsIE5vdF9mb3VuZFxuICB8IHggOjogbCAtPlxuICAgIEx3dC5hcHBseSBmIHggPj49IGZ1bmN0aW9uXG4gICAgfCB0cnVlIC0+XG4gICAgICBMd3QucmV0dXJuIHhcbiAgICB8IGZhbHNlIC0+XG4gICAgICAoZmluZF9zIFtAb2NhbWwudGFpbGNhbGxdKSBmIGxcblxubGV0IF9vcHRpb25hbGl6ZSBmIHggPVxuICBmIHggPj49IGZ1biBiIC0+IGlmIGIgdGhlbiBMd3QucmV0dXJuIChTb21lIHgpIGVsc2UgTHd0LnJldHVybl9ub25lXG5cbmxldCBmaWx0ZXJfcyBmIGwgPVxuICBmaWx0ZXJfbWFwX3MgKF9vcHRpb25hbGl6ZSBmKSBsXG5cbmxldCBmaWx0ZXJfcCBmIGwgPVxuICAgZmlsdGVyX21hcF9wIChfb3B0aW9uYWxpemUgZikgbFxuXG5sZXQgcGFydGl0aW9uX3MgZiBsID1cbiAgbGV0IHJlYyBpbm5lciBhY2MxIGFjYzIgPSBmdW5jdGlvblxuICAgIHwgW10gICAgIC0+IEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYzEsIExpc3QucmV2IGFjYzIpXG4gICAgfCBoZDo6dGwgLT4gTHd0LmFwcGx5IGYgaGQgPj49IGZ1biBiIC0+XG4gICAgICAgIGlmIGIgdGhlblxuICAgICAgICAgIGlubmVyIChoZDo6YWNjMSkgYWNjMiB0bFxuICAgICAgICBlbHNlXG4gICAgICAgICAgaW5uZXIgYWNjMSAoaGQ6OmFjYzIpIHRsXG4gIGluXG4gIGlubmVyIFtdIFtdIGxcblxubGV0IHBhcnRpdGlvbl9wIGYgbCA9XG4gIGxldCBnIHggPSBMd3QuYXBwbHkgZiB4ID4+PSBmdW4gYiAtPiBMd3QucmV0dXJuIChiLCB4KSBpblxuICBtYXBfcCBnIGwgPj49IGZ1biB0bCAtPlxuICBsZXQgZ3JvdXAxID0gdGFpbF9yZWN1cnNpdmVfbWFwIHNuZCBAQCBMaXN0LmZpbHRlciBmc3QgdGwgaW5cbiAgbGV0IGdyb3VwMiA9XG4gICAgdGFpbF9yZWN1cnNpdmVfbWFwIHNuZCBAQCBMaXN0LmZpbHRlciAoZnVuIHggLT4gbm90IEBAIGZzdCB4KSB0bCBpblxuICBMd3QucmV0dXJuIChncm91cDEsIGdyb3VwMilcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1MTMyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imx3dC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiTHd0X3NlcXVlbmNlIiwiU3RkbGliX1F1ZXVlIiwiTHd0X2xpc3QiLCJMd3QiLCJjcmVhdGUiLCJtIiwib3B0Iiwic3RoIiwidmFsaWRhdGUiLCJwYXJhbSIsImNoZWNrIiwiZGlzcG9zZSIsImNyZWF0ZV9tZW1iZXIiLCJwIiwiZXhuIiwicmVsZWFzZSIsImMiLCJtYXRjaCIsIndha2VuZXIiLCJ2YWxpZGF0ZV9hbmRfcmV0dXJuIiwiZSIsInVzZSIsImNsZWFyZWQiLCJwcm9taXNlIiwib2siLCJyZXN1bHQiLCJjbGVhciIsImVsZW1lbnRzIiwibCIsImVsZW1lbnQiLCJvbGRfY2xlYXJlZCIsIndhaXRfcXVldWVfbGVuZ3RoIiwiTHd0X3Bvb2wiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2RvZ2FkaW5tLy5vcGFtL2VsaW9tL2xpYi9sd3QvbHd0X3Bvb2wubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsWUFBQUMsT0FBQUMsR0FBQUMsS0FBQSxVQUFBRjtBQUFBQSxJQ29DRTtBQUFBLFNBQUFHLE1BQUEsUUFBQUMsV0FEd0I7QUFBQTtBQUFBLFNBQUFBLFdBQUEsU0FBQUMsT0FBUyxlQUFlO0FBQUEsSUFDaEQ7QUFBQSxTQUFBRixRQUFBLFFBQUFHLFFBRDREO0FBQUE7QUFBQSxTQUFBQSxRQUFBLFNBQUFELE9BQUFoQixHQUFXLHVCQUFNO0FBQUEsSUFDN0U7QUFBQSxTQUFBYyxRQUFBLFFBQUFJLFVBRDJGO0FBQUE7QUFBQSxTQUFBQSxVQUFBLFNBQUFGLE9BQVMsZUFBZTtBQUFBLGNBU3ZHO0FBQUEsSUFESDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBZTtBQUFBLEdBQ1k7QUFBQSxZQUFBRyxjQUFBQztBQUFBQSxJQUlwQztBQUFBO0FBQUEsc0JBQUFKLE9BSUsscUJBQ0EsMEJBQVc7QUFBQSxzQkFBQUs7QUFBQUEsY0FHWDtBQUFBLGNBQ0EsOEJBQVk7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBQyxRQUFBRixHQUFBRztBQUFBQSxRQUFBQyxRQUlaO0FBQUEsSUFBaUMsWUFNckMsMkNBQW1CO0FBQUEsUUFBQUMsVUFOa0I7QUFBQSxJQUdyQyxxQ0FHbUI7QUFBQTtBQUFBLFlBQUFQLFFBQUFFLEdBQUFHO0FBQUFBLFFBQUEsTUFJckI7QUFBQSxJQUFXO0FBQUE7QUFBQTtBQUFBLHNCQUFBUCxPQUNYLHFCQUNBLGVBQWU7QUFBQTtBQUFBLFlBQUFVLG9CQUFBTixHQUFBRztBQUFBQSxJQW9CZjtBQUFBO0FBQUEsc0JBQUFQLE9BRU8sMEJBQVk7QUFBQSxzQkFBQUE7QUFBQUEsY0FDZixVQUVJLDRCQUlnQjtBQUFBLHdCQURoQjtBQUFBLGNBQVc7QUFBQSxpREFBQUEsT0FDWCx1QkFBZSxHQUFDO0FBQUE7QUFBQSxzQkFBQVc7QUFBQUEsa0JBQUEsTUFJakI7QUFBQSxjQUFXO0FBQUE7QUFBQTtBQUFBLGdDQUFBWDtBQUFBQSw0QkFBQVEsUUE3Qlo7QUFBQSx3QkFBaUM7QUFBQSw2QkFBQUMsVUFBQSxnQkFPbkM7QUFBQSx5QkFBdUI7QUFBQTtBQUFBO0FBQUEsb0NBQUFGLEdBRXBCLHFDQUEwQjtBQUFBLG9DQUFBRixLQUcxQix1Q0FBZ0M7QUFBQTtBQUFBLHdCQWtCZDtBQUFBLHVCQUNMO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQU8sSUFBQVIsR0FBQXBCO0FBQUFBLGFBQUEsSUFBQXVCO0FBQUFBO0FBQUFBLE1BQUFNLFVBb0NyQjtBQUFBLE1BQUFDO0FBQUFBLFFBRUU7QUFBQTtBQUFBLG1CQUFBZCxPQUNhLHVCQUFHO0FBQUEsbUJBQUFXO0FBQUFBLGVBQUFFLFlBRVgsWUFBQUUsS0FyQlA7QUFBQSxXQUNBLDZCQUFBQyxRQUF5Qix5QkFBWTtBQUFBO0FBQUE7QUFBQSxzQkFBQyxTQUFBaEIsT0FxQi9CLDRCQUFVO0FBQUEsWUFyQnFCO0FBQUEsYUFPcEM7QUFBQSx1QkFBVztBQUFBO0FBQUE7QUFBQSxzQkFOYztBQUFBO0FBQUEsV0FtQlUsdUNBQ3BCO0FBQUE7QUFBQSxLQUVqQjtBQUFBO0FBQUE7QUFBQSx1QkFBQUE7QUFBQUEsZUFDQTtBQUFBLDBCQUVFO0FBQUEsZ0JBQVc7QUFBQSxtREFBQUEsT0FDWCxlQUFPLEVBS1I7QUFBQTtBQUFBLGVBRkM7QUFBQSxlQUFXO0FBQUEsY0FFWjtBQUFBO0FBQUEsSUFqREU7QUFBQSxLQUVEO0FBQUEsZ0JBRUU7QUFBQTtBQUFBO0FBQUEsYUFHQTtBQUFBO0FBQUEsU0FBZ0Q7QUFBQTtBQUFBO0FBQUEseUJBQUs7QUFBQTtBQUFBO0FBQUEsTUFBQU8sSUFHL0M7QUFBQSxZQUNSO0FBQUEsSUFrQk8sdUNBb0JSO0FBQUE7QUFBQSxZQUFBVSxNQUFBYjtBQUFBQTtBQUFBQSxLQUFBYztBQUFBQSxPQUdjO0FBQUE7QUFBQSxrQkFBQUMsR0FBQUMsU0FBNkIsdUJBQVk7QUFBQTtBQUFBO0FBQUEsSUFDeEQ7QUFBQSxRQUFBQyxjQUFrQjtBQUFBLElBR2xCO0FBQUEsSUFDQTtBQUFBLElBQzJCO0FBQUEsd0NBQVgsbUNBQW9CO0FBQUE7QUFBQSxZQUFBQyxrQkFBQWxCLEdBRVosd0NBQTZCO0FBQUEsT0FBQW1CLFdENUt2RCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG4oKiBbTHd0X3NlcXVlbmNlXSBpcyBkZXByZWNhdGVkIOKAkyB3ZSBkb24ndCB3YW50IHVzZXJzIG91dHNpZGUgTHd0IHVzaW5nIGl0LlxuICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgdXNlZCBpbnRlcm5hbGx5IGJ5IEx3dC4gU28sIGJyaWVmbHkgZGlzYWJsZSB3YXJuaW5nIDNcbiAgIChcImRlcHJlY2F0ZWRcIiksIGFuZCBjcmVhdGUgYSBsb2NhbCwgbm9uLWRlcHJlY2F0ZWQgYWxpYXMgZm9yXG4gICBbTHd0X3NlcXVlbmNlXSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBieSB0aGUgcmVzdCBvZiB0aGUgY29kZSBpbiB0aGlzXG4gICBtb2R1bGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFueSBtb3JlIHdhcm5pbmdzLiAqKVxubW9kdWxlIEx3dF9zZXF1ZW5jZSA9IEx3dF9zZXF1ZW5jZVxuXG5vcGVuIEx3dC5JbmZpeFxuXG50eXBlICdhIHQgPSB7XG4gIGNyZWF0ZSA6IHVuaXQgLT4gJ2EgTHd0LnQ7XG4gICgqIENyZWF0ZSBhIG5ldyBwb29sIG1lbWJlci4gKilcbiAgY2hlY2sgOiAnYSAtPiAoYm9vbCAtPiB1bml0KSAtPiB1bml0O1xuICAoKiBDaGVjayB2YWxpZGl0eSBvZiBhIHBvb2wgbWVtYmVyIHdoZW4gdXNlIHJlc3VsdGVkIGluIGZhaWxlZCBwcm9taXNlLiAqKVxuICB2YWxpZGF0ZSA6ICdhIC0+IGJvb2wgTHd0LnQ7XG4gICgqIFZhbGlkYXRlIGFuIGV4aXN0aW5nIGZyZWUgcG9vbCBtZW1iZXIgYmVmb3JlIHVzZS4gKilcbiAgZGlzcG9zZSA6ICdhIC0+IHVuaXQgTHd0LnQ7XG4gICgqIERpc3Bvc2Ugb2YgYSBwb29sIG1lbWJlci4gKilcbiAgY2xlYXJlZCA6IGJvb2wgcmVmIHJlZjtcbiAgKCogSGF2ZSB0aGUgY3VycmVudCBwb29sIGVsZW1lbnRzIGJlZW4gY2xlYXJlZCBvdXQ/ICopXG4gIG1heCA6IGludDtcbiAgKCogU2l6ZSBvZiB0aGUgcG9vbC4gKilcbiAgbXV0YWJsZSBjb3VudCA6IGludDtcbiAgKCogTnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBwb29sLiAqKVxuICBsaXN0IDogJ2EgUXVldWUudDtcbiAgKCogQXZhaWxhYmxlIHBvb2wgbWVtYmVycy4gKilcbiAgd2FpdGVycyA6ICdhIEx3dC51IEx3dF9zZXF1ZW5jZS50O1xuICAoKiBQcm9taXNlIHJlc29sdmVycyB3YWl0aW5nIGZvciBhIGZyZWUgbWVtYmVyLiAqKVxufVxuXG5sZXQgY3JlYXRlIG0gPyh2YWxpZGF0ZSA9IGZ1biBfIC0+IEx3dC5yZXR1cm5fdHJ1ZSkgPyhjaGVjayA9IGZ1biBfIGYgLT4gZiB0cnVlKSA/KGRpc3Bvc2UgPSBmdW4gXyAtPiBMd3QucmV0dXJuX3VuaXQpIGNyZWF0ZSA9XG4gIHsgbWF4ID0gbTtcbiAgICBjcmVhdGUgPSBjcmVhdGU7XG4gICAgdmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgICBjaGVjayA9IGNoZWNrO1xuICAgIGRpc3Bvc2UgPSBkaXNwb3NlO1xuICAgIGNsZWFyZWQgPSByZWYgKHJlZiBmYWxzZSk7XG4gICAgY291bnQgPSAwO1xuICAgIGxpc3QgPSBRdWV1ZS5jcmVhdGUgKCk7XG4gICAgd2FpdGVycyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCkgfVxuXG4oKiBDcmVhdGUgYSBwb29sIG1lbWJlci4gKilcbmxldCBjcmVhdGVfbWVtYmVyIHAgPVxuICBMd3QuY2F0Y2hcbiAgICAoZnVuICgpIC0+XG4gICAgICAgKCogTXVzdCBiZSBkb25lIGJlZm9yZSBwLmNyZWF0ZSB0byBwcmV2ZW50IG90aGVyIHJlc29sdmVycyBmcm9tXG4gICAgICAgICAgY3JlYXRpbmcgbmV3IG1lbWJlcnMgaWYgdGhlIGxpbWl0IGlzIHJlYWNoZWQuICopXG4gICAgICAgcC5jb3VudCA8LSBwLmNvdW50ICsgMTtcbiAgICAgICBwLmNyZWF0ZSAoKSlcbiAgICAoZnVuIGV4biAtPlxuICAgICAgICgqIENyZWF0aW9uIGZhaWxlZCwgc28gZG9uJ3QgaW5jcmVtZW50IGNvdW50LiAqKVxuICAgICAgIHAuY291bnQgPC0gcC5jb3VudCAtIDE7XG4gICAgICAgTHd0LmZhaWwgZXhuKVxuXG4oKiBSZWxlYXNlIGEgcG9vbCBtZW1iZXIuICopXG5sZXQgcmVsZWFzZSBwIGMgPVxuICBtYXRjaCBMd3Rfc2VxdWVuY2UudGFrZV9vcHRfbCBwLndhaXRlcnMgd2l0aFxuICB8IFNvbWUgd2FrZW5lciAtPlxuICAgICgqIEEgcHJvbWlzZSByZXNvbHZlciBpcyB3YWl0aW5nLCBnaXZlIGl0IHRoZSBwb29sIG1lbWJlci4gKilcbiAgICBMd3Qud2FrZXVwX2xhdGVyIHdha2VuZXIgY1xuICB8IE5vbmUgLT5cbiAgICAoKiBObyBvbmUgaXMgd2FpdGluZywgcXVldWUgaXQuICopXG4gICAgUXVldWUucHVzaCBjIHAubGlzdFxuXG4oKiBEaXNwb3NlIG9mIGEgcG9vbCBtZW1iZXIuICopXG5sZXQgZGlzcG9zZSBwIGMgPVxuICBwLmRpc3Bvc2UgYyA+Pj0gZnVuICgpIC0+XG4gIHAuY291bnQgPC0gcC5jb3VudCAtIDE7XG4gIEx3dC5yZXR1cm5fdW5pdFxuXG4oKiBDcmVhdGUgYSBuZXcgbWVtYmVyIHdoZW4gb25lIGlzIHRocm93biBhd2F5LiAqKVxubGV0IHJlcGxhY2VfZGlzcG9zZWQgcCA9XG4gIG1hdGNoIEx3dF9zZXF1ZW5jZS50YWtlX29wdF9sIHAud2FpdGVycyB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICgqIE5vIG9uZSBpcyB3YWl0aW5nLCBkbyBub3QgY3JlYXRlIGEgbmV3IG1lbWJlciB0byBhdm9pZFxuICAgICAgIGxvc2luZyBhbiBlcnJvciBpZiBjcmVhdGlvbiBmYWlscy4gKilcbiAgICAoKVxuICB8IFNvbWUgd2FrZW5lciAtPlxuICAgIEx3dC5vbl9hbnlcbiAgICAgIChMd3QuYXBwbHkgcC5jcmVhdGUgKCkpXG4gICAgICAoZnVuIGMgLT5cbiAgICAgICAgIEx3dC53YWtldXBfbGF0ZXIgd2FrZW5lciBjKVxuICAgICAgKGZ1biBleG4gLT5cbiAgICAgICAgICgqIENyZWF0aW9uIGZhaWxlZCwgbm90aWZ5IHRoZSB3YWl0ZXIgb2YgdGhlIGZhaWx1cmUuICopXG4gICAgICAgICBMd3Qud2FrZXVwX2xhdGVyX2V4biB3YWtlbmVyIGV4bilcblxuKCogVmVyaWZ5IGEgbWVtYmVyIGlzIHN0aWxsIHZhbGlkIGJlZm9yZSB1c2luZyBpdC4gKilcbmxldCB2YWxpZGF0ZV9hbmRfcmV0dXJuIHAgYyA9XG4gIEx3dC50cnlfYmluZFxuICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgcC52YWxpZGF0ZSBjKVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIEx3dC5yZXR1cm4gY1xuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgKCogUmVtb3ZlIHRoaXMgbWVtYmVyIGFuZCBjcmVhdGUgYSBuZXcgb25lLiAqKVxuICAgICAgICAgIGRpc3Bvc2UgcCBjID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICBjcmVhdGVfbWVtYmVyIHApXG4gICAgICAoZnVuIGUgLT5cbiAgICAgICAgICgqIFZhbGlkYXRpb24gZmFpbGVkOiBjcmVhdGUgYSBuZXcgbWVtYmVyIGlmIGF0IGxlYXN0IG9uZVxuICAgICAgICAgICAgcmVzb2x2ZXIgaXMgd2FpdGluZy4gKilcbiAgICAgICAgIGRpc3Bvc2UgcCBjID4+PSBmdW4gKCkgLT5cbiAgICAgICAgIHJlcGxhY2VfZGlzcG9zZWQgcDtcbiAgICAgICAgIEx3dC5yZXJhaXNlIGUpXG5cbigqIEFjcXVpcmUgYSBwb29sIG1lbWJlci4gKilcbmxldCBhY3F1aXJlIHAgPVxuICBpZiBRdWV1ZS5pc19lbXB0eSBwLmxpc3QgdGhlblxuICAgICgqIE5vIG1vcmUgYXZhaWxhYmxlIG1lbWJlci4gKilcbiAgICBpZiBwLmNvdW50IDwgcC5tYXggdGhlblxuICAgICAgKCogTGltaXQgbm90IHJlYWNoZWQ6IGNyZWF0ZSBhIG5ldyBvbmUuICopXG4gICAgICBjcmVhdGVfbWVtYmVyIHBcbiAgICBlbHNlXG4gICAgICAoKiBMaW1pdCByZWFjaGVkOiB3YWl0IGZvciBhIGZyZWUgb25lLiAqKVxuICAgICAgKEx3dC5hZGRfdGFza19yIFtAb2NhbWwud2FybmluZyBcIi0zXCJdKSBwLndhaXRlcnMgPj49IHZhbGlkYXRlX2FuZF9yZXR1cm4gcFxuICBlbHNlXG4gICAgKCogVGFrZSB0aGUgZmlyc3QgZnJlZSBtZW1iZXIgYW5kIHZhbGlkYXRlIGl0LiAqKVxuICAgIGxldCBjID0gUXVldWUudGFrZSBwLmxpc3QgaW5cbiAgICB2YWxpZGF0ZV9hbmRfcmV0dXJuIHAgY1xuXG4oKiBSZWxlYXNlIGEgbWVtYmVyIHdoZW4gdXNlIHJlc3VsdGVkIGluIGZhaWxlZCBwcm9taXNlIGlmIHRoZSBtZW1iZXJcbiAgIGlzIHN0aWxsIHZhbGlkLiAqKVxubGV0IGNoZWNrX2FuZF9yZWxlYXNlIHAgYyBjbGVhcmVkID1cbiAgbGV0IG9rID0gcmVmIGZhbHNlIGluXG4gIHAuY2hlY2sgYyAoZnVuIHJlc3VsdCAtPiBvayA6PSByZXN1bHQpO1xuICBpZiBjbGVhcmVkIHx8IG5vdCAhb2sgdGhlbiAoXG4gICAgKCogRWxlbWVudCBpcyBub3Qgb2sgb3IgdGhlIHBvb2wgd2FzIGNsZWFyZWQgLSBkaXNwb3NlIG9mIGl0ICopXG4gICAgZGlzcG9zZSBwIGNcbiAgKVxuICBlbHNlIChcbiAgICAoKiBFbGVtZW50IGlzIG9rIC0gcmVsZWFzZSBpdCBiYWNrIHRvIHRoZSBwb29sICopXG4gICAgcmVsZWFzZSBwIGM7XG4gICAgTHd0LnJldHVybl91bml0XG4gIClcblxubGV0IHVzZSBwIGYgPVxuICBhY3F1aXJlIHAgPj49IGZ1biBjIC0+XG4gICgqIENhcHR1cmUgdGhlIGN1cnJlbnQgY2xlYXJlZCBzdGF0ZSBzbyB3ZSBjYW4gc2VlIGlmIGl0IGNoYW5nZXMgd2hpbGUgdGhpc1xuICAgICBlbGVtZW50IGlzIGluIHVzZSAqKVxuICBsZXQgY2xlYXJlZCA9ICEocC5jbGVhcmVkKSBpblxuICBsZXQgcHJvbWlzZSA9XG4gICAgTHd0LmNhdGNoXG4gICAgICAoZnVuICgpIC0+IGYgYylcbiAgICAgIChmdW4gZSAtPlxuICAgICAgICAgY2hlY2tfYW5kX3JlbGVhc2UgcCBjICFjbGVhcmVkID4+PSBmdW4gKCkgLT5cbiAgICAgICAgIEx3dC5mYWlsIGUpXG4gIGluXG4gIHByb21pc2UgPj49IGZ1biBfIC0+XG4gIGlmICFjbGVhcmVkIHRoZW4gKFxuICAgICgqIHAgd2FzIGNsZWFyZWQgd2hpbGUgcHJvbWlzZSB3YXMgcmVzb2x2aW5nIC0gZGlzcG9zZSBvZiB0aGlzIGVsZW1lbnQgKilcbiAgICBkaXNwb3NlIHAgYyA+Pj0gZnVuICgpIC0+XG4gICAgcHJvbWlzZVxuICApXG4gIGVsc2UgKFxuICAgIHJlbGVhc2UgcCBjO1xuICAgIHByb21pc2VcbiAgKVxuXG5sZXQgY2xlYXIgcCA9XG4gIGxldCBlbGVtZW50cyA9IFF1ZXVlLmZvbGQgKGZ1biBsIGVsZW1lbnQgLT4gZWxlbWVudCA6OiBsKSBbXSBwLmxpc3QgaW5cbiAgUXVldWUuY2xlYXIgcC5saXN0O1xuICAoKiBJbmRpY2F0ZSB0byBhbnkgY3VycmVudGx5IGluLXVzZSBlbGVtZW50cyB0aGF0IHdlIGNsZWFyZWQgdGhlIHBvb2wgKilcbiAgbGV0IG9sZF9jbGVhcmVkID0gIShwLmNsZWFyZWQpIGluXG4gIG9sZF9jbGVhcmVkIDo9IHRydWU7XG4gIHAuY2xlYXJlZCA6PSByZWYgZmFsc2U7XG4gIEx3dF9saXN0Lml0ZXJfcyAoZGlzcG9zZSBwKSBlbGVtZW50c1xuXG5sZXQgd2FpdF9xdWV1ZV9sZW5ndGggcCA9IEx3dF9zZXF1ZW5jZS5sZW5ndGggcC53YWl0ZXJzXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTMxMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkx3dCIsIkx3dF9zZXF1ZW5jZSIsImNyZWF0ZV9lbXB0eSIsInBhcmFtIiwiY3JlYXRlIiwidiIsInB1dCIsIm12YXIiLCJtYXRjaCIsInciLCJyZXMiLCJub2RlIiwidGFrZV9hdmFpbGFibGUiLCJ0YWtlIiwiaXNfZW1wdHkiLCJMd3RfbXZhciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvZG9nYWRpbm0vLm9wYW0vZWxpb20vbGliL2x3dC9sd3RfbXZhci5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsWUFBQUMsYUFBQUM7QUFBQUEsUUFBQSxNQ29EYztBQUFBLElBREEsa0RBQXNCO0FBQUEsR0FDRTtBQUFBLFlBQUFDLE9BQUFDO0FBQUFBLFFBQUEsTUFLeEI7QUFBQSxJQURBLHVEQUFzQjtBQUFBLEdBQ0U7QUFBQSxZQUFBQyxJQUFBQyxNQUFBRjtBQUFBQSxJQUdwQztBQUFBO0FBQUEsTUFBQUcsUUFVaUI7QUFBQSxNQUFBQyxJQUFXO0FBQUEsTUFBQUMsTUFBQTtBQUFBLE1BQUFDLE9BQ2Y7QUFBQSxLQUNYO0FBQUE7QUFBQTtBQUFBLGdCQUFBUixPQUE0Qix3Q0FBd0I7QUFBQSxLQUFDO0FBQUE7QUFBQSxRQUFBSyxVQVZ6QztBQUFBLElBQW9DO0FBQUEsU0FBQUMsTUFBQTtBQUFBLEtBSTVDO0FBQUE7QUFBQTtBQUFBLEtBRkE7QUFBQSxJQUlKO0FBQUEsR0FLRztBQUFBLFlBQUFHLGVBQUFMO0FBQUFBLFFBQUFDLFVBV0w7QUFBQSxrQkFLRTtBQUFBLFFBQUFILE1BTEYsWUFBQUcsUUFSTTtBQUFBLElBQW9DO0FBQUEsU0FBQUEsVUFBQSxVQUFBQyxJQUFBLFlBQUFKLElBQUE7QUFBQSxLQUV4QztBQUFBLEtBQ0E7QUFBQTtBQUFBO0FBQUEsS0FFQTtBQUFBLElBS2dCO0FBQUEsR0FHWjtBQUFBLFlBQUFRLEtBQUFOO0FBQUFBLFFBQUFDLFFBR0E7QUFBQSxJQUFtQixZQUVmLG1DQUFtRDtBQUFBLFFBQUFILElBRnBDO0FBQUEsSUFDYiw0QkFDaUQ7QUFBQTtBQUFBLFlBQUFTLFNBQUFQLE1BRzdELHNCQUVjO0FBQUE7QUFBQSxJQUFBUSxXRG5HaEIiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIE9DYW1sIHByb21pc2UgbGlicmFyeVxuICogaHR0cHM6Ly9vY3NpZ2VuLm9yZy9sd3RcbiAqIENvcHlyaWdodCAoYykgMjAwOSwgTWV0YXdlYiBUZWNobm9sb2dpZXMsIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgTUVUQVdFQiBURUNITk9MT0dJRVMgYGBBUyBJUycnIEFORCBBTllcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIE1FVEFXRUIgVEVDSE5PTE9HSUVTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SXG4gKiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFXG4gKiBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOXG4gKiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqKVxuXG4oKiBUaGlzIGNvZGUgaXMgYWRhcHRlZCBmcm9tXG4gICBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDEwMDEyMTU0MjUvaHR0cDovL2VpZ2VuY2xhc3Mub3JnOjgwL2hpa2kvbGlnaHR3ZWlnaHQtdGhyZWFkcy13aXRoLWx3dC4gKilcblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIG12YXJfY29udGVudHMgOiAnYSBvcHRpb247XG4gICgqIEN1cnJlbnQgY29udGVudHMgKilcblxuICB3cml0ZXJzIDogKCdhICogdW5pdCBMd3QudSkgTHd0X3NlcXVlbmNlLnQ7XG4gICgqIFRocmVhZHMgd2FpdGluZyB0byBwdXQgYSB2YWx1ZSAqKVxuXG4gIHJlYWRlcnMgOiAnYSBMd3QudSBMd3Rfc2VxdWVuY2UudDtcbiAgKCogVGhyZWFkcyB3YWl0aW5nIGZvciBhIHZhbHVlICopXG59XG5cbmxldCBjcmVhdGVfZW1wdHkgKCkgPVxuICB7IG12YXJfY29udGVudHMgPSBOb25lO1xuICAgIHdyaXRlcnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpO1xuICAgIHJlYWRlcnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIH1cblxubGV0IGNyZWF0ZSB2ID1cbiAgeyBtdmFyX2NvbnRlbnRzID0gU29tZSB2O1xuICAgIHdyaXRlcnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpO1xuICAgIHJlYWRlcnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIH1cblxubGV0IHB1dCBtdmFyIHYgPVxuICBtYXRjaCBtdmFyLm12YXJfY29udGVudHMgd2l0aFxuICB8IE5vbmUgLT5cbiAgICBiZWdpbiBtYXRjaCBMd3Rfc2VxdWVuY2UudGFrZV9vcHRfbCBtdmFyLnJlYWRlcnMgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG12YXIubXZhcl9jb250ZW50cyA8LSBTb21lIHZcbiAgICAgIHwgU29tZSB3IC0+XG4gICAgICAgIEx3dC53YWtldXBfbGF0ZXIgdyB2XG4gICAgZW5kO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICB8IFNvbWUgXyAtPlxuICAgIGxldCAocmVzLCB3KSA9IEx3dC50YXNrICgpIGluXG4gICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX3IgKHYsIHcpIG12YXIud3JpdGVycyBpblxuICAgIEx3dC5vbl9jYW5jZWwgcmVzIChmdW4gXyAtPiBMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGUpO1xuICAgIHJlc1xuXG5sZXQgbmV4dF93cml0ZXIgbXZhciA9XG4gIG1hdGNoIEx3dF9zZXF1ZW5jZS50YWtlX29wdF9sIG12YXIud3JpdGVycyB3aXRoXG4gIHwgU29tZSh2JywgdykgLT5cbiAgICBtdmFyLm12YXJfY29udGVudHMgPC0gU29tZSB2JztcbiAgICBMd3Qud2FrZXVwX2xhdGVyIHcgKClcbiAgfCBOb25lIC0+XG4gICAgbXZhci5tdmFyX2NvbnRlbnRzIDwtIE5vbmVcblxubGV0IHRha2VfYXZhaWxhYmxlIG12YXIgPVxuICBtYXRjaCBtdmFyLm12YXJfY29udGVudHMgd2l0aFxuICB8IFNvbWUgdiAtPlxuICAgIG5leHRfd3JpdGVyIG12YXI7XG4gICAgU29tZSB2XG4gIHwgTm9uZSAtPlxuICAgIE5vbmVcblxubGV0IHRha2UgbXZhciA9XG4gIG1hdGNoIHRha2VfYXZhaWxhYmxlIG12YXIgd2l0aFxuICB8IFNvbWUgdiAtPiBMd3QucmV0dXJuIHZcbiAgfCBOb25lIC0+IChMd3QuYWRkX3Rhc2tfciBbQG9jYW1sLndhcm5pbmcgXCItM1wiXSkgbXZhci5yZWFkZXJzXG5cbmxldCBpc19lbXB0eSBtdmFyID1cbiAgbWF0Y2ggbXZhci5tdmFyX2NvbnRlbnRzIHdpdGhcbiAgfCBTb21lIF8gLT4gZmFsc2VcbiAgfCBOb25lIC0+IHRydWVcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1Mzg4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imx3dC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiTHd0X3NlcXVlbmNlIiwiTHd0IiwiY3JlYXRlIiwicGFyYW0iLCJsb2NrIiwibSIsInVubG9jayIsIndpdGhfbG9jayIsImlzX2xvY2tlZCIsImlzX2VtcHR5IiwiTHd0X211dGV4Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9kb2dhZGlubS8ub3BhbS9lbGlvbS9saWIvbHd0L2x3dF9tdXRleC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsWUFBQUMsT0FBQUMsT0NnQjRDLDZDQUFzQixDQUFFO0FBQUEsWUFBQUMsS0FBQUM7QUFBQUEsSUFHbEUsY0FDRSwrQ0FJQztBQUFBO0FBQUEsWUFBQUMsT0FBQUQ7QUFBQUEsUUFBQSxNQUdIO0FBQUE7QUFBQSxJQUNLLHNDQUNEO0FBQUEsY0FJaUI7QUFBQSxJQUErQixpQ0FDakQ7QUFBQTtBQUFBLFlBQUFFLFVBQUFGLEdBQUFWO0FBQUFBLFFBQUEsTUFHSDtBQUFBLElBQU07QUFBQTtBQUFBO0FBQUEsc0JBQUFRO0FBQUFBLGNBQ047QUFBQSwyQ0FBQUEsT0FBMEIsV0FBUSxlQUFpQixFQUFDO0FBQUE7QUFBQTtBQUFBLFlBQUFLLFVBQUFILEdBRXBDLFlBQVE7QUFBQSxZQUFBSSxTQUFBSixHQUNULHdDQUErQjtBQUFBLE9BQUFLLFlEekNoRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG4oKiBbTHd0X3NlcXVlbmNlXSBpcyBkZXByZWNhdGVkIOKAkyB3ZSBkb24ndCB3YW50IHVzZXJzIG91dHNpZGUgTHd0IHVzaW5nIGl0LlxuICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgdXNlZCBpbnRlcm5hbGx5IGJ5IEx3dC4gU28sIGJyaWVmbHkgZGlzYWJsZSB3YXJuaW5nIDNcbiAgIChcImRlcHJlY2F0ZWRcIiksIGFuZCBjcmVhdGUgYSBsb2NhbCwgbm9uLWRlcHJlY2F0ZWQgYWxpYXMgZm9yXG4gICBbTHd0X3NlcXVlbmNlXSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBieSB0aGUgcmVzdCBvZiB0aGUgY29kZSBpbiB0aGlzXG4gICBtb2R1bGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFueSBtb3JlIHdhcm5pbmdzLiAqKVxubW9kdWxlIEx3dF9zZXF1ZW5jZSA9IEx3dF9zZXF1ZW5jZVxuXG5vcGVuIEx3dC5JbmZpeFxuXG50eXBlIHQgPSB7IG11dGFibGUgbG9ja2VkIDogYm9vbDsgd2FpdGVycyA6IHVuaXQgTHd0LnUgTHd0X3NlcXVlbmNlLnQgIH1cblxubGV0IGNyZWF0ZSAoKSA9IHsgbG9ja2VkID0gZmFsc2U7IHdhaXRlcnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIH1cblxubGV0IGxvY2sgbSA9XG4gIGlmIG0ubG9ja2VkIHRoZW5cbiAgICAoTHd0LmFkZF90YXNrX3IgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl0pIG0ud2FpdGVyc1xuICBlbHNlIGJlZ2luXG4gICAgbS5sb2NrZWQgPC0gdHJ1ZTtcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgZW5kXG5cbmxldCB1bmxvY2sgbSA9XG4gIGlmIG0ubG9ja2VkIHRoZW4gYmVnaW5cbiAgICBpZiBMd3Rfc2VxdWVuY2UuaXNfZW1wdHkgbS53YWl0ZXJzIHRoZW5cbiAgICAgIG0ubG9ja2VkIDwtIGZhbHNlXG4gICAgZWxzZVxuICAgICAgKCogV2UgZG8gbm90IHVzZSBbTHd0Lndha2V1cF0gaGVyZSB0byBhdm9pZCBhIHN0YWNrIG92ZXJmbG93XG4gICAgICAgICB3aGVuIHVubG9ja2luZyBhIGxvdCBvZiB0aHJlYWRzLiAqKVxuICAgICAgTHd0Lndha2V1cF9sYXRlciAoTHd0X3NlcXVlbmNlLnRha2VfbCBtLndhaXRlcnMpICgpXG4gIGVuZFxuXG5sZXQgd2l0aF9sb2NrIG0gZiA9XG4gIGxvY2sgbSA+Pj0gZnVuICgpIC0+XG4gIEx3dC5maW5hbGl6ZSBmIChmdW4gKCkgLT4gdW5sb2NrIG07IEx3dC5yZXR1cm5fdW5pdClcblxubGV0IGlzX2xvY2tlZCBtID0gbS5sb2NrZWRcbmxldCBpc19lbXB0eSBtID0gTHd0X3NlcXVlbmNlLmlzX2VtcHR5IG0ud2FpdGVyc1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjU0MzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiTHd0IiwiTHd0X3NlcXVlbmNlIiwiU3RkbGliX0xpc3QiLCJMd3RfbXV0ZXgiLCJjcmVhdGUiLCJ3YWl0IiwibXV0ZXgiLCJjdmFyIiwid2FpdGVyIiwibSIsInBhcmFtIiwic2lnbmFsIiwiYXJnIiwiYnJvYWRjYXN0Iiwid2FrZW5lcnMiLCJ4IiwibCIsIndha2VuZXIiLCJicm9hZGNhc3RfZXhuIiwiZXhuIiwiTHd0X2NvbmRpdGlvbiJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvZG9nYWRpbm0vLm9wYW0vZWxpb20vbGliL2x3dC9sd3RfY29uZGl0aW9uLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLFlBQUFDLEtBQUFDLE9BQUFDO0FBQUFBLFFBQUFDLFNDd0NlO0FBQUEsSUFDYixjQUFBQyxJQUFBLFVBRWM7QUFBQSxJQUdkO0FBQUE7QUFBQSxzQkFBQUMsT0FDYSxjQUFNO0FBQUEsc0JBQUFBO0FBQUFBLGNBRWQsWUFFVTtBQUFBLGtCQUFBRCxJQUZWO0FBQUEsY0FDWSxrQ0FDYTtBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFFLE9BQUFKLE1BQUFLO0FBQUFBLElBRy9CO0FBQUE7QUFBQSxZQUNtQjtBQUFBLFlBQWpCO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUR2REo7QUFBQSxrQ0N5REk7QUFBQSxLRHpESjtBQUFBO0FBQUEsR0N5RE07QUFBQSxZQUFBQyxVQUFBTixNQUFBSztBQUFBQTtBQUFBQSxLQUFBRTtBQUFBQSxPQUdXO0FBQUEsb0NBQUFDLEdBQUFDLEdBQWdDLGlCQUFNO0FBQUEsSUFDckQ7QUFBQSxJQUFpRDtBQUFBO0FBQUEsc0JBQUFDLFNBQ3ZCLHVDQUE0QjtBQUFBLHNCQUFVO0FBQUE7QUFBQSxZQUFBQyxjQUFBWCxNQUFBWTtBQUFBQTtBQUFBQSxLQUFBTDtBQUFBQSxPQUdqRDtBQUFBLG9DQUFBQyxHQUFBQyxHQUFnQyxpQkFBTTtBQUFBLElBQ3JEO0FBQUEsSUFBaUQ7QUFBQTtBQUFBLHNCQUFBQyxTQUN2Qix1Q0FBZ0M7QUFBQSxzQkFBVTtBQUFBO0FBQUEsT0FBQUcsZ0JEbkV0RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogT0NhbWwgcHJvbWlzZSBsaWJyYXJ5XG4gKiBodHRwczovL29jc2lnZW4ub3JnL2x3dFxuICogQ29weXJpZ2h0IChjKSAyMDA5LCBNZXRhd2ViIFRlY2hub2xvZ2llcywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogYXJlIG1ldDpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBNRVRBV0VCIFRFQ0hOT0xPR0lFUyBgYEFTIElTJycgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICogUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgTUVUQVdFQiBURUNITk9MT0dJRVMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1JcbiAqIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0VcbiAqIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU5cbiAqIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICopXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5cbnR5cGUgJ2EgdCA9ICdhIEx3dC51IEx3dF9zZXF1ZW5jZS50XG5cbmxldCBjcmVhdGUgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlXG5cbmxldCB3YWl0ID9tdXRleCBjdmFyID1cbiAgbGV0IHdhaXRlciA9IChMd3QuYWRkX3Rhc2tfciBbQG9jYW1sLndhcm5pbmcgXCItM1wiXSkgY3ZhciBpblxuICBsZXQgKCkgPVxuICAgIG1hdGNoIG11dGV4IHdpdGhcbiAgICB8IFNvbWUgbSAtPiBMd3RfbXV0ZXgudW5sb2NrIG1cbiAgICB8IE5vbmUgLT4gKClcbiAgaW5cbiAgTHd0LmZpbmFsaXplXG4gICAgKGZ1biAoKSAtPiB3YWl0ZXIpXG4gICAgKGZ1biAoKSAtPlxuICAgICAgIG1hdGNoIG11dGV4IHdpdGhcbiAgICAgICB8IFNvbWUgbSAtPiBMd3RfbXV0ZXgubG9jayBtXG4gICAgICAgfCBOb25lIC0+IEx3dC5yZXR1cm5fdW5pdClcblxubGV0IHNpZ25hbCBjdmFyIGFyZyA9XG4gIHRyeVxuICAgIEx3dC53YWtldXBfbGF0ZXIgKEx3dF9zZXF1ZW5jZS50YWtlX2wgY3ZhcikgYXJnXG4gIHdpdGggTHd0X3NlcXVlbmNlLkVtcHR5IC0+XG4gICAgKClcblxubGV0IGJyb2FkY2FzdCBjdmFyIGFyZyA9XG4gIGxldCB3YWtlbmVycyA9IEx3dF9zZXF1ZW5jZS5mb2xkX3IgKGZ1biB4IGwgLT4geCA6OiBsKSBjdmFyIFtdIGluXG4gIEx3dF9zZXF1ZW5jZS5pdGVyX25vZGVfbCBMd3Rfc2VxdWVuY2UucmVtb3ZlIGN2YXI7XG4gIExpc3QuaXRlciAoZnVuIHdha2VuZXIgLT4gTHd0Lndha2V1cF9sYXRlciB3YWtlbmVyIGFyZykgd2FrZW5lcnNcblxubGV0IGJyb2FkY2FzdF9leG4gY3ZhciBleG4gPVxuICBsZXQgd2FrZW5lcnMgPSBMd3Rfc2VxdWVuY2UuZm9sZF9yIChmdW4geCBsIC0+IHggOjogbCkgY3ZhciBbXSBpblxuICBMd3Rfc2VxdWVuY2UuaXRlcl9ub2RlX2wgTHd0X3NlcXVlbmNlLnJlbW92ZSBjdmFyO1xuICBMaXN0Lml0ZXIgKGZ1biB3YWtlbmVyIC0+IEx3dC53YWtldXBfbGF0ZXJfZXhuIHdha2VuZXIgZXhuKSB3YWtlbmVyc1xuIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
